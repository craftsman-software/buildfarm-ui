/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const build = $root.build = (() => {

    /**
     * Namespace build.
     * @exports build
     * @namespace
     */
    const build = {};

    build.bazel = (function() {

        /**
         * Namespace bazel.
         * @memberof build
         * @namespace
         */
        const bazel = {};

        bazel.remote = (function() {

            /**
             * Namespace remote.
             * @memberof build.bazel
             * @namespace
             */
            const remote = {};

            remote.execution = (function() {

                /**
                 * Namespace execution.
                 * @memberof build.bazel.remote
                 * @namespace
                 */
                const execution = {};

                execution.v2 = (function() {

                    /**
                     * Namespace v2.
                     * @memberof build.bazel.remote.execution
                     * @namespace
                     */
                    const v2 = {};

                    v2.Execution = (function() {

                        /**
                         * Constructs a new Execution service.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an Execution
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function Execution(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (Execution.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Execution;

                        /**
                         * Creates new Execution service using the specified rpc implementation.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Execution
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {Execution} RPC service. Useful where requests and/or responses are streamed.
                         */
                        Execution.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.Execution#execute}.
                         * @memberof build.bazel.remote.execution.v2.Execution
                         * @typedef ExecuteCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {google.longrunning.Operation} [response] Operation
                         */

                        /**
                         * Calls Execute.
                         * @function execute
                         * @memberof build.bazel.remote.execution.v2.Execution
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IExecuteRequest} request ExecuteRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.Execution.ExecuteCallback} callback Node-style callback called with the error, if any, and Operation
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(Execution.prototype.execute = function execute(request, callback) {
                            return this.rpcCall(execute, $root.build.bazel.remote.execution.v2.ExecuteRequest, $root.google.longrunning.Operation, request, callback);
                        }, "name", { value: "Execute" });

                        /**
                         * Calls Execute.
                         * @function execute
                         * @memberof build.bazel.remote.execution.v2.Execution
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IExecuteRequest} request ExecuteRequest message or plain object
                         * @returns {Promise<google.longrunning.Operation>} Promise
                         * @variation 2
                         */

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.Execution#waitExecution}.
                         * @memberof build.bazel.remote.execution.v2.Execution
                         * @typedef WaitExecutionCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {google.longrunning.Operation} [response] Operation
                         */

                        /**
                         * Calls WaitExecution.
                         * @function waitExecution
                         * @memberof build.bazel.remote.execution.v2.Execution
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IWaitExecutionRequest} request WaitExecutionRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.Execution.WaitExecutionCallback} callback Node-style callback called with the error, if any, and Operation
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(Execution.prototype.waitExecution = function waitExecution(request, callback) {
                            return this.rpcCall(waitExecution, $root.build.bazel.remote.execution.v2.WaitExecutionRequest, $root.google.longrunning.Operation, request, callback);
                        }, "name", { value: "WaitExecution" });

                        /**
                         * Calls WaitExecution.
                         * @function waitExecution
                         * @memberof build.bazel.remote.execution.v2.Execution
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IWaitExecutionRequest} request WaitExecutionRequest message or plain object
                         * @returns {Promise<google.longrunning.Operation>} Promise
                         * @variation 2
                         */

                        return Execution;
                    })();

                    v2.ActionCache = (function() {

                        /**
                         * Constructs a new ActionCache service.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ActionCache
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function ActionCache(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (ActionCache.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ActionCache;

                        /**
                         * Creates new ActionCache service using the specified rpc implementation.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ActionCache
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {ActionCache} RPC service. Useful where requests and/or responses are streamed.
                         */
                        ActionCache.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.ActionCache#getActionResult}.
                         * @memberof build.bazel.remote.execution.v2.ActionCache
                         * @typedef GetActionResultCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.execution.v2.ActionResult} [response] ActionResult
                         */

                        /**
                         * Calls GetActionResult.
                         * @function getActionResult
                         * @memberof build.bazel.remote.execution.v2.ActionCache
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IGetActionResultRequest} request GetActionResultRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.ActionCache.GetActionResultCallback} callback Node-style callback called with the error, if any, and ActionResult
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(ActionCache.prototype.getActionResult = function getActionResult(request, callback) {
                            return this.rpcCall(getActionResult, $root.build.bazel.remote.execution.v2.GetActionResultRequest, $root.build.bazel.remote.execution.v2.ActionResult, request, callback);
                        }, "name", { value: "GetActionResult" });

                        /**
                         * Calls GetActionResult.
                         * @function getActionResult
                         * @memberof build.bazel.remote.execution.v2.ActionCache
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IGetActionResultRequest} request GetActionResultRequest message or plain object
                         * @returns {Promise<build.bazel.remote.execution.v2.ActionResult>} Promise
                         * @variation 2
                         */

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.ActionCache#updateActionResult}.
                         * @memberof build.bazel.remote.execution.v2.ActionCache
                         * @typedef UpdateActionResultCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.execution.v2.ActionResult} [response] ActionResult
                         */

                        /**
                         * Calls UpdateActionResult.
                         * @function updateActionResult
                         * @memberof build.bazel.remote.execution.v2.ActionCache
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IUpdateActionResultRequest} request UpdateActionResultRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.ActionCache.UpdateActionResultCallback} callback Node-style callback called with the error, if any, and ActionResult
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(ActionCache.prototype.updateActionResult = function updateActionResult(request, callback) {
                            return this.rpcCall(updateActionResult, $root.build.bazel.remote.execution.v2.UpdateActionResultRequest, $root.build.bazel.remote.execution.v2.ActionResult, request, callback);
                        }, "name", { value: "UpdateActionResult" });

                        /**
                         * Calls UpdateActionResult.
                         * @function updateActionResult
                         * @memberof build.bazel.remote.execution.v2.ActionCache
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IUpdateActionResultRequest} request UpdateActionResultRequest message or plain object
                         * @returns {Promise<build.bazel.remote.execution.v2.ActionResult>} Promise
                         * @variation 2
                         */

                        return ActionCache;
                    })();

                    v2.ContentAddressableStorage = (function() {

                        /**
                         * Constructs a new ContentAddressableStorage service.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a ContentAddressableStorage
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function ContentAddressableStorage(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (ContentAddressableStorage.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ContentAddressableStorage;

                        /**
                         * Creates new ContentAddressableStorage service using the specified rpc implementation.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {ContentAddressableStorage} RPC service. Useful where requests and/or responses are streamed.
                         */
                        ContentAddressableStorage.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.ContentAddressableStorage#findMissingBlobs}.
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @typedef FindMissingBlobsCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.execution.v2.FindMissingBlobsResponse} [response] FindMissingBlobsResponse
                         */

                        /**
                         * Calls FindMissingBlobs.
                         * @function findMissingBlobs
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsRequest} request FindMissingBlobsRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.ContentAddressableStorage.FindMissingBlobsCallback} callback Node-style callback called with the error, if any, and FindMissingBlobsResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(ContentAddressableStorage.prototype.findMissingBlobs = function findMissingBlobs(request, callback) {
                            return this.rpcCall(findMissingBlobs, $root.build.bazel.remote.execution.v2.FindMissingBlobsRequest, $root.build.bazel.remote.execution.v2.FindMissingBlobsResponse, request, callback);
                        }, "name", { value: "FindMissingBlobs" });

                        /**
                         * Calls FindMissingBlobs.
                         * @function findMissingBlobs
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsRequest} request FindMissingBlobsRequest message or plain object
                         * @returns {Promise<build.bazel.remote.execution.v2.FindMissingBlobsResponse>} Promise
                         * @variation 2
                         */

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.ContentAddressableStorage#batchUpdateBlobs}.
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @typedef BatchUpdateBlobsCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse} [response] BatchUpdateBlobsResponse
                         */

                        /**
                         * Calls BatchUpdateBlobs.
                         * @function batchUpdateBlobs
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsRequest} request BatchUpdateBlobsRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobsCallback} callback Node-style callback called with the error, if any, and BatchUpdateBlobsResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(ContentAddressableStorage.prototype.batchUpdateBlobs = function batchUpdateBlobs(request, callback) {
                            return this.rpcCall(batchUpdateBlobs, $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest, $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse, request, callback);
                        }, "name", { value: "BatchUpdateBlobs" });

                        /**
                         * Calls BatchUpdateBlobs.
                         * @function batchUpdateBlobs
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsRequest} request BatchUpdateBlobsRequest message or plain object
                         * @returns {Promise<build.bazel.remote.execution.v2.BatchUpdateBlobsResponse>} Promise
                         * @variation 2
                         */

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.ContentAddressableStorage#batchReadBlobs}.
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @typedef BatchReadBlobsCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.execution.v2.BatchReadBlobsResponse} [response] BatchReadBlobsResponse
                         */

                        /**
                         * Calls BatchReadBlobs.
                         * @function batchReadBlobs
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsRequest} request BatchReadBlobsRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobsCallback} callback Node-style callback called with the error, if any, and BatchReadBlobsResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(ContentAddressableStorage.prototype.batchReadBlobs = function batchReadBlobs(request, callback) {
                            return this.rpcCall(batchReadBlobs, $root.build.bazel.remote.execution.v2.BatchReadBlobsRequest, $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse, request, callback);
                        }, "name", { value: "BatchReadBlobs" });

                        /**
                         * Calls BatchReadBlobs.
                         * @function batchReadBlobs
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsRequest} request BatchReadBlobsRequest message or plain object
                         * @returns {Promise<build.bazel.remote.execution.v2.BatchReadBlobsResponse>} Promise
                         * @variation 2
                         */

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.ContentAddressableStorage#getTree}.
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @typedef GetTreeCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.execution.v2.GetTreeResponse} [response] GetTreeResponse
                         */

                        /**
                         * Calls GetTree.
                         * @function getTree
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IGetTreeRequest} request GetTreeRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.ContentAddressableStorage.GetTreeCallback} callback Node-style callback called with the error, if any, and GetTreeResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(ContentAddressableStorage.prototype.getTree = function getTree(request, callback) {
                            return this.rpcCall(getTree, $root.build.bazel.remote.execution.v2.GetTreeRequest, $root.build.bazel.remote.execution.v2.GetTreeResponse, request, callback);
                        }, "name", { value: "GetTree" });

                        /**
                         * Calls GetTree.
                         * @function getTree
                         * @memberof build.bazel.remote.execution.v2.ContentAddressableStorage
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IGetTreeRequest} request GetTreeRequest message or plain object
                         * @returns {Promise<build.bazel.remote.execution.v2.GetTreeResponse>} Promise
                         * @variation 2
                         */

                        return ContentAddressableStorage;
                    })();

                    v2.Capabilities = (function() {

                        /**
                         * Constructs a new Capabilities service.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a Capabilities
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function Capabilities(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (Capabilities.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Capabilities;

                        /**
                         * Creates new Capabilities service using the specified rpc implementation.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Capabilities
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {Capabilities} RPC service. Useful where requests and/or responses are streamed.
                         */
                        Capabilities.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link build.bazel.remote.execution.v2.Capabilities#getCapabilities}.
                         * @memberof build.bazel.remote.execution.v2.Capabilities
                         * @typedef GetCapabilitiesCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.execution.v2.ServerCapabilities} [response] ServerCapabilities
                         */

                        /**
                         * Calls GetCapabilities.
                         * @function getCapabilities
                         * @memberof build.bazel.remote.execution.v2.Capabilities
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IGetCapabilitiesRequest} request GetCapabilitiesRequest message or plain object
                         * @param {build.bazel.remote.execution.v2.Capabilities.GetCapabilitiesCallback} callback Node-style callback called with the error, if any, and ServerCapabilities
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(Capabilities.prototype.getCapabilities = function getCapabilities(request, callback) {
                            return this.rpcCall(getCapabilities, $root.build.bazel.remote.execution.v2.GetCapabilitiesRequest, $root.build.bazel.remote.execution.v2.ServerCapabilities, request, callback);
                        }, "name", { value: "GetCapabilities" });

                        /**
                         * Calls GetCapabilities.
                         * @function getCapabilities
                         * @memberof build.bazel.remote.execution.v2.Capabilities
                         * @instance
                         * @param {build.bazel.remote.execution.v2.IGetCapabilitiesRequest} request GetCapabilitiesRequest message or plain object
                         * @returns {Promise<build.bazel.remote.execution.v2.ServerCapabilities>} Promise
                         * @variation 2
                         */

                        return Capabilities;
                    })();

                    v2.Action = (function() {

                        /**
                         * Properties of an Action.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IAction
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [commandDigest] Action commandDigest
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [inputRootDigest] Action inputRootDigest
                         * @property {google.protobuf.IDuration|null} [timeout] Action timeout
                         * @property {boolean|null} [doNotCache] Action doNotCache
                         * @property {Uint8Array|null} [salt] Action salt
                         * @property {build.bazel.remote.execution.v2.IPlatform|null} [platform] Action platform
                         */

                        /**
                         * Constructs a new Action.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an Action.
                         * @implements IAction
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IAction=} [properties] Properties to set
                         */
                        function Action(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Action commandDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} commandDigest
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @instance
                         */
                        Action.prototype.commandDigest = null;

                        /**
                         * Action inputRootDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} inputRootDigest
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @instance
                         */
                        Action.prototype.inputRootDigest = null;

                        /**
                         * Action timeout.
                         * @member {google.protobuf.IDuration|null|undefined} timeout
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @instance
                         */
                        Action.prototype.timeout = null;

                        /**
                         * Action doNotCache.
                         * @member {boolean} doNotCache
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @instance
                         */
                        Action.prototype.doNotCache = false;

                        /**
                         * Action salt.
                         * @member {Uint8Array} salt
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @instance
                         */
                        Action.prototype.salt = $util.newBuffer([]);

                        /**
                         * Action platform.
                         * @member {build.bazel.remote.execution.v2.IPlatform|null|undefined} platform
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @instance
                         */
                        Action.prototype.platform = null;

                        /**
                         * Creates a new Action instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {build.bazel.remote.execution.v2.IAction=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.Action} Action instance
                         */
                        Action.create = function create(properties) {
                            return new Action(properties);
                        };

                        /**
                         * Encodes the specified Action message. Does not implicitly {@link build.bazel.remote.execution.v2.Action.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {build.bazel.remote.execution.v2.IAction} message Action message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Action.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.commandDigest != null && Object.hasOwnProperty.call(message, "commandDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.commandDigest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.inputRootDigest != null && Object.hasOwnProperty.call(message, "inputRootDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.inputRootDigest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                                $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.doNotCache != null && Object.hasOwnProperty.call(message, "doNotCache"))
                                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.doNotCache);
                            if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.salt);
                            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                                $root.build.bazel.remote.execution.v2.Platform.encode(message.platform, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Action message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Action.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {build.bazel.remote.execution.v2.IAction} message Action message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Action.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Action message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.Action} Action
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Action.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Action();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.commandDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.inputRootDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 7: {
                                        message.doNotCache = reader.bool();
                                        break;
                                    }
                                case 9: {
                                        message.salt = reader.bytes();
                                        break;
                                    }
                                case 10: {
                                        message.platform = $root.build.bazel.remote.execution.v2.Platform.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Action message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.Action} Action
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Action.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Action message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Action.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.commandDigest != null && message.hasOwnProperty("commandDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.commandDigest);
                                if (error)
                                    return "commandDigest." + error;
                            }
                            if (message.inputRootDigest != null && message.hasOwnProperty("inputRootDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.inputRootDigest);
                                if (error)
                                    return "inputRootDigest." + error;
                            }
                            if (message.timeout != null && message.hasOwnProperty("timeout")) {
                                let error = $root.google.protobuf.Duration.verify(message.timeout);
                                if (error)
                                    return "timeout." + error;
                            }
                            if (message.doNotCache != null && message.hasOwnProperty("doNotCache"))
                                if (typeof message.doNotCache !== "boolean")
                                    return "doNotCache: boolean expected";
                            if (message.salt != null && message.hasOwnProperty("salt"))
                                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                                    return "salt: buffer expected";
                            if (message.platform != null && message.hasOwnProperty("platform")) {
                                let error = $root.build.bazel.remote.execution.v2.Platform.verify(message.platform);
                                if (error)
                                    return "platform." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an Action message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.Action} Action
                         */
                        Action.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.Action)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.Action();
                            if (object.commandDigest != null) {
                                if (typeof object.commandDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.Action.commandDigest: object expected");
                                message.commandDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.commandDigest);
                            }
                            if (object.inputRootDigest != null) {
                                if (typeof object.inputRootDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.Action.inputRootDigest: object expected");
                                message.inputRootDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.inputRootDigest);
                            }
                            if (object.timeout != null) {
                                if (typeof object.timeout !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.Action.timeout: object expected");
                                message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                            }
                            if (object.doNotCache != null)
                                message.doNotCache = Boolean(object.doNotCache);
                            if (object.salt != null)
                                if (typeof object.salt === "string")
                                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                                else if (object.salt.length >= 0)
                                    message.salt = object.salt;
                            if (object.platform != null) {
                                if (typeof object.platform !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.Action.platform: object expected");
                                message.platform = $root.build.bazel.remote.execution.v2.Platform.fromObject(object.platform);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an Action message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {build.bazel.remote.execution.v2.Action} message Action
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Action.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.commandDigest = null;
                                object.inputRootDigest = null;
                                object.timeout = null;
                                object.doNotCache = false;
                                if (options.bytes === String)
                                    object.salt = "";
                                else {
                                    object.salt = [];
                                    if (options.bytes !== Array)
                                        object.salt = $util.newBuffer(object.salt);
                                }
                                object.platform = null;
                            }
                            if (message.commandDigest != null && message.hasOwnProperty("commandDigest"))
                                object.commandDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.commandDigest, options);
                            if (message.inputRootDigest != null && message.hasOwnProperty("inputRootDigest"))
                                object.inputRootDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.inputRootDigest, options);
                            if (message.timeout != null && message.hasOwnProperty("timeout"))
                                object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                            if (message.doNotCache != null && message.hasOwnProperty("doNotCache"))
                                object.doNotCache = message.doNotCache;
                            if (message.salt != null && message.hasOwnProperty("salt"))
                                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
                            if (message.platform != null && message.hasOwnProperty("platform"))
                                object.platform = $root.build.bazel.remote.execution.v2.Platform.toObject(message.platform, options);
                            return object;
                        };

                        /**
                         * Converts this Action to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Action.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Action
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.Action
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Action.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.Action";
                        };

                        return Action;
                    })();

                    v2.Command = (function() {

                        /**
                         * Properties of a Command.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface ICommand
                         * @property {Array.<string>|null} ["arguments"] Command arguments
                         * @property {Array.<build.bazel.remote.execution.v2.Command.IEnvironmentVariable>|null} [environmentVariables] Command environmentVariables
                         * @property {Array.<string>|null} [outputFiles] Command outputFiles
                         * @property {Array.<string>|null} [outputDirectories] Command outputDirectories
                         * @property {Array.<string>|null} [outputPaths] Command outputPaths
                         * @property {build.bazel.remote.execution.v2.IPlatform|null} [platform] Command platform
                         * @property {string|null} [workingDirectory] Command workingDirectory
                         * @property {Array.<string>|null} [outputNodeProperties] Command outputNodeProperties
                         * @property {build.bazel.remote.execution.v2.Command.OutputDirectoryFormat|null} [outputDirectoryFormat] Command outputDirectoryFormat
                         */

                        /**
                         * Constructs a new Command.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a Command.
                         * @implements ICommand
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.ICommand=} [properties] Properties to set
                         */
                        function Command(properties) {
                            this["arguments"] = [];
                            this.environmentVariables = [];
                            this.outputFiles = [];
                            this.outputDirectories = [];
                            this.outputPaths = [];
                            this.outputNodeProperties = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Command arguments.
                         * @member {Array.<string>} arguments
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype["arguments"] = $util.emptyArray;

                        /**
                         * Command environmentVariables.
                         * @member {Array.<build.bazel.remote.execution.v2.Command.IEnvironmentVariable>} environmentVariables
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.environmentVariables = $util.emptyArray;

                        /**
                         * Command outputFiles.
                         * @member {Array.<string>} outputFiles
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.outputFiles = $util.emptyArray;

                        /**
                         * Command outputDirectories.
                         * @member {Array.<string>} outputDirectories
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.outputDirectories = $util.emptyArray;

                        /**
                         * Command outputPaths.
                         * @member {Array.<string>} outputPaths
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.outputPaths = $util.emptyArray;

                        /**
                         * Command platform.
                         * @member {build.bazel.remote.execution.v2.IPlatform|null|undefined} platform
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.platform = null;

                        /**
                         * Command workingDirectory.
                         * @member {string} workingDirectory
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.workingDirectory = "";

                        /**
                         * Command outputNodeProperties.
                         * @member {Array.<string>} outputNodeProperties
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.outputNodeProperties = $util.emptyArray;

                        /**
                         * Command outputDirectoryFormat.
                         * @member {build.bazel.remote.execution.v2.Command.OutputDirectoryFormat} outputDirectoryFormat
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         */
                        Command.prototype.outputDirectoryFormat = 0;

                        /**
                         * Creates a new Command instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICommand=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.Command} Command instance
                         */
                        Command.create = function create(properties) {
                            return new Command(properties);
                        };

                        /**
                         * Encodes the specified Command message. Does not implicitly {@link build.bazel.remote.execution.v2.Command.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICommand} message Command message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Command.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message["arguments"] != null && message["arguments"].length)
                                for (let i = 0; i < message["arguments"].length; ++i)
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message["arguments"][i]);
                            if (message.environmentVariables != null && message.environmentVariables.length)
                                for (let i = 0; i < message.environmentVariables.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Command.EnvironmentVariable.encode(message.environmentVariables[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.outputFiles != null && message.outputFiles.length)
                                for (let i = 0; i < message.outputFiles.length; ++i)
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputFiles[i]);
                            if (message.outputDirectories != null && message.outputDirectories.length)
                                for (let i = 0; i < message.outputDirectories.length; ++i)
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.outputDirectories[i]);
                            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                                $root.build.bazel.remote.execution.v2.Platform.encode(message.platform, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.workingDirectory != null && Object.hasOwnProperty.call(message, "workingDirectory"))
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.workingDirectory);
                            if (message.outputPaths != null && message.outputPaths.length)
                                for (let i = 0; i < message.outputPaths.length; ++i)
                                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.outputPaths[i]);
                            if (message.outputNodeProperties != null && message.outputNodeProperties.length)
                                for (let i = 0; i < message.outputNodeProperties.length; ++i)
                                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.outputNodeProperties[i]);
                            if (message.outputDirectoryFormat != null && Object.hasOwnProperty.call(message, "outputDirectoryFormat"))
                                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.outputDirectoryFormat);
                            return writer;
                        };

                        /**
                         * Encodes the specified Command message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Command.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICommand} message Command message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Command.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Command message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.Command} Command
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Command.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Command();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message["arguments"] && message["arguments"].length))
                                            message["arguments"] = [];
                                        message["arguments"].push(reader.string());
                                        break;
                                    }
                                case 2: {
                                        if (!(message.environmentVariables && message.environmentVariables.length))
                                            message.environmentVariables = [];
                                        message.environmentVariables.push($root.build.bazel.remote.execution.v2.Command.EnvironmentVariable.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 3: {
                                        if (!(message.outputFiles && message.outputFiles.length))
                                            message.outputFiles = [];
                                        message.outputFiles.push(reader.string());
                                        break;
                                    }
                                case 4: {
                                        if (!(message.outputDirectories && message.outputDirectories.length))
                                            message.outputDirectories = [];
                                        message.outputDirectories.push(reader.string());
                                        break;
                                    }
                                case 7: {
                                        if (!(message.outputPaths && message.outputPaths.length))
                                            message.outputPaths = [];
                                        message.outputPaths.push(reader.string());
                                        break;
                                    }
                                case 5: {
                                        message.platform = $root.build.bazel.remote.execution.v2.Platform.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        message.workingDirectory = reader.string();
                                        break;
                                    }
                                case 8: {
                                        if (!(message.outputNodeProperties && message.outputNodeProperties.length))
                                            message.outputNodeProperties = [];
                                        message.outputNodeProperties.push(reader.string());
                                        break;
                                    }
                                case 9: {
                                        message.outputDirectoryFormat = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Command message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.Command} Command
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Command.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Command message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Command.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message["arguments"] != null && message.hasOwnProperty("arguments")) {
                                if (!Array.isArray(message["arguments"]))
                                    return "arguments: array expected";
                                for (let i = 0; i < message["arguments"].length; ++i)
                                    if (!$util.isString(message["arguments"][i]))
                                        return "arguments: string[] expected";
                            }
                            if (message.environmentVariables != null && message.hasOwnProperty("environmentVariables")) {
                                if (!Array.isArray(message.environmentVariables))
                                    return "environmentVariables: array expected";
                                for (let i = 0; i < message.environmentVariables.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Command.EnvironmentVariable.verify(message.environmentVariables[i]);
                                    if (error)
                                        return "environmentVariables." + error;
                                }
                            }
                            if (message.outputFiles != null && message.hasOwnProperty("outputFiles")) {
                                if (!Array.isArray(message.outputFiles))
                                    return "outputFiles: array expected";
                                for (let i = 0; i < message.outputFiles.length; ++i)
                                    if (!$util.isString(message.outputFiles[i]))
                                        return "outputFiles: string[] expected";
                            }
                            if (message.outputDirectories != null && message.hasOwnProperty("outputDirectories")) {
                                if (!Array.isArray(message.outputDirectories))
                                    return "outputDirectories: array expected";
                                for (let i = 0; i < message.outputDirectories.length; ++i)
                                    if (!$util.isString(message.outputDirectories[i]))
                                        return "outputDirectories: string[] expected";
                            }
                            if (message.outputPaths != null && message.hasOwnProperty("outputPaths")) {
                                if (!Array.isArray(message.outputPaths))
                                    return "outputPaths: array expected";
                                for (let i = 0; i < message.outputPaths.length; ++i)
                                    if (!$util.isString(message.outputPaths[i]))
                                        return "outputPaths: string[] expected";
                            }
                            if (message.platform != null && message.hasOwnProperty("platform")) {
                                let error = $root.build.bazel.remote.execution.v2.Platform.verify(message.platform);
                                if (error)
                                    return "platform." + error;
                            }
                            if (message.workingDirectory != null && message.hasOwnProperty("workingDirectory"))
                                if (!$util.isString(message.workingDirectory))
                                    return "workingDirectory: string expected";
                            if (message.outputNodeProperties != null && message.hasOwnProperty("outputNodeProperties")) {
                                if (!Array.isArray(message.outputNodeProperties))
                                    return "outputNodeProperties: array expected";
                                for (let i = 0; i < message.outputNodeProperties.length; ++i)
                                    if (!$util.isString(message.outputNodeProperties[i]))
                                        return "outputNodeProperties: string[] expected";
                            }
                            if (message.outputDirectoryFormat != null && message.hasOwnProperty("outputDirectoryFormat"))
                                switch (message.outputDirectoryFormat) {
                                default:
                                    return "outputDirectoryFormat: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a Command message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.Command} Command
                         */
                        Command.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.Command)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.Command();
                            if (object["arguments"]) {
                                if (!Array.isArray(object["arguments"]))
                                    throw TypeError(".build.bazel.remote.execution.v2.Command.arguments: array expected");
                                message["arguments"] = [];
                                for (let i = 0; i < object["arguments"].length; ++i)
                                    message["arguments"][i] = String(object["arguments"][i]);
                            }
                            if (object.environmentVariables) {
                                if (!Array.isArray(object.environmentVariables))
                                    throw TypeError(".build.bazel.remote.execution.v2.Command.environmentVariables: array expected");
                                message.environmentVariables = [];
                                for (let i = 0; i < object.environmentVariables.length; ++i) {
                                    if (typeof object.environmentVariables[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.Command.environmentVariables: object expected");
                                    message.environmentVariables[i] = $root.build.bazel.remote.execution.v2.Command.EnvironmentVariable.fromObject(object.environmentVariables[i]);
                                }
                            }
                            if (object.outputFiles) {
                                if (!Array.isArray(object.outputFiles))
                                    throw TypeError(".build.bazel.remote.execution.v2.Command.outputFiles: array expected");
                                message.outputFiles = [];
                                for (let i = 0; i < object.outputFiles.length; ++i)
                                    message.outputFiles[i] = String(object.outputFiles[i]);
                            }
                            if (object.outputDirectories) {
                                if (!Array.isArray(object.outputDirectories))
                                    throw TypeError(".build.bazel.remote.execution.v2.Command.outputDirectories: array expected");
                                message.outputDirectories = [];
                                for (let i = 0; i < object.outputDirectories.length; ++i)
                                    message.outputDirectories[i] = String(object.outputDirectories[i]);
                            }
                            if (object.outputPaths) {
                                if (!Array.isArray(object.outputPaths))
                                    throw TypeError(".build.bazel.remote.execution.v2.Command.outputPaths: array expected");
                                message.outputPaths = [];
                                for (let i = 0; i < object.outputPaths.length; ++i)
                                    message.outputPaths[i] = String(object.outputPaths[i]);
                            }
                            if (object.platform != null) {
                                if (typeof object.platform !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.Command.platform: object expected");
                                message.platform = $root.build.bazel.remote.execution.v2.Platform.fromObject(object.platform);
                            }
                            if (object.workingDirectory != null)
                                message.workingDirectory = String(object.workingDirectory);
                            if (object.outputNodeProperties) {
                                if (!Array.isArray(object.outputNodeProperties))
                                    throw TypeError(".build.bazel.remote.execution.v2.Command.outputNodeProperties: array expected");
                                message.outputNodeProperties = [];
                                for (let i = 0; i < object.outputNodeProperties.length; ++i)
                                    message.outputNodeProperties[i] = String(object.outputNodeProperties[i]);
                            }
                            switch (object.outputDirectoryFormat) {
                            default:
                                if (typeof object.outputDirectoryFormat === "number") {
                                    message.outputDirectoryFormat = object.outputDirectoryFormat;
                                    break;
                                }
                                break;
                            case "TREE_ONLY":
                            case 0:
                                message.outputDirectoryFormat = 0;
                                break;
                            case "DIRECTORY_ONLY":
                            case 1:
                                message.outputDirectoryFormat = 1;
                                break;
                            case "TREE_AND_DIRECTORY":
                            case 2:
                                message.outputDirectoryFormat = 2;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Command message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {build.bazel.remote.execution.v2.Command} message Command
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Command.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object["arguments"] = [];
                                object.environmentVariables = [];
                                object.outputFiles = [];
                                object.outputDirectories = [];
                                object.outputPaths = [];
                                object.outputNodeProperties = [];
                            }
                            if (options.defaults) {
                                object.platform = null;
                                object.workingDirectory = "";
                                object.outputDirectoryFormat = options.enums === String ? "TREE_ONLY" : 0;
                            }
                            if (message["arguments"] && message["arguments"].length) {
                                object["arguments"] = [];
                                for (let j = 0; j < message["arguments"].length; ++j)
                                    object["arguments"][j] = message["arguments"][j];
                            }
                            if (message.environmentVariables && message.environmentVariables.length) {
                                object.environmentVariables = [];
                                for (let j = 0; j < message.environmentVariables.length; ++j)
                                    object.environmentVariables[j] = $root.build.bazel.remote.execution.v2.Command.EnvironmentVariable.toObject(message.environmentVariables[j], options);
                            }
                            if (message.outputFiles && message.outputFiles.length) {
                                object.outputFiles = [];
                                for (let j = 0; j < message.outputFiles.length; ++j)
                                    object.outputFiles[j] = message.outputFiles[j];
                            }
                            if (message.outputDirectories && message.outputDirectories.length) {
                                object.outputDirectories = [];
                                for (let j = 0; j < message.outputDirectories.length; ++j)
                                    object.outputDirectories[j] = message.outputDirectories[j];
                            }
                            if (message.platform != null && message.hasOwnProperty("platform"))
                                object.platform = $root.build.bazel.remote.execution.v2.Platform.toObject(message.platform, options);
                            if (message.workingDirectory != null && message.hasOwnProperty("workingDirectory"))
                                object.workingDirectory = message.workingDirectory;
                            if (message.outputPaths && message.outputPaths.length) {
                                object.outputPaths = [];
                                for (let j = 0; j < message.outputPaths.length; ++j)
                                    object.outputPaths[j] = message.outputPaths[j];
                            }
                            if (message.outputNodeProperties && message.outputNodeProperties.length) {
                                object.outputNodeProperties = [];
                                for (let j = 0; j < message.outputNodeProperties.length; ++j)
                                    object.outputNodeProperties[j] = message.outputNodeProperties[j];
                            }
                            if (message.outputDirectoryFormat != null && message.hasOwnProperty("outputDirectoryFormat"))
                                object.outputDirectoryFormat = options.enums === String ? $root.build.bazel.remote.execution.v2.Command.OutputDirectoryFormat[message.outputDirectoryFormat] === undefined ? message.outputDirectoryFormat : $root.build.bazel.remote.execution.v2.Command.OutputDirectoryFormat[message.outputDirectoryFormat] : message.outputDirectoryFormat;
                            return object;
                        };

                        /**
                         * Converts this Command to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Command.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Command
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.Command
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.Command";
                        };

                        Command.EnvironmentVariable = (function() {

                            /**
                             * Properties of an EnvironmentVariable.
                             * @memberof build.bazel.remote.execution.v2.Command
                             * @interface IEnvironmentVariable
                             * @property {string|null} [name] EnvironmentVariable name
                             * @property {string|null} [value] EnvironmentVariable value
                             */

                            /**
                             * Constructs a new EnvironmentVariable.
                             * @memberof build.bazel.remote.execution.v2.Command
                             * @classdesc Represents an EnvironmentVariable.
                             * @implements IEnvironmentVariable
                             * @constructor
                             * @param {build.bazel.remote.execution.v2.Command.IEnvironmentVariable=} [properties] Properties to set
                             */
                            function EnvironmentVariable(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * EnvironmentVariable name.
                             * @member {string} name
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @instance
                             */
                            EnvironmentVariable.prototype.name = "";

                            /**
                             * EnvironmentVariable value.
                             * @member {string} value
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @instance
                             */
                            EnvironmentVariable.prototype.value = "";

                            /**
                             * Creates a new EnvironmentVariable instance using the specified properties.
                             * @function create
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {build.bazel.remote.execution.v2.Command.IEnvironmentVariable=} [properties] Properties to set
                             * @returns {build.bazel.remote.execution.v2.Command.EnvironmentVariable} EnvironmentVariable instance
                             */
                            EnvironmentVariable.create = function create(properties) {
                                return new EnvironmentVariable(properties);
                            };

                            /**
                             * Encodes the specified EnvironmentVariable message. Does not implicitly {@link build.bazel.remote.execution.v2.Command.EnvironmentVariable.verify|verify} messages.
                             * @function encode
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {build.bazel.remote.execution.v2.Command.IEnvironmentVariable} message EnvironmentVariable message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            EnvironmentVariable.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                                return writer;
                            };

                            /**
                             * Encodes the specified EnvironmentVariable message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Command.EnvironmentVariable.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {build.bazel.remote.execution.v2.Command.IEnvironmentVariable} message EnvironmentVariable message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            EnvironmentVariable.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an EnvironmentVariable message from the specified reader or buffer.
                             * @function decode
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {build.bazel.remote.execution.v2.Command.EnvironmentVariable} EnvironmentVariable
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            EnvironmentVariable.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Command.EnvironmentVariable();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.name = reader.string();
                                            break;
                                        }
                                    case 2: {
                                            message.value = reader.string();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an EnvironmentVariable message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {build.bazel.remote.execution.v2.Command.EnvironmentVariable} EnvironmentVariable
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            EnvironmentVariable.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an EnvironmentVariable message.
                             * @function verify
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            EnvironmentVariable.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                if (message.value != null && message.hasOwnProperty("value"))
                                    if (!$util.isString(message.value))
                                        return "value: string expected";
                                return null;
                            };

                            /**
                             * Creates an EnvironmentVariable message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {build.bazel.remote.execution.v2.Command.EnvironmentVariable} EnvironmentVariable
                             */
                            EnvironmentVariable.fromObject = function fromObject(object) {
                                if (object instanceof $root.build.bazel.remote.execution.v2.Command.EnvironmentVariable)
                                    return object;
                                let message = new $root.build.bazel.remote.execution.v2.Command.EnvironmentVariable();
                                if (object.name != null)
                                    message.name = String(object.name);
                                if (object.value != null)
                                    message.value = String(object.value);
                                return message;
                            };

                            /**
                             * Creates a plain object from an EnvironmentVariable message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {build.bazel.remote.execution.v2.Command.EnvironmentVariable} message EnvironmentVariable
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            EnvironmentVariable.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.name = "";
                                    object.value = "";
                                }
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                if (message.value != null && message.hasOwnProperty("value"))
                                    object.value = message.value;
                                return object;
                            };

                            /**
                             * Converts this EnvironmentVariable to JSON.
                             * @function toJSON
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            EnvironmentVariable.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for EnvironmentVariable
                             * @function getTypeUrl
                             * @memberof build.bazel.remote.execution.v2.Command.EnvironmentVariable
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            EnvironmentVariable.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/build.bazel.remote.execution.v2.Command.EnvironmentVariable";
                            };

                            return EnvironmentVariable;
                        })();

                        /**
                         * OutputDirectoryFormat enum.
                         * @name build.bazel.remote.execution.v2.Command.OutputDirectoryFormat
                         * @enum {number}
                         * @property {number} TREE_ONLY=0 TREE_ONLY value
                         * @property {number} DIRECTORY_ONLY=1 DIRECTORY_ONLY value
                         * @property {number} TREE_AND_DIRECTORY=2 TREE_AND_DIRECTORY value
                         */
                        Command.OutputDirectoryFormat = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "TREE_ONLY"] = 0;
                            values[valuesById[1] = "DIRECTORY_ONLY"] = 1;
                            values[valuesById[2] = "TREE_AND_DIRECTORY"] = 2;
                            return values;
                        })();

                        return Command;
                    })();

                    v2.Platform = (function() {

                        /**
                         * Properties of a Platform.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IPlatform
                         * @property {Array.<build.bazel.remote.execution.v2.Platform.IProperty>|null} [properties] Platform properties
                         */

                        /**
                         * Constructs a new Platform.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a Platform.
                         * @implements IPlatform
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IPlatform=} [properties] Properties to set
                         */
                        function Platform(properties) {
                            this.properties = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Platform properties.
                         * @member {Array.<build.bazel.remote.execution.v2.Platform.IProperty>} properties
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @instance
                         */
                        Platform.prototype.properties = $util.emptyArray;

                        /**
                         * Creates a new Platform instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {build.bazel.remote.execution.v2.IPlatform=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.Platform} Platform instance
                         */
                        Platform.create = function create(properties) {
                            return new Platform(properties);
                        };

                        /**
                         * Encodes the specified Platform message. Does not implicitly {@link build.bazel.remote.execution.v2.Platform.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {build.bazel.remote.execution.v2.IPlatform} message Platform message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Platform.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.properties != null && message.properties.length)
                                for (let i = 0; i < message.properties.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Platform.Property.encode(message.properties[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Platform message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Platform.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {build.bazel.remote.execution.v2.IPlatform} message Platform message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Platform.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Platform message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.Platform} Platform
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Platform.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Platform();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.properties && message.properties.length))
                                            message.properties = [];
                                        message.properties.push($root.build.bazel.remote.execution.v2.Platform.Property.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Platform message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.Platform} Platform
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Platform.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Platform message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Platform.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.properties != null && message.hasOwnProperty("properties")) {
                                if (!Array.isArray(message.properties))
                                    return "properties: array expected";
                                for (let i = 0; i < message.properties.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Platform.Property.verify(message.properties[i]);
                                    if (error)
                                        return "properties." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Platform message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.Platform} Platform
                         */
                        Platform.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.Platform)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.Platform();
                            if (object.properties) {
                                if (!Array.isArray(object.properties))
                                    throw TypeError(".build.bazel.remote.execution.v2.Platform.properties: array expected");
                                message.properties = [];
                                for (let i = 0; i < object.properties.length; ++i) {
                                    if (typeof object.properties[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.Platform.properties: object expected");
                                    message.properties[i] = $root.build.bazel.remote.execution.v2.Platform.Property.fromObject(object.properties[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Platform message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {build.bazel.remote.execution.v2.Platform} message Platform
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Platform.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.properties = [];
                            if (message.properties && message.properties.length) {
                                object.properties = [];
                                for (let j = 0; j < message.properties.length; ++j)
                                    object.properties[j] = $root.build.bazel.remote.execution.v2.Platform.Property.toObject(message.properties[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Platform to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Platform.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Platform
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.Platform
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Platform.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.Platform";
                        };

                        Platform.Property = (function() {

                            /**
                             * Properties of a Property.
                             * @memberof build.bazel.remote.execution.v2.Platform
                             * @interface IProperty
                             * @property {string|null} [name] Property name
                             * @property {string|null} [value] Property value
                             */

                            /**
                             * Constructs a new Property.
                             * @memberof build.bazel.remote.execution.v2.Platform
                             * @classdesc Represents a Property.
                             * @implements IProperty
                             * @constructor
                             * @param {build.bazel.remote.execution.v2.Platform.IProperty=} [properties] Properties to set
                             */
                            function Property(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Property name.
                             * @member {string} name
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @instance
                             */
                            Property.prototype.name = "";

                            /**
                             * Property value.
                             * @member {string} value
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @instance
                             */
                            Property.prototype.value = "";

                            /**
                             * Creates a new Property instance using the specified properties.
                             * @function create
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {build.bazel.remote.execution.v2.Platform.IProperty=} [properties] Properties to set
                             * @returns {build.bazel.remote.execution.v2.Platform.Property} Property instance
                             */
                            Property.create = function create(properties) {
                                return new Property(properties);
                            };

                            /**
                             * Encodes the specified Property message. Does not implicitly {@link build.bazel.remote.execution.v2.Platform.Property.verify|verify} messages.
                             * @function encode
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {build.bazel.remote.execution.v2.Platform.IProperty} message Property message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Property.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                                return writer;
                            };

                            /**
                             * Encodes the specified Property message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Platform.Property.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {build.bazel.remote.execution.v2.Platform.IProperty} message Property message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Property.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Property message from the specified reader or buffer.
                             * @function decode
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {build.bazel.remote.execution.v2.Platform.Property} Property
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Property.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Platform.Property();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.name = reader.string();
                                            break;
                                        }
                                    case 2: {
                                            message.value = reader.string();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Property message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {build.bazel.remote.execution.v2.Platform.Property} Property
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Property.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Property message.
                             * @function verify
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Property.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                if (message.value != null && message.hasOwnProperty("value"))
                                    if (!$util.isString(message.value))
                                        return "value: string expected";
                                return null;
                            };

                            /**
                             * Creates a Property message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {build.bazel.remote.execution.v2.Platform.Property} Property
                             */
                            Property.fromObject = function fromObject(object) {
                                if (object instanceof $root.build.bazel.remote.execution.v2.Platform.Property)
                                    return object;
                                let message = new $root.build.bazel.remote.execution.v2.Platform.Property();
                                if (object.name != null)
                                    message.name = String(object.name);
                                if (object.value != null)
                                    message.value = String(object.value);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Property message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {build.bazel.remote.execution.v2.Platform.Property} message Property
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Property.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.name = "";
                                    object.value = "";
                                }
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                if (message.value != null && message.hasOwnProperty("value"))
                                    object.value = message.value;
                                return object;
                            };

                            /**
                             * Converts this Property to JSON.
                             * @function toJSON
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Property.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for Property
                             * @function getTypeUrl
                             * @memberof build.bazel.remote.execution.v2.Platform.Property
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Property.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/build.bazel.remote.execution.v2.Platform.Property";
                            };

                            return Property;
                        })();

                        return Platform;
                    })();

                    v2.Directory = (function() {

                        /**
                         * Properties of a Directory.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IDirectory
                         * @property {Array.<build.bazel.remote.execution.v2.IFileNode>|null} [files] Directory files
                         * @property {Array.<build.bazel.remote.execution.v2.IDirectoryNode>|null} [directories] Directory directories
                         * @property {Array.<build.bazel.remote.execution.v2.ISymlinkNode>|null} [symlinks] Directory symlinks
                         * @property {build.bazel.remote.execution.v2.INodeProperties|null} [nodeProperties] Directory nodeProperties
                         */

                        /**
                         * Constructs a new Directory.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a Directory.
                         * @implements IDirectory
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IDirectory=} [properties] Properties to set
                         */
                        function Directory(properties) {
                            this.files = [];
                            this.directories = [];
                            this.symlinks = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Directory files.
                         * @member {Array.<build.bazel.remote.execution.v2.IFileNode>} files
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @instance
                         */
                        Directory.prototype.files = $util.emptyArray;

                        /**
                         * Directory directories.
                         * @member {Array.<build.bazel.remote.execution.v2.IDirectoryNode>} directories
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @instance
                         */
                        Directory.prototype.directories = $util.emptyArray;

                        /**
                         * Directory symlinks.
                         * @member {Array.<build.bazel.remote.execution.v2.ISymlinkNode>} symlinks
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @instance
                         */
                        Directory.prototype.symlinks = $util.emptyArray;

                        /**
                         * Directory nodeProperties.
                         * @member {build.bazel.remote.execution.v2.INodeProperties|null|undefined} nodeProperties
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @instance
                         */
                        Directory.prototype.nodeProperties = null;

                        /**
                         * Creates a new Directory instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDirectory=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.Directory} Directory instance
                         */
                        Directory.create = function create(properties) {
                            return new Directory(properties);
                        };

                        /**
                         * Encodes the specified Directory message. Does not implicitly {@link build.bazel.remote.execution.v2.Directory.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDirectory} message Directory message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Directory.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.files != null && message.files.length)
                                for (let i = 0; i < message.files.length; ++i)
                                    $root.build.bazel.remote.execution.v2.FileNode.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.directories != null && message.directories.length)
                                for (let i = 0; i < message.directories.length; ++i)
                                    $root.build.bazel.remote.execution.v2.DirectoryNode.encode(message.directories[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.symlinks != null && message.symlinks.length)
                                for (let i = 0; i < message.symlinks.length; ++i)
                                    $root.build.bazel.remote.execution.v2.SymlinkNode.encode(message.symlinks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.nodeProperties != null && Object.hasOwnProperty.call(message, "nodeProperties"))
                                $root.build.bazel.remote.execution.v2.NodeProperties.encode(message.nodeProperties, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Directory message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Directory.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDirectory} message Directory message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Directory.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Directory message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.Directory} Directory
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Directory.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Directory();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.files && message.files.length))
                                            message.files = [];
                                        message.files.push($root.build.bazel.remote.execution.v2.FileNode.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 2: {
                                        if (!(message.directories && message.directories.length))
                                            message.directories = [];
                                        message.directories.push($root.build.bazel.remote.execution.v2.DirectoryNode.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 3: {
                                        if (!(message.symlinks && message.symlinks.length))
                                            message.symlinks = [];
                                        message.symlinks.push($root.build.bazel.remote.execution.v2.SymlinkNode.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 5: {
                                        message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Directory message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.Directory} Directory
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Directory.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Directory message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Directory.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.files != null && message.hasOwnProperty("files")) {
                                if (!Array.isArray(message.files))
                                    return "files: array expected";
                                for (let i = 0; i < message.files.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.FileNode.verify(message.files[i]);
                                    if (error)
                                        return "files." + error;
                                }
                            }
                            if (message.directories != null && message.hasOwnProperty("directories")) {
                                if (!Array.isArray(message.directories))
                                    return "directories: array expected";
                                for (let i = 0; i < message.directories.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.DirectoryNode.verify(message.directories[i]);
                                    if (error)
                                        return "directories." + error;
                                }
                            }
                            if (message.symlinks != null && message.hasOwnProperty("symlinks")) {
                                if (!Array.isArray(message.symlinks))
                                    return "symlinks: array expected";
                                for (let i = 0; i < message.symlinks.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.SymlinkNode.verify(message.symlinks[i]);
                                    if (error)
                                        return "symlinks." + error;
                                }
                            }
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties")) {
                                let error = $root.build.bazel.remote.execution.v2.NodeProperties.verify(message.nodeProperties);
                                if (error)
                                    return "nodeProperties." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Directory message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.Directory} Directory
                         */
                        Directory.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.Directory)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.Directory();
                            if (object.files) {
                                if (!Array.isArray(object.files))
                                    throw TypeError(".build.bazel.remote.execution.v2.Directory.files: array expected");
                                message.files = [];
                                for (let i = 0; i < object.files.length; ++i) {
                                    if (typeof object.files[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.Directory.files: object expected");
                                    message.files[i] = $root.build.bazel.remote.execution.v2.FileNode.fromObject(object.files[i]);
                                }
                            }
                            if (object.directories) {
                                if (!Array.isArray(object.directories))
                                    throw TypeError(".build.bazel.remote.execution.v2.Directory.directories: array expected");
                                message.directories = [];
                                for (let i = 0; i < object.directories.length; ++i) {
                                    if (typeof object.directories[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.Directory.directories: object expected");
                                    message.directories[i] = $root.build.bazel.remote.execution.v2.DirectoryNode.fromObject(object.directories[i]);
                                }
                            }
                            if (object.symlinks) {
                                if (!Array.isArray(object.symlinks))
                                    throw TypeError(".build.bazel.remote.execution.v2.Directory.symlinks: array expected");
                                message.symlinks = [];
                                for (let i = 0; i < object.symlinks.length; ++i) {
                                    if (typeof object.symlinks[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.Directory.symlinks: object expected");
                                    message.symlinks[i] = $root.build.bazel.remote.execution.v2.SymlinkNode.fromObject(object.symlinks[i]);
                                }
                            }
                            if (object.nodeProperties != null) {
                                if (typeof object.nodeProperties !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.Directory.nodeProperties: object expected");
                                message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.fromObject(object.nodeProperties);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Directory message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {build.bazel.remote.execution.v2.Directory} message Directory
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Directory.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.files = [];
                                object.directories = [];
                                object.symlinks = [];
                            }
                            if (options.defaults)
                                object.nodeProperties = null;
                            if (message.files && message.files.length) {
                                object.files = [];
                                for (let j = 0; j < message.files.length; ++j)
                                    object.files[j] = $root.build.bazel.remote.execution.v2.FileNode.toObject(message.files[j], options);
                            }
                            if (message.directories && message.directories.length) {
                                object.directories = [];
                                for (let j = 0; j < message.directories.length; ++j)
                                    object.directories[j] = $root.build.bazel.remote.execution.v2.DirectoryNode.toObject(message.directories[j], options);
                            }
                            if (message.symlinks && message.symlinks.length) {
                                object.symlinks = [];
                                for (let j = 0; j < message.symlinks.length; ++j)
                                    object.symlinks[j] = $root.build.bazel.remote.execution.v2.SymlinkNode.toObject(message.symlinks[j], options);
                            }
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties"))
                                object.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.toObject(message.nodeProperties, options);
                            return object;
                        };

                        /**
                         * Converts this Directory to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Directory.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Directory
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.Directory
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Directory.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.Directory";
                        };

                        return Directory;
                    })();

                    v2.NodeProperty = (function() {

                        /**
                         * Properties of a NodeProperty.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface INodeProperty
                         * @property {string|null} [name] NodeProperty name
                         * @property {string|null} [value] NodeProperty value
                         */

                        /**
                         * Constructs a new NodeProperty.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a NodeProperty.
                         * @implements INodeProperty
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.INodeProperty=} [properties] Properties to set
                         */
                        function NodeProperty(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * NodeProperty name.
                         * @member {string} name
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @instance
                         */
                        NodeProperty.prototype.name = "";

                        /**
                         * NodeProperty value.
                         * @member {string} value
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @instance
                         */
                        NodeProperty.prototype.value = "";

                        /**
                         * Creates a new NodeProperty instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {build.bazel.remote.execution.v2.INodeProperty=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.NodeProperty} NodeProperty instance
                         */
                        NodeProperty.create = function create(properties) {
                            return new NodeProperty(properties);
                        };

                        /**
                         * Encodes the specified NodeProperty message. Does not implicitly {@link build.bazel.remote.execution.v2.NodeProperty.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {build.bazel.remote.execution.v2.INodeProperty} message NodeProperty message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NodeProperty.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified NodeProperty message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.NodeProperty.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {build.bazel.remote.execution.v2.INodeProperty} message NodeProperty message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NodeProperty.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a NodeProperty message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.NodeProperty} NodeProperty
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NodeProperty.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.NodeProperty();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.name = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.value = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a NodeProperty message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.NodeProperty} NodeProperty
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NodeProperty.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a NodeProperty message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        NodeProperty.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a NodeProperty message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.NodeProperty} NodeProperty
                         */
                        NodeProperty.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.NodeProperty)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.NodeProperty();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a NodeProperty message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {build.bazel.remote.execution.v2.NodeProperty} message NodeProperty
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        NodeProperty.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.name = "";
                                object.value = "";
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this NodeProperty to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        NodeProperty.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for NodeProperty
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.NodeProperty
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        NodeProperty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.NodeProperty";
                        };

                        return NodeProperty;
                    })();

                    v2.NodeProperties = (function() {

                        /**
                         * Properties of a NodeProperties.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface INodeProperties
                         * @property {Array.<build.bazel.remote.execution.v2.INodeProperty>|null} [properties] NodeProperties properties
                         * @property {google.protobuf.ITimestamp|null} [mtime] NodeProperties mtime
                         * @property {google.protobuf.IUInt32Value|null} [unixMode] NodeProperties unixMode
                         */

                        /**
                         * Constructs a new NodeProperties.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a NodeProperties.
                         * @implements INodeProperties
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.INodeProperties=} [properties] Properties to set
                         */
                        function NodeProperties(properties) {
                            this.properties = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * NodeProperties properties.
                         * @member {Array.<build.bazel.remote.execution.v2.INodeProperty>} properties
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @instance
                         */
                        NodeProperties.prototype.properties = $util.emptyArray;

                        /**
                         * NodeProperties mtime.
                         * @member {google.protobuf.ITimestamp|null|undefined} mtime
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @instance
                         */
                        NodeProperties.prototype.mtime = null;

                        /**
                         * NodeProperties unixMode.
                         * @member {google.protobuf.IUInt32Value|null|undefined} unixMode
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @instance
                         */
                        NodeProperties.prototype.unixMode = null;

                        /**
                         * Creates a new NodeProperties instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {build.bazel.remote.execution.v2.INodeProperties=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.NodeProperties} NodeProperties instance
                         */
                        NodeProperties.create = function create(properties) {
                            return new NodeProperties(properties);
                        };

                        /**
                         * Encodes the specified NodeProperties message. Does not implicitly {@link build.bazel.remote.execution.v2.NodeProperties.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {build.bazel.remote.execution.v2.INodeProperties} message NodeProperties message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NodeProperties.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.properties != null && message.properties.length)
                                for (let i = 0; i < message.properties.length; ++i)
                                    $root.build.bazel.remote.execution.v2.NodeProperty.encode(message.properties[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.mtime != null && Object.hasOwnProperty.call(message, "mtime"))
                                $root.google.protobuf.Timestamp.encode(message.mtime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.unixMode != null && Object.hasOwnProperty.call(message, "unixMode"))
                                $root.google.protobuf.UInt32Value.encode(message.unixMode, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified NodeProperties message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.NodeProperties.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {build.bazel.remote.execution.v2.INodeProperties} message NodeProperties message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        NodeProperties.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a NodeProperties message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.NodeProperties} NodeProperties
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NodeProperties.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.NodeProperties();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.properties && message.properties.length))
                                            message.properties = [];
                                        message.properties.push($root.build.bazel.remote.execution.v2.NodeProperty.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 2: {
                                        message.mtime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.unixMode = $root.google.protobuf.UInt32Value.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a NodeProperties message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.NodeProperties} NodeProperties
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        NodeProperties.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a NodeProperties message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        NodeProperties.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.properties != null && message.hasOwnProperty("properties")) {
                                if (!Array.isArray(message.properties))
                                    return "properties: array expected";
                                for (let i = 0; i < message.properties.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.NodeProperty.verify(message.properties[i]);
                                    if (error)
                                        return "properties." + error;
                                }
                            }
                            if (message.mtime != null && message.hasOwnProperty("mtime")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.mtime);
                                if (error)
                                    return "mtime." + error;
                            }
                            if (message.unixMode != null && message.hasOwnProperty("unixMode")) {
                                let error = $root.google.protobuf.UInt32Value.verify(message.unixMode);
                                if (error)
                                    return "unixMode." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a NodeProperties message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.NodeProperties} NodeProperties
                         */
                        NodeProperties.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.NodeProperties)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.NodeProperties();
                            if (object.properties) {
                                if (!Array.isArray(object.properties))
                                    throw TypeError(".build.bazel.remote.execution.v2.NodeProperties.properties: array expected");
                                message.properties = [];
                                for (let i = 0; i < object.properties.length; ++i) {
                                    if (typeof object.properties[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.NodeProperties.properties: object expected");
                                    message.properties[i] = $root.build.bazel.remote.execution.v2.NodeProperty.fromObject(object.properties[i]);
                                }
                            }
                            if (object.mtime != null) {
                                if (typeof object.mtime !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.NodeProperties.mtime: object expected");
                                message.mtime = $root.google.protobuf.Timestamp.fromObject(object.mtime);
                            }
                            if (object.unixMode != null) {
                                if (typeof object.unixMode !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.NodeProperties.unixMode: object expected");
                                message.unixMode = $root.google.protobuf.UInt32Value.fromObject(object.unixMode);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a NodeProperties message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {build.bazel.remote.execution.v2.NodeProperties} message NodeProperties
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        NodeProperties.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.properties = [];
                            if (options.defaults) {
                                object.mtime = null;
                                object.unixMode = null;
                            }
                            if (message.properties && message.properties.length) {
                                object.properties = [];
                                for (let j = 0; j < message.properties.length; ++j)
                                    object.properties[j] = $root.build.bazel.remote.execution.v2.NodeProperty.toObject(message.properties[j], options);
                            }
                            if (message.mtime != null && message.hasOwnProperty("mtime"))
                                object.mtime = $root.google.protobuf.Timestamp.toObject(message.mtime, options);
                            if (message.unixMode != null && message.hasOwnProperty("unixMode"))
                                object.unixMode = $root.google.protobuf.UInt32Value.toObject(message.unixMode, options);
                            return object;
                        };

                        /**
                         * Converts this NodeProperties to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        NodeProperties.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for NodeProperties
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.NodeProperties
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        NodeProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.NodeProperties";
                        };

                        return NodeProperties;
                    })();

                    v2.FileNode = (function() {

                        /**
                         * Properties of a FileNode.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IFileNode
                         * @property {string|null} [name] FileNode name
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [digest] FileNode digest
                         * @property {boolean|null} [isExecutable] FileNode isExecutable
                         * @property {build.bazel.remote.execution.v2.INodeProperties|null} [nodeProperties] FileNode nodeProperties
                         */

                        /**
                         * Constructs a new FileNode.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a FileNode.
                         * @implements IFileNode
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IFileNode=} [properties] Properties to set
                         */
                        function FileNode(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FileNode name.
                         * @member {string} name
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @instance
                         */
                        FileNode.prototype.name = "";

                        /**
                         * FileNode digest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} digest
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @instance
                         */
                        FileNode.prototype.digest = null;

                        /**
                         * FileNode isExecutable.
                         * @member {boolean} isExecutable
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @instance
                         */
                        FileNode.prototype.isExecutable = false;

                        /**
                         * FileNode nodeProperties.
                         * @member {build.bazel.remote.execution.v2.INodeProperties|null|undefined} nodeProperties
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @instance
                         */
                        FileNode.prototype.nodeProperties = null;

                        /**
                         * Creates a new FileNode instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFileNode=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.FileNode} FileNode instance
                         */
                        FileNode.create = function create(properties) {
                            return new FileNode(properties);
                        };

                        /**
                         * Encodes the specified FileNode message. Does not implicitly {@link build.bazel.remote.execution.v2.FileNode.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFileNode} message FileNode message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FileNode.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.digest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.isExecutable != null && Object.hasOwnProperty.call(message, "isExecutable"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isExecutable);
                            if (message.nodeProperties != null && Object.hasOwnProperty.call(message, "nodeProperties"))
                                $root.build.bazel.remote.execution.v2.NodeProperties.encode(message.nodeProperties, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified FileNode message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.FileNode.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFileNode} message FileNode message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FileNode.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FileNode message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.FileNode} FileNode
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FileNode.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.FileNode();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.name = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.digest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.isExecutable = reader.bool();
                                        break;
                                    }
                                case 6: {
                                        message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FileNode message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.FileNode} FileNode
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FileNode.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FileNode message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FileNode.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.digest != null && message.hasOwnProperty("digest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digest);
                                if (error)
                                    return "digest." + error;
                            }
                            if (message.isExecutable != null && message.hasOwnProperty("isExecutable"))
                                if (typeof message.isExecutable !== "boolean")
                                    return "isExecutable: boolean expected";
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties")) {
                                let error = $root.build.bazel.remote.execution.v2.NodeProperties.verify(message.nodeProperties);
                                if (error)
                                    return "nodeProperties." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a FileNode message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.FileNode} FileNode
                         */
                        FileNode.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.FileNode)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.FileNode();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.digest != null) {
                                if (typeof object.digest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.FileNode.digest: object expected");
                                message.digest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digest);
                            }
                            if (object.isExecutable != null)
                                message.isExecutable = Boolean(object.isExecutable);
                            if (object.nodeProperties != null) {
                                if (typeof object.nodeProperties !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.FileNode.nodeProperties: object expected");
                                message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.fromObject(object.nodeProperties);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FileNode message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.FileNode} message FileNode
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FileNode.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.name = "";
                                object.digest = null;
                                object.isExecutable = false;
                                object.nodeProperties = null;
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.digest != null && message.hasOwnProperty("digest"))
                                object.digest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digest, options);
                            if (message.isExecutable != null && message.hasOwnProperty("isExecutable"))
                                object.isExecutable = message.isExecutable;
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties"))
                                object.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.toObject(message.nodeProperties, options);
                            return object;
                        };

                        /**
                         * Converts this FileNode to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FileNode.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FileNode
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.FileNode
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FileNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.FileNode";
                        };

                        return FileNode;
                    })();

                    v2.DirectoryNode = (function() {

                        /**
                         * Properties of a DirectoryNode.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IDirectoryNode
                         * @property {string|null} [name] DirectoryNode name
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [digest] DirectoryNode digest
                         */

                        /**
                         * Constructs a new DirectoryNode.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a DirectoryNode.
                         * @implements IDirectoryNode
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IDirectoryNode=} [properties] Properties to set
                         */
                        function DirectoryNode(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * DirectoryNode name.
                         * @member {string} name
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @instance
                         */
                        DirectoryNode.prototype.name = "";

                        /**
                         * DirectoryNode digest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} digest
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @instance
                         */
                        DirectoryNode.prototype.digest = null;

                        /**
                         * Creates a new DirectoryNode instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDirectoryNode=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.DirectoryNode} DirectoryNode instance
                         */
                        DirectoryNode.create = function create(properties) {
                            return new DirectoryNode(properties);
                        };

                        /**
                         * Encodes the specified DirectoryNode message. Does not implicitly {@link build.bazel.remote.execution.v2.DirectoryNode.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDirectoryNode} message DirectoryNode message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        DirectoryNode.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.digest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified DirectoryNode message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.DirectoryNode.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDirectoryNode} message DirectoryNode message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        DirectoryNode.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a DirectoryNode message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.DirectoryNode} DirectoryNode
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        DirectoryNode.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.DirectoryNode();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.name = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.digest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a DirectoryNode message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.DirectoryNode} DirectoryNode
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        DirectoryNode.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a DirectoryNode message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        DirectoryNode.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.digest != null && message.hasOwnProperty("digest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digest);
                                if (error)
                                    return "digest." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a DirectoryNode message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.DirectoryNode} DirectoryNode
                         */
                        DirectoryNode.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.DirectoryNode)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.DirectoryNode();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.digest != null) {
                                if (typeof object.digest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.DirectoryNode.digest: object expected");
                                message.digest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digest);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a DirectoryNode message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.DirectoryNode} message DirectoryNode
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        DirectoryNode.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.name = "";
                                object.digest = null;
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.digest != null && message.hasOwnProperty("digest"))
                                object.digest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digest, options);
                            return object;
                        };

                        /**
                         * Converts this DirectoryNode to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        DirectoryNode.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for DirectoryNode
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.DirectoryNode
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        DirectoryNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.DirectoryNode";
                        };

                        return DirectoryNode;
                    })();

                    v2.SymlinkNode = (function() {

                        /**
                         * Properties of a SymlinkNode.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface ISymlinkNode
                         * @property {string|null} [name] SymlinkNode name
                         * @property {string|null} [target] SymlinkNode target
                         * @property {build.bazel.remote.execution.v2.INodeProperties|null} [nodeProperties] SymlinkNode nodeProperties
                         */

                        /**
                         * Constructs a new SymlinkNode.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a SymlinkNode.
                         * @implements ISymlinkNode
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.ISymlinkNode=} [properties] Properties to set
                         */
                        function SymlinkNode(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SymlinkNode name.
                         * @member {string} name
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @instance
                         */
                        SymlinkNode.prototype.name = "";

                        /**
                         * SymlinkNode target.
                         * @member {string} target
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @instance
                         */
                        SymlinkNode.prototype.target = "";

                        /**
                         * SymlinkNode nodeProperties.
                         * @member {build.bazel.remote.execution.v2.INodeProperties|null|undefined} nodeProperties
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @instance
                         */
                        SymlinkNode.prototype.nodeProperties = null;

                        /**
                         * Creates a new SymlinkNode instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.ISymlinkNode=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.SymlinkNode} SymlinkNode instance
                         */
                        SymlinkNode.create = function create(properties) {
                            return new SymlinkNode(properties);
                        };

                        /**
                         * Encodes the specified SymlinkNode message. Does not implicitly {@link build.bazel.remote.execution.v2.SymlinkNode.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.ISymlinkNode} message SymlinkNode message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SymlinkNode.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.target);
                            if (message.nodeProperties != null && Object.hasOwnProperty.call(message, "nodeProperties"))
                                $root.build.bazel.remote.execution.v2.NodeProperties.encode(message.nodeProperties, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified SymlinkNode message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.SymlinkNode.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.ISymlinkNode} message SymlinkNode message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SymlinkNode.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a SymlinkNode message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.SymlinkNode} SymlinkNode
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SymlinkNode.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.SymlinkNode();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.name = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.target = reader.string();
                                        break;
                                    }
                                case 4: {
                                        message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a SymlinkNode message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.SymlinkNode} SymlinkNode
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SymlinkNode.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a SymlinkNode message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SymlinkNode.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.target != null && message.hasOwnProperty("target"))
                                if (!$util.isString(message.target))
                                    return "target: string expected";
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties")) {
                                let error = $root.build.bazel.remote.execution.v2.NodeProperties.verify(message.nodeProperties);
                                if (error)
                                    return "nodeProperties." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a SymlinkNode message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.SymlinkNode} SymlinkNode
                         */
                        SymlinkNode.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.SymlinkNode)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.SymlinkNode();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.target != null)
                                message.target = String(object.target);
                            if (object.nodeProperties != null) {
                                if (typeof object.nodeProperties !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.SymlinkNode.nodeProperties: object expected");
                                message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.fromObject(object.nodeProperties);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SymlinkNode message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {build.bazel.remote.execution.v2.SymlinkNode} message SymlinkNode
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SymlinkNode.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.name = "";
                                object.target = "";
                                object.nodeProperties = null;
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.target != null && message.hasOwnProperty("target"))
                                object.target = message.target;
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties"))
                                object.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.toObject(message.nodeProperties, options);
                            return object;
                        };

                        /**
                         * Converts this SymlinkNode to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SymlinkNode.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for SymlinkNode
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.SymlinkNode
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        SymlinkNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.SymlinkNode";
                        };

                        return SymlinkNode;
                    })();

                    v2.Digest = (function() {

                        /**
                         * Properties of a Digest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IDigest
                         * @property {string|null} [hash] Digest hash
                         * @property {number|Long|null} [sizeBytes] Digest sizeBytes
                         */

                        /**
                         * Constructs a new Digest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a Digest.
                         * @implements IDigest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IDigest=} [properties] Properties to set
                         */
                        function Digest(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Digest hash.
                         * @member {string} hash
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @instance
                         */
                        Digest.prototype.hash = "";

                        /**
                         * Digest sizeBytes.
                         * @member {number|Long} sizeBytes
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @instance
                         */
                        Digest.prototype.sizeBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * Creates a new Digest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDigest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.Digest} Digest instance
                         */
                        Digest.create = function create(properties) {
                            return new Digest(properties);
                        };

                        /**
                         * Encodes the specified Digest message. Does not implicitly {@link build.bazel.remote.execution.v2.Digest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDigest} message Digest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Digest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
                            if (message.sizeBytes != null && Object.hasOwnProperty.call(message, "sizeBytes"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sizeBytes);
                            return writer;
                        };

                        /**
                         * Encodes the specified Digest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Digest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDigest} message Digest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Digest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Digest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.Digest} Digest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Digest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Digest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.hash = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.sizeBytes = reader.int64();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Digest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.Digest} Digest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Digest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Digest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Digest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.hash != null && message.hasOwnProperty("hash"))
                                if (!$util.isString(message.hash))
                                    return "hash: string expected";
                            if (message.sizeBytes != null && message.hasOwnProperty("sizeBytes"))
                                if (!$util.isInteger(message.sizeBytes) && !(message.sizeBytes && $util.isInteger(message.sizeBytes.low) && $util.isInteger(message.sizeBytes.high)))
                                    return "sizeBytes: integer|Long expected";
                            return null;
                        };

                        /**
                         * Creates a Digest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.Digest} Digest
                         */
                        Digest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.Digest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.Digest();
                            if (object.hash != null)
                                message.hash = String(object.hash);
                            if (object.sizeBytes != null)
                                if ($util.Long)
                                    (message.sizeBytes = $util.Long.fromValue(object.sizeBytes)).unsigned = false;
                                else if (typeof object.sizeBytes === "string")
                                    message.sizeBytes = parseInt(object.sizeBytes, 10);
                                else if (typeof object.sizeBytes === "number")
                                    message.sizeBytes = object.sizeBytes;
                                else if (typeof object.sizeBytes === "object")
                                    message.sizeBytes = new $util.LongBits(object.sizeBytes.low >>> 0, object.sizeBytes.high >>> 0).toNumber();
                            return message;
                        };

                        /**
                         * Creates a plain object from a Digest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {build.bazel.remote.execution.v2.Digest} message Digest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Digest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.hash = "";
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.sizeBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.sizeBytes = options.longs === String ? "0" : 0;
                            }
                            if (message.hash != null && message.hasOwnProperty("hash"))
                                object.hash = message.hash;
                            if (message.sizeBytes != null && message.hasOwnProperty("sizeBytes"))
                                if (typeof message.sizeBytes === "number")
                                    object.sizeBytes = options.longs === String ? String(message.sizeBytes) : message.sizeBytes;
                                else
                                    object.sizeBytes = options.longs === String ? $util.Long.prototype.toString.call(message.sizeBytes) : options.longs === Number ? new $util.LongBits(message.sizeBytes.low >>> 0, message.sizeBytes.high >>> 0).toNumber() : message.sizeBytes;
                            return object;
                        };

                        /**
                         * Converts this Digest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Digest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Digest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.Digest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Digest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.Digest";
                        };

                        return Digest;
                    })();

                    v2.ExecutedActionMetadata = (function() {

                        /**
                         * Properties of an ExecutedActionMetadata.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IExecutedActionMetadata
                         * @property {string|null} [worker] ExecutedActionMetadata worker
                         * @property {google.protobuf.ITimestamp|null} [queuedTimestamp] ExecutedActionMetadata queuedTimestamp
                         * @property {google.protobuf.ITimestamp|null} [workerStartTimestamp] ExecutedActionMetadata workerStartTimestamp
                         * @property {google.protobuf.ITimestamp|null} [workerCompletedTimestamp] ExecutedActionMetadata workerCompletedTimestamp
                         * @property {google.protobuf.ITimestamp|null} [inputFetchStartTimestamp] ExecutedActionMetadata inputFetchStartTimestamp
                         * @property {google.protobuf.ITimestamp|null} [inputFetchCompletedTimestamp] ExecutedActionMetadata inputFetchCompletedTimestamp
                         * @property {google.protobuf.ITimestamp|null} [executionStartTimestamp] ExecutedActionMetadata executionStartTimestamp
                         * @property {google.protobuf.ITimestamp|null} [executionCompletedTimestamp] ExecutedActionMetadata executionCompletedTimestamp
                         * @property {google.protobuf.IDuration|null} [virtualExecutionDuration] ExecutedActionMetadata virtualExecutionDuration
                         * @property {google.protobuf.ITimestamp|null} [outputUploadStartTimestamp] ExecutedActionMetadata outputUploadStartTimestamp
                         * @property {google.protobuf.ITimestamp|null} [outputUploadCompletedTimestamp] ExecutedActionMetadata outputUploadCompletedTimestamp
                         * @property {Array.<google.protobuf.IAny>|null} [auxiliaryMetadata] ExecutedActionMetadata auxiliaryMetadata
                         */

                        /**
                         * Constructs a new ExecutedActionMetadata.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ExecutedActionMetadata.
                         * @implements IExecutedActionMetadata
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IExecutedActionMetadata=} [properties] Properties to set
                         */
                        function ExecutedActionMetadata(properties) {
                            this.auxiliaryMetadata = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ExecutedActionMetadata worker.
                         * @member {string} worker
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.worker = "";

                        /**
                         * ExecutedActionMetadata queuedTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} queuedTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.queuedTimestamp = null;

                        /**
                         * ExecutedActionMetadata workerStartTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} workerStartTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.workerStartTimestamp = null;

                        /**
                         * ExecutedActionMetadata workerCompletedTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} workerCompletedTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.workerCompletedTimestamp = null;

                        /**
                         * ExecutedActionMetadata inputFetchStartTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} inputFetchStartTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.inputFetchStartTimestamp = null;

                        /**
                         * ExecutedActionMetadata inputFetchCompletedTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} inputFetchCompletedTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.inputFetchCompletedTimestamp = null;

                        /**
                         * ExecutedActionMetadata executionStartTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} executionStartTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.executionStartTimestamp = null;

                        /**
                         * ExecutedActionMetadata executionCompletedTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} executionCompletedTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.executionCompletedTimestamp = null;

                        /**
                         * ExecutedActionMetadata virtualExecutionDuration.
                         * @member {google.protobuf.IDuration|null|undefined} virtualExecutionDuration
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.virtualExecutionDuration = null;

                        /**
                         * ExecutedActionMetadata outputUploadStartTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} outputUploadStartTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.outputUploadStartTimestamp = null;

                        /**
                         * ExecutedActionMetadata outputUploadCompletedTimestamp.
                         * @member {google.protobuf.ITimestamp|null|undefined} outputUploadCompletedTimestamp
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.outputUploadCompletedTimestamp = null;

                        /**
                         * ExecutedActionMetadata auxiliaryMetadata.
                         * @member {Array.<google.protobuf.IAny>} auxiliaryMetadata
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         */
                        ExecutedActionMetadata.prototype.auxiliaryMetadata = $util.emptyArray;

                        /**
                         * Creates a new ExecutedActionMetadata instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutedActionMetadata=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ExecutedActionMetadata} ExecutedActionMetadata instance
                         */
                        ExecutedActionMetadata.create = function create(properties) {
                            return new ExecutedActionMetadata(properties);
                        };

                        /**
                         * Encodes the specified ExecutedActionMetadata message. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutedActionMetadata.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutedActionMetadata} message ExecutedActionMetadata message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutedActionMetadata.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.worker != null && Object.hasOwnProperty.call(message, "worker"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.worker);
                            if (message.queuedTimestamp != null && Object.hasOwnProperty.call(message, "queuedTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.queuedTimestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.workerStartTimestamp != null && Object.hasOwnProperty.call(message, "workerStartTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.workerStartTimestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.workerCompletedTimestamp != null && Object.hasOwnProperty.call(message, "workerCompletedTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.workerCompletedTimestamp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.inputFetchStartTimestamp != null && Object.hasOwnProperty.call(message, "inputFetchStartTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.inputFetchStartTimestamp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.inputFetchCompletedTimestamp != null && Object.hasOwnProperty.call(message, "inputFetchCompletedTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.inputFetchCompletedTimestamp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.executionStartTimestamp != null && Object.hasOwnProperty.call(message, "executionStartTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.executionStartTimestamp, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                            if (message.executionCompletedTimestamp != null && Object.hasOwnProperty.call(message, "executionCompletedTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.executionCompletedTimestamp, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                            if (message.outputUploadStartTimestamp != null && Object.hasOwnProperty.call(message, "outputUploadStartTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.outputUploadStartTimestamp, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                            if (message.outputUploadCompletedTimestamp != null && Object.hasOwnProperty.call(message, "outputUploadCompletedTimestamp"))
                                $root.google.protobuf.Timestamp.encode(message.outputUploadCompletedTimestamp, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                            if (message.auxiliaryMetadata != null && message.auxiliaryMetadata.length)
                                for (let i = 0; i < message.auxiliaryMetadata.length; ++i)
                                    $root.google.protobuf.Any.encode(message.auxiliaryMetadata[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                            if (message.virtualExecutionDuration != null && Object.hasOwnProperty.call(message, "virtualExecutionDuration"))
                                $root.google.protobuf.Duration.encode(message.virtualExecutionDuration, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified ExecutedActionMetadata message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutedActionMetadata.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutedActionMetadata} message ExecutedActionMetadata message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutedActionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ExecutedActionMetadata message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ExecutedActionMetadata} ExecutedActionMetadata
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutedActionMetadata.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ExecutedActionMetadata();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.worker = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.queuedTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.workerStartTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.workerCompletedTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 5: {
                                        message.inputFetchStartTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        message.inputFetchCompletedTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 7: {
                                        message.executionStartTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 8: {
                                        message.executionCompletedTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 12: {
                                        message.virtualExecutionDuration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 9: {
                                        message.outputUploadStartTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 10: {
                                        message.outputUploadCompletedTimestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 11: {
                                        if (!(message.auxiliaryMetadata && message.auxiliaryMetadata.length))
                                            message.auxiliaryMetadata = [];
                                        message.auxiliaryMetadata.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ExecutedActionMetadata message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ExecutedActionMetadata} ExecutedActionMetadata
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutedActionMetadata.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ExecutedActionMetadata message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ExecutedActionMetadata.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.worker != null && message.hasOwnProperty("worker"))
                                if (!$util.isString(message.worker))
                                    return "worker: string expected";
                            if (message.queuedTimestamp != null && message.hasOwnProperty("queuedTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.queuedTimestamp);
                                if (error)
                                    return "queuedTimestamp." + error;
                            }
                            if (message.workerStartTimestamp != null && message.hasOwnProperty("workerStartTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.workerStartTimestamp);
                                if (error)
                                    return "workerStartTimestamp." + error;
                            }
                            if (message.workerCompletedTimestamp != null && message.hasOwnProperty("workerCompletedTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.workerCompletedTimestamp);
                                if (error)
                                    return "workerCompletedTimestamp." + error;
                            }
                            if (message.inputFetchStartTimestamp != null && message.hasOwnProperty("inputFetchStartTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.inputFetchStartTimestamp);
                                if (error)
                                    return "inputFetchStartTimestamp." + error;
                            }
                            if (message.inputFetchCompletedTimestamp != null && message.hasOwnProperty("inputFetchCompletedTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.inputFetchCompletedTimestamp);
                                if (error)
                                    return "inputFetchCompletedTimestamp." + error;
                            }
                            if (message.executionStartTimestamp != null && message.hasOwnProperty("executionStartTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.executionStartTimestamp);
                                if (error)
                                    return "executionStartTimestamp." + error;
                            }
                            if (message.executionCompletedTimestamp != null && message.hasOwnProperty("executionCompletedTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.executionCompletedTimestamp);
                                if (error)
                                    return "executionCompletedTimestamp." + error;
                            }
                            if (message.virtualExecutionDuration != null && message.hasOwnProperty("virtualExecutionDuration")) {
                                let error = $root.google.protobuf.Duration.verify(message.virtualExecutionDuration);
                                if (error)
                                    return "virtualExecutionDuration." + error;
                            }
                            if (message.outputUploadStartTimestamp != null && message.hasOwnProperty("outputUploadStartTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.outputUploadStartTimestamp);
                                if (error)
                                    return "outputUploadStartTimestamp." + error;
                            }
                            if (message.outputUploadCompletedTimestamp != null && message.hasOwnProperty("outputUploadCompletedTimestamp")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.outputUploadCompletedTimestamp);
                                if (error)
                                    return "outputUploadCompletedTimestamp." + error;
                            }
                            if (message.auxiliaryMetadata != null && message.hasOwnProperty("auxiliaryMetadata")) {
                                if (!Array.isArray(message.auxiliaryMetadata))
                                    return "auxiliaryMetadata: array expected";
                                for (let i = 0; i < message.auxiliaryMetadata.length; ++i) {
                                    let error = $root.google.protobuf.Any.verify(message.auxiliaryMetadata[i]);
                                    if (error)
                                        return "auxiliaryMetadata." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates an ExecutedActionMetadata message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ExecutedActionMetadata} ExecutedActionMetadata
                         */
                        ExecutedActionMetadata.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ExecutedActionMetadata)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ExecutedActionMetadata();
                            if (object.worker != null)
                                message.worker = String(object.worker);
                            if (object.queuedTimestamp != null) {
                                if (typeof object.queuedTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.queuedTimestamp: object expected");
                                message.queuedTimestamp = $root.google.protobuf.Timestamp.fromObject(object.queuedTimestamp);
                            }
                            if (object.workerStartTimestamp != null) {
                                if (typeof object.workerStartTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.workerStartTimestamp: object expected");
                                message.workerStartTimestamp = $root.google.protobuf.Timestamp.fromObject(object.workerStartTimestamp);
                            }
                            if (object.workerCompletedTimestamp != null) {
                                if (typeof object.workerCompletedTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.workerCompletedTimestamp: object expected");
                                message.workerCompletedTimestamp = $root.google.protobuf.Timestamp.fromObject(object.workerCompletedTimestamp);
                            }
                            if (object.inputFetchStartTimestamp != null) {
                                if (typeof object.inputFetchStartTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.inputFetchStartTimestamp: object expected");
                                message.inputFetchStartTimestamp = $root.google.protobuf.Timestamp.fromObject(object.inputFetchStartTimestamp);
                            }
                            if (object.inputFetchCompletedTimestamp != null) {
                                if (typeof object.inputFetchCompletedTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.inputFetchCompletedTimestamp: object expected");
                                message.inputFetchCompletedTimestamp = $root.google.protobuf.Timestamp.fromObject(object.inputFetchCompletedTimestamp);
                            }
                            if (object.executionStartTimestamp != null) {
                                if (typeof object.executionStartTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.executionStartTimestamp: object expected");
                                message.executionStartTimestamp = $root.google.protobuf.Timestamp.fromObject(object.executionStartTimestamp);
                            }
                            if (object.executionCompletedTimestamp != null) {
                                if (typeof object.executionCompletedTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.executionCompletedTimestamp: object expected");
                                message.executionCompletedTimestamp = $root.google.protobuf.Timestamp.fromObject(object.executionCompletedTimestamp);
                            }
                            if (object.virtualExecutionDuration != null) {
                                if (typeof object.virtualExecutionDuration !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.virtualExecutionDuration: object expected");
                                message.virtualExecutionDuration = $root.google.protobuf.Duration.fromObject(object.virtualExecutionDuration);
                            }
                            if (object.outputUploadStartTimestamp != null) {
                                if (typeof object.outputUploadStartTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.outputUploadStartTimestamp: object expected");
                                message.outputUploadStartTimestamp = $root.google.protobuf.Timestamp.fromObject(object.outputUploadStartTimestamp);
                            }
                            if (object.outputUploadCompletedTimestamp != null) {
                                if (typeof object.outputUploadCompletedTimestamp !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.outputUploadCompletedTimestamp: object expected");
                                message.outputUploadCompletedTimestamp = $root.google.protobuf.Timestamp.fromObject(object.outputUploadCompletedTimestamp);
                            }
                            if (object.auxiliaryMetadata) {
                                if (!Array.isArray(object.auxiliaryMetadata))
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.auxiliaryMetadata: array expected");
                                message.auxiliaryMetadata = [];
                                for (let i = 0; i < object.auxiliaryMetadata.length; ++i) {
                                    if (typeof object.auxiliaryMetadata[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.ExecutedActionMetadata.auxiliaryMetadata: object expected");
                                    message.auxiliaryMetadata[i] = $root.google.protobuf.Any.fromObject(object.auxiliaryMetadata[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an ExecutedActionMetadata message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.ExecutedActionMetadata} message ExecutedActionMetadata
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ExecutedActionMetadata.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.auxiliaryMetadata = [];
                            if (options.defaults) {
                                object.worker = "";
                                object.queuedTimestamp = null;
                                object.workerStartTimestamp = null;
                                object.workerCompletedTimestamp = null;
                                object.inputFetchStartTimestamp = null;
                                object.inputFetchCompletedTimestamp = null;
                                object.executionStartTimestamp = null;
                                object.executionCompletedTimestamp = null;
                                object.outputUploadStartTimestamp = null;
                                object.outputUploadCompletedTimestamp = null;
                                object.virtualExecutionDuration = null;
                            }
                            if (message.worker != null && message.hasOwnProperty("worker"))
                                object.worker = message.worker;
                            if (message.queuedTimestamp != null && message.hasOwnProperty("queuedTimestamp"))
                                object.queuedTimestamp = $root.google.protobuf.Timestamp.toObject(message.queuedTimestamp, options);
                            if (message.workerStartTimestamp != null && message.hasOwnProperty("workerStartTimestamp"))
                                object.workerStartTimestamp = $root.google.protobuf.Timestamp.toObject(message.workerStartTimestamp, options);
                            if (message.workerCompletedTimestamp != null && message.hasOwnProperty("workerCompletedTimestamp"))
                                object.workerCompletedTimestamp = $root.google.protobuf.Timestamp.toObject(message.workerCompletedTimestamp, options);
                            if (message.inputFetchStartTimestamp != null && message.hasOwnProperty("inputFetchStartTimestamp"))
                                object.inputFetchStartTimestamp = $root.google.protobuf.Timestamp.toObject(message.inputFetchStartTimestamp, options);
                            if (message.inputFetchCompletedTimestamp != null && message.hasOwnProperty("inputFetchCompletedTimestamp"))
                                object.inputFetchCompletedTimestamp = $root.google.protobuf.Timestamp.toObject(message.inputFetchCompletedTimestamp, options);
                            if (message.executionStartTimestamp != null && message.hasOwnProperty("executionStartTimestamp"))
                                object.executionStartTimestamp = $root.google.protobuf.Timestamp.toObject(message.executionStartTimestamp, options);
                            if (message.executionCompletedTimestamp != null && message.hasOwnProperty("executionCompletedTimestamp"))
                                object.executionCompletedTimestamp = $root.google.protobuf.Timestamp.toObject(message.executionCompletedTimestamp, options);
                            if (message.outputUploadStartTimestamp != null && message.hasOwnProperty("outputUploadStartTimestamp"))
                                object.outputUploadStartTimestamp = $root.google.protobuf.Timestamp.toObject(message.outputUploadStartTimestamp, options);
                            if (message.outputUploadCompletedTimestamp != null && message.hasOwnProperty("outputUploadCompletedTimestamp"))
                                object.outputUploadCompletedTimestamp = $root.google.protobuf.Timestamp.toObject(message.outputUploadCompletedTimestamp, options);
                            if (message.auxiliaryMetadata && message.auxiliaryMetadata.length) {
                                object.auxiliaryMetadata = [];
                                for (let j = 0; j < message.auxiliaryMetadata.length; ++j)
                                    object.auxiliaryMetadata[j] = $root.google.protobuf.Any.toObject(message.auxiliaryMetadata[j], options);
                            }
                            if (message.virtualExecutionDuration != null && message.hasOwnProperty("virtualExecutionDuration"))
                                object.virtualExecutionDuration = $root.google.protobuf.Duration.toObject(message.virtualExecutionDuration, options);
                            return object;
                        };

                        /**
                         * Converts this ExecutedActionMetadata to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ExecutedActionMetadata.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ExecutedActionMetadata
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ExecutedActionMetadata
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ExecutedActionMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ExecutedActionMetadata";
                        };

                        return ExecutedActionMetadata;
                    })();

                    v2.ActionResult = (function() {

                        /**
                         * Properties of an ActionResult.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IActionResult
                         * @property {Array.<build.bazel.remote.execution.v2.IOutputFile>|null} [outputFiles] ActionResult outputFiles
                         * @property {Array.<build.bazel.remote.execution.v2.IOutputSymlink>|null} [outputFileSymlinks] ActionResult outputFileSymlinks
                         * @property {Array.<build.bazel.remote.execution.v2.IOutputSymlink>|null} [outputSymlinks] ActionResult outputSymlinks
                         * @property {Array.<build.bazel.remote.execution.v2.IOutputDirectory>|null} [outputDirectories] ActionResult outputDirectories
                         * @property {Array.<build.bazel.remote.execution.v2.IOutputSymlink>|null} [outputDirectorySymlinks] ActionResult outputDirectorySymlinks
                         * @property {number|null} [exitCode] ActionResult exitCode
                         * @property {Uint8Array|null} [stdoutRaw] ActionResult stdoutRaw
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [stdoutDigest] ActionResult stdoutDigest
                         * @property {Uint8Array|null} [stderrRaw] ActionResult stderrRaw
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [stderrDigest] ActionResult stderrDigest
                         * @property {build.bazel.remote.execution.v2.IExecutedActionMetadata|null} [executionMetadata] ActionResult executionMetadata
                         */

                        /**
                         * Constructs a new ActionResult.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ActionResult.
                         * @implements IActionResult
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IActionResult=} [properties] Properties to set
                         */
                        function ActionResult(properties) {
                            this.outputFiles = [];
                            this.outputFileSymlinks = [];
                            this.outputSymlinks = [];
                            this.outputDirectories = [];
                            this.outputDirectorySymlinks = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ActionResult outputFiles.
                         * @member {Array.<build.bazel.remote.execution.v2.IOutputFile>} outputFiles
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.outputFiles = $util.emptyArray;

                        /**
                         * ActionResult outputFileSymlinks.
                         * @member {Array.<build.bazel.remote.execution.v2.IOutputSymlink>} outputFileSymlinks
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.outputFileSymlinks = $util.emptyArray;

                        /**
                         * ActionResult outputSymlinks.
                         * @member {Array.<build.bazel.remote.execution.v2.IOutputSymlink>} outputSymlinks
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.outputSymlinks = $util.emptyArray;

                        /**
                         * ActionResult outputDirectories.
                         * @member {Array.<build.bazel.remote.execution.v2.IOutputDirectory>} outputDirectories
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.outputDirectories = $util.emptyArray;

                        /**
                         * ActionResult outputDirectorySymlinks.
                         * @member {Array.<build.bazel.remote.execution.v2.IOutputSymlink>} outputDirectorySymlinks
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.outputDirectorySymlinks = $util.emptyArray;

                        /**
                         * ActionResult exitCode.
                         * @member {number} exitCode
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.exitCode = 0;

                        /**
                         * ActionResult stdoutRaw.
                         * @member {Uint8Array} stdoutRaw
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.stdoutRaw = $util.newBuffer([]);

                        /**
                         * ActionResult stdoutDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} stdoutDigest
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.stdoutDigest = null;

                        /**
                         * ActionResult stderrRaw.
                         * @member {Uint8Array} stderrRaw
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.stderrRaw = $util.newBuffer([]);

                        /**
                         * ActionResult stderrDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} stderrDigest
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.stderrDigest = null;

                        /**
                         * ActionResult executionMetadata.
                         * @member {build.bazel.remote.execution.v2.IExecutedActionMetadata|null|undefined} executionMetadata
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         */
                        ActionResult.prototype.executionMetadata = null;

                        /**
                         * Creates a new ActionResult instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {build.bazel.remote.execution.v2.IActionResult=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ActionResult} ActionResult instance
                         */
                        ActionResult.create = function create(properties) {
                            return new ActionResult(properties);
                        };

                        /**
                         * Encodes the specified ActionResult message. Does not implicitly {@link build.bazel.remote.execution.v2.ActionResult.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {build.bazel.remote.execution.v2.IActionResult} message ActionResult message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ActionResult.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.outputFiles != null && message.outputFiles.length)
                                for (let i = 0; i < message.outputFiles.length; ++i)
                                    $root.build.bazel.remote.execution.v2.OutputFile.encode(message.outputFiles[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.outputDirectories != null && message.outputDirectories.length)
                                for (let i = 0; i < message.outputDirectories.length; ++i)
                                    $root.build.bazel.remote.execution.v2.OutputDirectory.encode(message.outputDirectories[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.exitCode != null && Object.hasOwnProperty.call(message, "exitCode"))
                                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.exitCode);
                            if (message.stdoutRaw != null && Object.hasOwnProperty.call(message, "stdoutRaw"))
                                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.stdoutRaw);
                            if (message.stdoutDigest != null && Object.hasOwnProperty.call(message, "stdoutDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.stdoutDigest, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.stderrRaw != null && Object.hasOwnProperty.call(message, "stderrRaw"))
                                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stderrRaw);
                            if (message.stderrDigest != null && Object.hasOwnProperty.call(message, "stderrDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.stderrDigest, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                            if (message.executionMetadata != null && Object.hasOwnProperty.call(message, "executionMetadata"))
                                $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.encode(message.executionMetadata, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                            if (message.outputFileSymlinks != null && message.outputFileSymlinks.length)
                                for (let i = 0; i < message.outputFileSymlinks.length; ++i)
                                    $root.build.bazel.remote.execution.v2.OutputSymlink.encode(message.outputFileSymlinks[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                            if (message.outputDirectorySymlinks != null && message.outputDirectorySymlinks.length)
                                for (let i = 0; i < message.outputDirectorySymlinks.length; ++i)
                                    $root.build.bazel.remote.execution.v2.OutputSymlink.encode(message.outputDirectorySymlinks[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                            if (message.outputSymlinks != null && message.outputSymlinks.length)
                                for (let i = 0; i < message.outputSymlinks.length; ++i)
                                    $root.build.bazel.remote.execution.v2.OutputSymlink.encode(message.outputSymlinks[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified ActionResult message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ActionResult.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {build.bazel.remote.execution.v2.IActionResult} message ActionResult message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ActionResult.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ActionResult message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ActionResult} ActionResult
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ActionResult.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ActionResult();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 2: {
                                        if (!(message.outputFiles && message.outputFiles.length))
                                            message.outputFiles = [];
                                        message.outputFiles.push($root.build.bazel.remote.execution.v2.OutputFile.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 10: {
                                        if (!(message.outputFileSymlinks && message.outputFileSymlinks.length))
                                            message.outputFileSymlinks = [];
                                        message.outputFileSymlinks.push($root.build.bazel.remote.execution.v2.OutputSymlink.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 12: {
                                        if (!(message.outputSymlinks && message.outputSymlinks.length))
                                            message.outputSymlinks = [];
                                        message.outputSymlinks.push($root.build.bazel.remote.execution.v2.OutputSymlink.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 3: {
                                        if (!(message.outputDirectories && message.outputDirectories.length))
                                            message.outputDirectories = [];
                                        message.outputDirectories.push($root.build.bazel.remote.execution.v2.OutputDirectory.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 11: {
                                        if (!(message.outputDirectorySymlinks && message.outputDirectorySymlinks.length))
                                            message.outputDirectorySymlinks = [];
                                        message.outputDirectorySymlinks.push($root.build.bazel.remote.execution.v2.OutputSymlink.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 4: {
                                        message.exitCode = reader.int32();
                                        break;
                                    }
                                case 5: {
                                        message.stdoutRaw = reader.bytes();
                                        break;
                                    }
                                case 6: {
                                        message.stdoutDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 7: {
                                        message.stderrRaw = reader.bytes();
                                        break;
                                    }
                                case 8: {
                                        message.stderrDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 9: {
                                        message.executionMetadata = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ActionResult message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ActionResult} ActionResult
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ActionResult.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ActionResult message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ActionResult.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.outputFiles != null && message.hasOwnProperty("outputFiles")) {
                                if (!Array.isArray(message.outputFiles))
                                    return "outputFiles: array expected";
                                for (let i = 0; i < message.outputFiles.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.OutputFile.verify(message.outputFiles[i]);
                                    if (error)
                                        return "outputFiles." + error;
                                }
                            }
                            if (message.outputFileSymlinks != null && message.hasOwnProperty("outputFileSymlinks")) {
                                if (!Array.isArray(message.outputFileSymlinks))
                                    return "outputFileSymlinks: array expected";
                                for (let i = 0; i < message.outputFileSymlinks.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.OutputSymlink.verify(message.outputFileSymlinks[i]);
                                    if (error)
                                        return "outputFileSymlinks." + error;
                                }
                            }
                            if (message.outputSymlinks != null && message.hasOwnProperty("outputSymlinks")) {
                                if (!Array.isArray(message.outputSymlinks))
                                    return "outputSymlinks: array expected";
                                for (let i = 0; i < message.outputSymlinks.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.OutputSymlink.verify(message.outputSymlinks[i]);
                                    if (error)
                                        return "outputSymlinks." + error;
                                }
                            }
                            if (message.outputDirectories != null && message.hasOwnProperty("outputDirectories")) {
                                if (!Array.isArray(message.outputDirectories))
                                    return "outputDirectories: array expected";
                                for (let i = 0; i < message.outputDirectories.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.OutputDirectory.verify(message.outputDirectories[i]);
                                    if (error)
                                        return "outputDirectories." + error;
                                }
                            }
                            if (message.outputDirectorySymlinks != null && message.hasOwnProperty("outputDirectorySymlinks")) {
                                if (!Array.isArray(message.outputDirectorySymlinks))
                                    return "outputDirectorySymlinks: array expected";
                                for (let i = 0; i < message.outputDirectorySymlinks.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.OutputSymlink.verify(message.outputDirectorySymlinks[i]);
                                    if (error)
                                        return "outputDirectorySymlinks." + error;
                                }
                            }
                            if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                                if (!$util.isInteger(message.exitCode))
                                    return "exitCode: integer expected";
                            if (message.stdoutRaw != null && message.hasOwnProperty("stdoutRaw"))
                                if (!(message.stdoutRaw && typeof message.stdoutRaw.length === "number" || $util.isString(message.stdoutRaw)))
                                    return "stdoutRaw: buffer expected";
                            if (message.stdoutDigest != null && message.hasOwnProperty("stdoutDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.stdoutDigest);
                                if (error)
                                    return "stdoutDigest." + error;
                            }
                            if (message.stderrRaw != null && message.hasOwnProperty("stderrRaw"))
                                if (!(message.stderrRaw && typeof message.stderrRaw.length === "number" || $util.isString(message.stderrRaw)))
                                    return "stderrRaw: buffer expected";
                            if (message.stderrDigest != null && message.hasOwnProperty("stderrDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.stderrDigest);
                                if (error)
                                    return "stderrDigest." + error;
                            }
                            if (message.executionMetadata != null && message.hasOwnProperty("executionMetadata")) {
                                let error = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.verify(message.executionMetadata);
                                if (error)
                                    return "executionMetadata." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an ActionResult message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ActionResult} ActionResult
                         */
                        ActionResult.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ActionResult)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ActionResult();
                            if (object.outputFiles) {
                                if (!Array.isArray(object.outputFiles))
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputFiles: array expected");
                                message.outputFiles = [];
                                for (let i = 0; i < object.outputFiles.length; ++i) {
                                    if (typeof object.outputFiles[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputFiles: object expected");
                                    message.outputFiles[i] = $root.build.bazel.remote.execution.v2.OutputFile.fromObject(object.outputFiles[i]);
                                }
                            }
                            if (object.outputFileSymlinks) {
                                if (!Array.isArray(object.outputFileSymlinks))
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputFileSymlinks: array expected");
                                message.outputFileSymlinks = [];
                                for (let i = 0; i < object.outputFileSymlinks.length; ++i) {
                                    if (typeof object.outputFileSymlinks[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputFileSymlinks: object expected");
                                    message.outputFileSymlinks[i] = $root.build.bazel.remote.execution.v2.OutputSymlink.fromObject(object.outputFileSymlinks[i]);
                                }
                            }
                            if (object.outputSymlinks) {
                                if (!Array.isArray(object.outputSymlinks))
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputSymlinks: array expected");
                                message.outputSymlinks = [];
                                for (let i = 0; i < object.outputSymlinks.length; ++i) {
                                    if (typeof object.outputSymlinks[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputSymlinks: object expected");
                                    message.outputSymlinks[i] = $root.build.bazel.remote.execution.v2.OutputSymlink.fromObject(object.outputSymlinks[i]);
                                }
                            }
                            if (object.outputDirectories) {
                                if (!Array.isArray(object.outputDirectories))
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputDirectories: array expected");
                                message.outputDirectories = [];
                                for (let i = 0; i < object.outputDirectories.length; ++i) {
                                    if (typeof object.outputDirectories[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputDirectories: object expected");
                                    message.outputDirectories[i] = $root.build.bazel.remote.execution.v2.OutputDirectory.fromObject(object.outputDirectories[i]);
                                }
                            }
                            if (object.outputDirectorySymlinks) {
                                if (!Array.isArray(object.outputDirectorySymlinks))
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputDirectorySymlinks: array expected");
                                message.outputDirectorySymlinks = [];
                                for (let i = 0; i < object.outputDirectorySymlinks.length; ++i) {
                                    if (typeof object.outputDirectorySymlinks[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.ActionResult.outputDirectorySymlinks: object expected");
                                    message.outputDirectorySymlinks[i] = $root.build.bazel.remote.execution.v2.OutputSymlink.fromObject(object.outputDirectorySymlinks[i]);
                                }
                            }
                            if (object.exitCode != null)
                                message.exitCode = object.exitCode | 0;
                            if (object.stdoutRaw != null)
                                if (typeof object.stdoutRaw === "string")
                                    $util.base64.decode(object.stdoutRaw, message.stdoutRaw = $util.newBuffer($util.base64.length(object.stdoutRaw)), 0);
                                else if (object.stdoutRaw.length >= 0)
                                    message.stdoutRaw = object.stdoutRaw;
                            if (object.stdoutDigest != null) {
                                if (typeof object.stdoutDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.stdoutDigest: object expected");
                                message.stdoutDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.stdoutDigest);
                            }
                            if (object.stderrRaw != null)
                                if (typeof object.stderrRaw === "string")
                                    $util.base64.decode(object.stderrRaw, message.stderrRaw = $util.newBuffer($util.base64.length(object.stderrRaw)), 0);
                                else if (object.stderrRaw.length >= 0)
                                    message.stderrRaw = object.stderrRaw;
                            if (object.stderrDigest != null) {
                                if (typeof object.stderrDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.stderrDigest: object expected");
                                message.stderrDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.stderrDigest);
                            }
                            if (object.executionMetadata != null) {
                                if (typeof object.executionMetadata !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ActionResult.executionMetadata: object expected");
                                message.executionMetadata = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.fromObject(object.executionMetadata);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an ActionResult message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {build.bazel.remote.execution.v2.ActionResult} message ActionResult
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ActionResult.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.outputFiles = [];
                                object.outputDirectories = [];
                                object.outputFileSymlinks = [];
                                object.outputDirectorySymlinks = [];
                                object.outputSymlinks = [];
                            }
                            if (options.defaults) {
                                object.exitCode = 0;
                                if (options.bytes === String)
                                    object.stdoutRaw = "";
                                else {
                                    object.stdoutRaw = [];
                                    if (options.bytes !== Array)
                                        object.stdoutRaw = $util.newBuffer(object.stdoutRaw);
                                }
                                object.stdoutDigest = null;
                                if (options.bytes === String)
                                    object.stderrRaw = "";
                                else {
                                    object.stderrRaw = [];
                                    if (options.bytes !== Array)
                                        object.stderrRaw = $util.newBuffer(object.stderrRaw);
                                }
                                object.stderrDigest = null;
                                object.executionMetadata = null;
                            }
                            if (message.outputFiles && message.outputFiles.length) {
                                object.outputFiles = [];
                                for (let j = 0; j < message.outputFiles.length; ++j)
                                    object.outputFiles[j] = $root.build.bazel.remote.execution.v2.OutputFile.toObject(message.outputFiles[j], options);
                            }
                            if (message.outputDirectories && message.outputDirectories.length) {
                                object.outputDirectories = [];
                                for (let j = 0; j < message.outputDirectories.length; ++j)
                                    object.outputDirectories[j] = $root.build.bazel.remote.execution.v2.OutputDirectory.toObject(message.outputDirectories[j], options);
                            }
                            if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                                object.exitCode = message.exitCode;
                            if (message.stdoutRaw != null && message.hasOwnProperty("stdoutRaw"))
                                object.stdoutRaw = options.bytes === String ? $util.base64.encode(message.stdoutRaw, 0, message.stdoutRaw.length) : options.bytes === Array ? Array.prototype.slice.call(message.stdoutRaw) : message.stdoutRaw;
                            if (message.stdoutDigest != null && message.hasOwnProperty("stdoutDigest"))
                                object.stdoutDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.stdoutDigest, options);
                            if (message.stderrRaw != null && message.hasOwnProperty("stderrRaw"))
                                object.stderrRaw = options.bytes === String ? $util.base64.encode(message.stderrRaw, 0, message.stderrRaw.length) : options.bytes === Array ? Array.prototype.slice.call(message.stderrRaw) : message.stderrRaw;
                            if (message.stderrDigest != null && message.hasOwnProperty("stderrDigest"))
                                object.stderrDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.stderrDigest, options);
                            if (message.executionMetadata != null && message.hasOwnProperty("executionMetadata"))
                                object.executionMetadata = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.toObject(message.executionMetadata, options);
                            if (message.outputFileSymlinks && message.outputFileSymlinks.length) {
                                object.outputFileSymlinks = [];
                                for (let j = 0; j < message.outputFileSymlinks.length; ++j)
                                    object.outputFileSymlinks[j] = $root.build.bazel.remote.execution.v2.OutputSymlink.toObject(message.outputFileSymlinks[j], options);
                            }
                            if (message.outputDirectorySymlinks && message.outputDirectorySymlinks.length) {
                                object.outputDirectorySymlinks = [];
                                for (let j = 0; j < message.outputDirectorySymlinks.length; ++j)
                                    object.outputDirectorySymlinks[j] = $root.build.bazel.remote.execution.v2.OutputSymlink.toObject(message.outputDirectorySymlinks[j], options);
                            }
                            if (message.outputSymlinks && message.outputSymlinks.length) {
                                object.outputSymlinks = [];
                                for (let j = 0; j < message.outputSymlinks.length; ++j)
                                    object.outputSymlinks[j] = $root.build.bazel.remote.execution.v2.OutputSymlink.toObject(message.outputSymlinks[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this ActionResult to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ActionResult.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ActionResult
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ActionResult
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ActionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ActionResult";
                        };

                        return ActionResult;
                    })();

                    v2.OutputFile = (function() {

                        /**
                         * Properties of an OutputFile.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IOutputFile
                         * @property {string|null} [path] OutputFile path
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [digest] OutputFile digest
                         * @property {boolean|null} [isExecutable] OutputFile isExecutable
                         * @property {Uint8Array|null} [contents] OutputFile contents
                         * @property {build.bazel.remote.execution.v2.INodeProperties|null} [nodeProperties] OutputFile nodeProperties
                         */

                        /**
                         * Constructs a new OutputFile.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an OutputFile.
                         * @implements IOutputFile
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IOutputFile=} [properties] Properties to set
                         */
                        function OutputFile(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * OutputFile path.
                         * @member {string} path
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @instance
                         */
                        OutputFile.prototype.path = "";

                        /**
                         * OutputFile digest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} digest
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @instance
                         */
                        OutputFile.prototype.digest = null;

                        /**
                         * OutputFile isExecutable.
                         * @member {boolean} isExecutable
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @instance
                         */
                        OutputFile.prototype.isExecutable = false;

                        /**
                         * OutputFile contents.
                         * @member {Uint8Array} contents
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @instance
                         */
                        OutputFile.prototype.contents = $util.newBuffer([]);

                        /**
                         * OutputFile nodeProperties.
                         * @member {build.bazel.remote.execution.v2.INodeProperties|null|undefined} nodeProperties
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @instance
                         */
                        OutputFile.prototype.nodeProperties = null;

                        /**
                         * Creates a new OutputFile instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputFile=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.OutputFile} OutputFile instance
                         */
                        OutputFile.create = function create(properties) {
                            return new OutputFile(properties);
                        };

                        /**
                         * Encodes the specified OutputFile message. Does not implicitly {@link build.bazel.remote.execution.v2.OutputFile.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputFile} message OutputFile message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputFile.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                            if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.digest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.isExecutable != null && Object.hasOwnProperty.call(message, "isExecutable"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isExecutable);
                            if (message.contents != null && Object.hasOwnProperty.call(message, "contents"))
                                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.contents);
                            if (message.nodeProperties != null && Object.hasOwnProperty.call(message, "nodeProperties"))
                                $root.build.bazel.remote.execution.v2.NodeProperties.encode(message.nodeProperties, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified OutputFile message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.OutputFile.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputFile} message OutputFile message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputFile.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an OutputFile message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.OutputFile} OutputFile
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputFile.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.OutputFile();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.path = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.digest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.isExecutable = reader.bool();
                                        break;
                                    }
                                case 5: {
                                        message.contents = reader.bytes();
                                        break;
                                    }
                                case 7: {
                                        message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an OutputFile message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.OutputFile} OutputFile
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputFile.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an OutputFile message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        OutputFile.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.path != null && message.hasOwnProperty("path"))
                                if (!$util.isString(message.path))
                                    return "path: string expected";
                            if (message.digest != null && message.hasOwnProperty("digest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digest);
                                if (error)
                                    return "digest." + error;
                            }
                            if (message.isExecutable != null && message.hasOwnProperty("isExecutable"))
                                if (typeof message.isExecutable !== "boolean")
                                    return "isExecutable: boolean expected";
                            if (message.contents != null && message.hasOwnProperty("contents"))
                                if (!(message.contents && typeof message.contents.length === "number" || $util.isString(message.contents)))
                                    return "contents: buffer expected";
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties")) {
                                let error = $root.build.bazel.remote.execution.v2.NodeProperties.verify(message.nodeProperties);
                                if (error)
                                    return "nodeProperties." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an OutputFile message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.OutputFile} OutputFile
                         */
                        OutputFile.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.OutputFile)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.OutputFile();
                            if (object.path != null)
                                message.path = String(object.path);
                            if (object.digest != null) {
                                if (typeof object.digest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.OutputFile.digest: object expected");
                                message.digest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digest);
                            }
                            if (object.isExecutable != null)
                                message.isExecutable = Boolean(object.isExecutable);
                            if (object.contents != null)
                                if (typeof object.contents === "string")
                                    $util.base64.decode(object.contents, message.contents = $util.newBuffer($util.base64.length(object.contents)), 0);
                                else if (object.contents.length >= 0)
                                    message.contents = object.contents;
                            if (object.nodeProperties != null) {
                                if (typeof object.nodeProperties !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.OutputFile.nodeProperties: object expected");
                                message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.fromObject(object.nodeProperties);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an OutputFile message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.OutputFile} message OutputFile
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        OutputFile.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.path = "";
                                object.digest = null;
                                object.isExecutable = false;
                                if (options.bytes === String)
                                    object.contents = "";
                                else {
                                    object.contents = [];
                                    if (options.bytes !== Array)
                                        object.contents = $util.newBuffer(object.contents);
                                }
                                object.nodeProperties = null;
                            }
                            if (message.path != null && message.hasOwnProperty("path"))
                                object.path = message.path;
                            if (message.digest != null && message.hasOwnProperty("digest"))
                                object.digest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digest, options);
                            if (message.isExecutable != null && message.hasOwnProperty("isExecutable"))
                                object.isExecutable = message.isExecutable;
                            if (message.contents != null && message.hasOwnProperty("contents"))
                                object.contents = options.bytes === String ? $util.base64.encode(message.contents, 0, message.contents.length) : options.bytes === Array ? Array.prototype.slice.call(message.contents) : message.contents;
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties"))
                                object.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.toObject(message.nodeProperties, options);
                            return object;
                        };

                        /**
                         * Converts this OutputFile to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        OutputFile.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for OutputFile
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.OutputFile
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        OutputFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.OutputFile";
                        };

                        return OutputFile;
                    })();

                    v2.Tree = (function() {

                        /**
                         * Properties of a Tree.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface ITree
                         * @property {build.bazel.remote.execution.v2.IDirectory|null} [root] Tree root
                         * @property {Array.<build.bazel.remote.execution.v2.IDirectory>|null} [children] Tree children
                         */

                        /**
                         * Constructs a new Tree.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a Tree.
                         * @implements ITree
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.ITree=} [properties] Properties to set
                         */
                        function Tree(properties) {
                            this.children = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Tree root.
                         * @member {build.bazel.remote.execution.v2.IDirectory|null|undefined} root
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @instance
                         */
                        Tree.prototype.root = null;

                        /**
                         * Tree children.
                         * @member {Array.<build.bazel.remote.execution.v2.IDirectory>} children
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @instance
                         */
                        Tree.prototype.children = $util.emptyArray;

                        /**
                         * Creates a new Tree instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {build.bazel.remote.execution.v2.ITree=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.Tree} Tree instance
                         */
                        Tree.create = function create(properties) {
                            return new Tree(properties);
                        };

                        /**
                         * Encodes the specified Tree message. Does not implicitly {@link build.bazel.remote.execution.v2.Tree.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {build.bazel.remote.execution.v2.ITree} message Tree message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Tree.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.root != null && Object.hasOwnProperty.call(message, "root"))
                                $root.build.bazel.remote.execution.v2.Directory.encode(message.root, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.children != null && message.children.length)
                                for (let i = 0; i < message.children.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Directory.encode(message.children[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Tree message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Tree.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {build.bazel.remote.execution.v2.ITree} message Tree message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Tree.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Tree message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.Tree} Tree
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Tree.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Tree();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.root = $root.build.bazel.remote.execution.v2.Directory.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        if (!(message.children && message.children.length))
                                            message.children = [];
                                        message.children.push($root.build.bazel.remote.execution.v2.Directory.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Tree message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.Tree} Tree
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Tree.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Tree message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Tree.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.root != null && message.hasOwnProperty("root")) {
                                let error = $root.build.bazel.remote.execution.v2.Directory.verify(message.root);
                                if (error)
                                    return "root." + error;
                            }
                            if (message.children != null && message.hasOwnProperty("children")) {
                                if (!Array.isArray(message.children))
                                    return "children: array expected";
                                for (let i = 0; i < message.children.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Directory.verify(message.children[i]);
                                    if (error)
                                        return "children." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Tree message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.Tree} Tree
                         */
                        Tree.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.Tree)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.Tree();
                            if (object.root != null) {
                                if (typeof object.root !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.Tree.root: object expected");
                                message.root = $root.build.bazel.remote.execution.v2.Directory.fromObject(object.root);
                            }
                            if (object.children) {
                                if (!Array.isArray(object.children))
                                    throw TypeError(".build.bazel.remote.execution.v2.Tree.children: array expected");
                                message.children = [];
                                for (let i = 0; i < object.children.length; ++i) {
                                    if (typeof object.children[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.Tree.children: object expected");
                                    message.children[i] = $root.build.bazel.remote.execution.v2.Directory.fromObject(object.children[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Tree message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {build.bazel.remote.execution.v2.Tree} message Tree
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Tree.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.children = [];
                            if (options.defaults)
                                object.root = null;
                            if (message.root != null && message.hasOwnProperty("root"))
                                object.root = $root.build.bazel.remote.execution.v2.Directory.toObject(message.root, options);
                            if (message.children && message.children.length) {
                                object.children = [];
                                for (let j = 0; j < message.children.length; ++j)
                                    object.children[j] = $root.build.bazel.remote.execution.v2.Directory.toObject(message.children[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Tree to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Tree.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Tree
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.Tree
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Tree.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.Tree";
                        };

                        return Tree;
                    })();

                    v2.OutputDirectory = (function() {

                        /**
                         * Properties of an OutputDirectory.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IOutputDirectory
                         * @property {string|null} [path] OutputDirectory path
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [treeDigest] OutputDirectory treeDigest
                         * @property {boolean|null} [isTopologicallySorted] OutputDirectory isTopologicallySorted
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [rootDirectoryDigest] OutputDirectory rootDirectoryDigest
                         */

                        /**
                         * Constructs a new OutputDirectory.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an OutputDirectory.
                         * @implements IOutputDirectory
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IOutputDirectory=} [properties] Properties to set
                         */
                        function OutputDirectory(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * OutputDirectory path.
                         * @member {string} path
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @instance
                         */
                        OutputDirectory.prototype.path = "";

                        /**
                         * OutputDirectory treeDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} treeDigest
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @instance
                         */
                        OutputDirectory.prototype.treeDigest = null;

                        /**
                         * OutputDirectory isTopologicallySorted.
                         * @member {boolean} isTopologicallySorted
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @instance
                         */
                        OutputDirectory.prototype.isTopologicallySorted = false;

                        /**
                         * OutputDirectory rootDirectoryDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} rootDirectoryDigest
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @instance
                         */
                        OutputDirectory.prototype.rootDirectoryDigest = null;

                        /**
                         * Creates a new OutputDirectory instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputDirectory=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.OutputDirectory} OutputDirectory instance
                         */
                        OutputDirectory.create = function create(properties) {
                            return new OutputDirectory(properties);
                        };

                        /**
                         * Encodes the specified OutputDirectory message. Does not implicitly {@link build.bazel.remote.execution.v2.OutputDirectory.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputDirectory} message OutputDirectory message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputDirectory.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                            if (message.treeDigest != null && Object.hasOwnProperty.call(message, "treeDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.treeDigest, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.isTopologicallySorted != null && Object.hasOwnProperty.call(message, "isTopologicallySorted"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isTopologicallySorted);
                            if (message.rootDirectoryDigest != null && Object.hasOwnProperty.call(message, "rootDirectoryDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.rootDirectoryDigest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified OutputDirectory message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.OutputDirectory.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputDirectory} message OutputDirectory message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputDirectory.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an OutputDirectory message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.OutputDirectory} OutputDirectory
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputDirectory.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.OutputDirectory();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.path = reader.string();
                                        break;
                                    }
                                case 3: {
                                        message.treeDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.isTopologicallySorted = reader.bool();
                                        break;
                                    }
                                case 5: {
                                        message.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an OutputDirectory message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.OutputDirectory} OutputDirectory
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputDirectory.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an OutputDirectory message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        OutputDirectory.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.path != null && message.hasOwnProperty("path"))
                                if (!$util.isString(message.path))
                                    return "path: string expected";
                            if (message.treeDigest != null && message.hasOwnProperty("treeDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.treeDigest);
                                if (error)
                                    return "treeDigest." + error;
                            }
                            if (message.isTopologicallySorted != null && message.hasOwnProperty("isTopologicallySorted"))
                                if (typeof message.isTopologicallySorted !== "boolean")
                                    return "isTopologicallySorted: boolean expected";
                            if (message.rootDirectoryDigest != null && message.hasOwnProperty("rootDirectoryDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.rootDirectoryDigest);
                                if (error)
                                    return "rootDirectoryDigest." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an OutputDirectory message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.OutputDirectory} OutputDirectory
                         */
                        OutputDirectory.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.OutputDirectory)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.OutputDirectory();
                            if (object.path != null)
                                message.path = String(object.path);
                            if (object.treeDigest != null) {
                                if (typeof object.treeDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.OutputDirectory.treeDigest: object expected");
                                message.treeDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.treeDigest);
                            }
                            if (object.isTopologicallySorted != null)
                                message.isTopologicallySorted = Boolean(object.isTopologicallySorted);
                            if (object.rootDirectoryDigest != null) {
                                if (typeof object.rootDirectoryDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.OutputDirectory.rootDirectoryDigest: object expected");
                                message.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.rootDirectoryDigest);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an OutputDirectory message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {build.bazel.remote.execution.v2.OutputDirectory} message OutputDirectory
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        OutputDirectory.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.path = "";
                                object.treeDigest = null;
                                object.isTopologicallySorted = false;
                                object.rootDirectoryDigest = null;
                            }
                            if (message.path != null && message.hasOwnProperty("path"))
                                object.path = message.path;
                            if (message.treeDigest != null && message.hasOwnProperty("treeDigest"))
                                object.treeDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.treeDigest, options);
                            if (message.isTopologicallySorted != null && message.hasOwnProperty("isTopologicallySorted"))
                                object.isTopologicallySorted = message.isTopologicallySorted;
                            if (message.rootDirectoryDigest != null && message.hasOwnProperty("rootDirectoryDigest"))
                                object.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.rootDirectoryDigest, options);
                            return object;
                        };

                        /**
                         * Converts this OutputDirectory to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        OutputDirectory.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for OutputDirectory
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.OutputDirectory
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        OutputDirectory.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.OutputDirectory";
                        };

                        return OutputDirectory;
                    })();

                    v2.OutputSymlink = (function() {

                        /**
                         * Properties of an OutputSymlink.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IOutputSymlink
                         * @property {string|null} [path] OutputSymlink path
                         * @property {string|null} [target] OutputSymlink target
                         * @property {build.bazel.remote.execution.v2.INodeProperties|null} [nodeProperties] OutputSymlink nodeProperties
                         */

                        /**
                         * Constructs a new OutputSymlink.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an OutputSymlink.
                         * @implements IOutputSymlink
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IOutputSymlink=} [properties] Properties to set
                         */
                        function OutputSymlink(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * OutputSymlink path.
                         * @member {string} path
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @instance
                         */
                        OutputSymlink.prototype.path = "";

                        /**
                         * OutputSymlink target.
                         * @member {string} target
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @instance
                         */
                        OutputSymlink.prototype.target = "";

                        /**
                         * OutputSymlink nodeProperties.
                         * @member {build.bazel.remote.execution.v2.INodeProperties|null|undefined} nodeProperties
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @instance
                         */
                        OutputSymlink.prototype.nodeProperties = null;

                        /**
                         * Creates a new OutputSymlink instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputSymlink=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.OutputSymlink} OutputSymlink instance
                         */
                        OutputSymlink.create = function create(properties) {
                            return new OutputSymlink(properties);
                        };

                        /**
                         * Encodes the specified OutputSymlink message. Does not implicitly {@link build.bazel.remote.execution.v2.OutputSymlink.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputSymlink} message OutputSymlink message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputSymlink.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.target);
                            if (message.nodeProperties != null && Object.hasOwnProperty.call(message, "nodeProperties"))
                                $root.build.bazel.remote.execution.v2.NodeProperties.encode(message.nodeProperties, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified OutputSymlink message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.OutputSymlink.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {build.bazel.remote.execution.v2.IOutputSymlink} message OutputSymlink message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        OutputSymlink.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an OutputSymlink message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.OutputSymlink} OutputSymlink
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputSymlink.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.OutputSymlink();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.path = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.target = reader.string();
                                        break;
                                    }
                                case 4: {
                                        message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an OutputSymlink message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.OutputSymlink} OutputSymlink
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        OutputSymlink.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an OutputSymlink message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        OutputSymlink.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.path != null && message.hasOwnProperty("path"))
                                if (!$util.isString(message.path))
                                    return "path: string expected";
                            if (message.target != null && message.hasOwnProperty("target"))
                                if (!$util.isString(message.target))
                                    return "target: string expected";
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties")) {
                                let error = $root.build.bazel.remote.execution.v2.NodeProperties.verify(message.nodeProperties);
                                if (error)
                                    return "nodeProperties." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an OutputSymlink message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.OutputSymlink} OutputSymlink
                         */
                        OutputSymlink.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.OutputSymlink)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.OutputSymlink();
                            if (object.path != null)
                                message.path = String(object.path);
                            if (object.target != null)
                                message.target = String(object.target);
                            if (object.nodeProperties != null) {
                                if (typeof object.nodeProperties !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.OutputSymlink.nodeProperties: object expected");
                                message.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.fromObject(object.nodeProperties);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an OutputSymlink message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {build.bazel.remote.execution.v2.OutputSymlink} message OutputSymlink
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        OutputSymlink.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.path = "";
                                object.target = "";
                                object.nodeProperties = null;
                            }
                            if (message.path != null && message.hasOwnProperty("path"))
                                object.path = message.path;
                            if (message.target != null && message.hasOwnProperty("target"))
                                object.target = message.target;
                            if (message.nodeProperties != null && message.hasOwnProperty("nodeProperties"))
                                object.nodeProperties = $root.build.bazel.remote.execution.v2.NodeProperties.toObject(message.nodeProperties, options);
                            return object;
                        };

                        /**
                         * Converts this OutputSymlink to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        OutputSymlink.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for OutputSymlink
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.OutputSymlink
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        OutputSymlink.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.OutputSymlink";
                        };

                        return OutputSymlink;
                    })();

                    v2.ExecutionPolicy = (function() {

                        /**
                         * Properties of an ExecutionPolicy.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IExecutionPolicy
                         * @property {number|null} [priority] ExecutionPolicy priority
                         */

                        /**
                         * Constructs a new ExecutionPolicy.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ExecutionPolicy.
                         * @implements IExecutionPolicy
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IExecutionPolicy=} [properties] Properties to set
                         */
                        function ExecutionPolicy(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ExecutionPolicy priority.
                         * @member {number} priority
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @instance
                         */
                        ExecutionPolicy.prototype.priority = 0;

                        /**
                         * Creates a new ExecutionPolicy instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionPolicy=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ExecutionPolicy} ExecutionPolicy instance
                         */
                        ExecutionPolicy.create = function create(properties) {
                            return new ExecutionPolicy(properties);
                        };

                        /**
                         * Encodes the specified ExecutionPolicy message. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutionPolicy.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionPolicy} message ExecutionPolicy message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutionPolicy.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.priority);
                            return writer;
                        };

                        /**
                         * Encodes the specified ExecutionPolicy message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutionPolicy.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionPolicy} message ExecutionPolicy message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutionPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ExecutionPolicy message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ExecutionPolicy} ExecutionPolicy
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutionPolicy.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ExecutionPolicy();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.priority = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ExecutionPolicy message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ExecutionPolicy} ExecutionPolicy
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutionPolicy.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ExecutionPolicy message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ExecutionPolicy.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.priority != null && message.hasOwnProperty("priority"))
                                if (!$util.isInteger(message.priority))
                                    return "priority: integer expected";
                            return null;
                        };

                        /**
                         * Creates an ExecutionPolicy message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ExecutionPolicy} ExecutionPolicy
                         */
                        ExecutionPolicy.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ExecutionPolicy)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ExecutionPolicy();
                            if (object.priority != null)
                                message.priority = object.priority | 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from an ExecutionPolicy message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.ExecutionPolicy} message ExecutionPolicy
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ExecutionPolicy.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.priority = 0;
                            if (message.priority != null && message.hasOwnProperty("priority"))
                                object.priority = message.priority;
                            return object;
                        };

                        /**
                         * Converts this ExecutionPolicy to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ExecutionPolicy.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ExecutionPolicy
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ExecutionPolicy
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ExecutionPolicy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ExecutionPolicy";
                        };

                        return ExecutionPolicy;
                    })();

                    v2.ResultsCachePolicy = (function() {

                        /**
                         * Properties of a ResultsCachePolicy.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IResultsCachePolicy
                         * @property {number|null} [priority] ResultsCachePolicy priority
                         */

                        /**
                         * Constructs a new ResultsCachePolicy.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a ResultsCachePolicy.
                         * @implements IResultsCachePolicy
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IResultsCachePolicy=} [properties] Properties to set
                         */
                        function ResultsCachePolicy(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ResultsCachePolicy priority.
                         * @member {number} priority
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @instance
                         */
                        ResultsCachePolicy.prototype.priority = 0;

                        /**
                         * Creates a new ResultsCachePolicy instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.IResultsCachePolicy=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ResultsCachePolicy} ResultsCachePolicy instance
                         */
                        ResultsCachePolicy.create = function create(properties) {
                            return new ResultsCachePolicy(properties);
                        };

                        /**
                         * Encodes the specified ResultsCachePolicy message. Does not implicitly {@link build.bazel.remote.execution.v2.ResultsCachePolicy.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.IResultsCachePolicy} message ResultsCachePolicy message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ResultsCachePolicy.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.priority);
                            return writer;
                        };

                        /**
                         * Encodes the specified ResultsCachePolicy message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ResultsCachePolicy.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.IResultsCachePolicy} message ResultsCachePolicy message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ResultsCachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ResultsCachePolicy message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ResultsCachePolicy} ResultsCachePolicy
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ResultsCachePolicy.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ResultsCachePolicy();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.priority = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ResultsCachePolicy message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ResultsCachePolicy} ResultsCachePolicy
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ResultsCachePolicy.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ResultsCachePolicy message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ResultsCachePolicy.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.priority != null && message.hasOwnProperty("priority"))
                                if (!$util.isInteger(message.priority))
                                    return "priority: integer expected";
                            return null;
                        };

                        /**
                         * Creates a ResultsCachePolicy message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ResultsCachePolicy} ResultsCachePolicy
                         */
                        ResultsCachePolicy.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ResultsCachePolicy)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ResultsCachePolicy();
                            if (object.priority != null)
                                message.priority = object.priority | 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a ResultsCachePolicy message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {build.bazel.remote.execution.v2.ResultsCachePolicy} message ResultsCachePolicy
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ResultsCachePolicy.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.priority = 0;
                            if (message.priority != null && message.hasOwnProperty("priority"))
                                object.priority = message.priority;
                            return object;
                        };

                        /**
                         * Converts this ResultsCachePolicy to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ResultsCachePolicy.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ResultsCachePolicy
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ResultsCachePolicy
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ResultsCachePolicy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ResultsCachePolicy";
                        };

                        return ResultsCachePolicy;
                    })();

                    v2.ExecuteRequest = (function() {

                        /**
                         * Properties of an ExecuteRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IExecuteRequest
                         * @property {string|null} [instanceName] ExecuteRequest instanceName
                         * @property {boolean|null} [skipCacheLookup] ExecuteRequest skipCacheLookup
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [actionDigest] ExecuteRequest actionDigest
                         * @property {build.bazel.remote.execution.v2.IExecutionPolicy|null} [executionPolicy] ExecuteRequest executionPolicy
                         * @property {build.bazel.remote.execution.v2.IResultsCachePolicy|null} [resultsCachePolicy] ExecuteRequest resultsCachePolicy
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] ExecuteRequest digestFunction
                         * @property {boolean|null} [inlineStdout] ExecuteRequest inlineStdout
                         * @property {boolean|null} [inlineStderr] ExecuteRequest inlineStderr
                         * @property {Array.<string>|null} [inlineOutputFiles] ExecuteRequest inlineOutputFiles
                         */

                        /**
                         * Constructs a new ExecuteRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ExecuteRequest.
                         * @implements IExecuteRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IExecuteRequest=} [properties] Properties to set
                         */
                        function ExecuteRequest(properties) {
                            this.inlineOutputFiles = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ExecuteRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.instanceName = "";

                        /**
                         * ExecuteRequest skipCacheLookup.
                         * @member {boolean} skipCacheLookup
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.skipCacheLookup = false;

                        /**
                         * ExecuteRequest actionDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} actionDigest
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.actionDigest = null;

                        /**
                         * ExecuteRequest executionPolicy.
                         * @member {build.bazel.remote.execution.v2.IExecutionPolicy|null|undefined} executionPolicy
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.executionPolicy = null;

                        /**
                         * ExecuteRequest resultsCachePolicy.
                         * @member {build.bazel.remote.execution.v2.IResultsCachePolicy|null|undefined} resultsCachePolicy
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.resultsCachePolicy = null;

                        /**
                         * ExecuteRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.digestFunction = 0;

                        /**
                         * ExecuteRequest inlineStdout.
                         * @member {boolean} inlineStdout
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.inlineStdout = false;

                        /**
                         * ExecuteRequest inlineStderr.
                         * @member {boolean} inlineStderr
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.inlineStderr = false;

                        /**
                         * ExecuteRequest inlineOutputFiles.
                         * @member {Array.<string>} inlineOutputFiles
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         */
                        ExecuteRequest.prototype.inlineOutputFiles = $util.emptyArray;

                        /**
                         * Creates a new ExecuteRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ExecuteRequest} ExecuteRequest instance
                         */
                        ExecuteRequest.create = function create(properties) {
                            return new ExecuteRequest(properties);
                        };

                        /**
                         * Encodes the specified ExecuteRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.ExecuteRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteRequest} message ExecuteRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecuteRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.skipCacheLookup != null && Object.hasOwnProperty.call(message, "skipCacheLookup"))
                                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.skipCacheLookup);
                            if (message.actionDigest != null && Object.hasOwnProperty.call(message, "actionDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.actionDigest, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.executionPolicy != null && Object.hasOwnProperty.call(message, "executionPolicy"))
                                $root.build.bazel.remote.execution.v2.ExecutionPolicy.encode(message.executionPolicy, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                            if (message.resultsCachePolicy != null && Object.hasOwnProperty.call(message, "resultsCachePolicy"))
                                $root.build.bazel.remote.execution.v2.ResultsCachePolicy.encode(message.resultsCachePolicy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.digestFunction);
                            if (message.inlineStdout != null && Object.hasOwnProperty.call(message, "inlineStdout"))
                                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.inlineStdout);
                            if (message.inlineStderr != null && Object.hasOwnProperty.call(message, "inlineStderr"))
                                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.inlineStderr);
                            if (message.inlineOutputFiles != null && message.inlineOutputFiles.length)
                                for (let i = 0; i < message.inlineOutputFiles.length; ++i)
                                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.inlineOutputFiles[i]);
                            return writer;
                        };

                        /**
                         * Encodes the specified ExecuteRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ExecuteRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteRequest} message ExecuteRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ExecuteRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ExecuteRequest} ExecuteRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecuteRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ExecuteRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 3: {
                                        message.skipCacheLookup = reader.bool();
                                        break;
                                    }
                                case 6: {
                                        message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 7: {
                                        message.executionPolicy = $root.build.bazel.remote.execution.v2.ExecutionPolicy.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 8: {
                                        message.resultsCachePolicy = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 9: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                case 10: {
                                        message.inlineStdout = reader.bool();
                                        break;
                                    }
                                case 11: {
                                        message.inlineStderr = reader.bool();
                                        break;
                                    }
                                case 12: {
                                        if (!(message.inlineOutputFiles && message.inlineOutputFiles.length))
                                            message.inlineOutputFiles = [];
                                        message.inlineOutputFiles.push(reader.string());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ExecuteRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ExecuteRequest} ExecuteRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ExecuteRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ExecuteRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.skipCacheLookup != null && message.hasOwnProperty("skipCacheLookup"))
                                if (typeof message.skipCacheLookup !== "boolean")
                                    return "skipCacheLookup: boolean expected";
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.actionDigest);
                                if (error)
                                    return "actionDigest." + error;
                            }
                            if (message.executionPolicy != null && message.hasOwnProperty("executionPolicy")) {
                                let error = $root.build.bazel.remote.execution.v2.ExecutionPolicy.verify(message.executionPolicy);
                                if (error)
                                    return "executionPolicy." + error;
                            }
                            if (message.resultsCachePolicy != null && message.hasOwnProperty("resultsCachePolicy")) {
                                let error = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.verify(message.resultsCachePolicy);
                                if (error)
                                    return "resultsCachePolicy." + error;
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            if (message.inlineStdout != null && message.hasOwnProperty("inlineStdout"))
                                if (typeof message.inlineStdout !== "boolean")
                                    return "inlineStdout: boolean expected";
                            if (message.inlineStderr != null && message.hasOwnProperty("inlineStderr"))
                                if (typeof message.inlineStderr !== "boolean")
                                    return "inlineStderr: boolean expected";
                            if (message.inlineOutputFiles != null && message.hasOwnProperty("inlineOutputFiles")) {
                                if (!Array.isArray(message.inlineOutputFiles))
                                    return "inlineOutputFiles: array expected";
                                for (let i = 0; i < message.inlineOutputFiles.length; ++i)
                                    if (!$util.isString(message.inlineOutputFiles[i]))
                                        return "inlineOutputFiles: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates an ExecuteRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ExecuteRequest} ExecuteRequest
                         */
                        ExecuteRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ExecuteRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ExecuteRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.skipCacheLookup != null)
                                message.skipCacheLookup = Boolean(object.skipCacheLookup);
                            if (object.actionDigest != null) {
                                if (typeof object.actionDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteRequest.actionDigest: object expected");
                                message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.actionDigest);
                            }
                            if (object.executionPolicy != null) {
                                if (typeof object.executionPolicy !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteRequest.executionPolicy: object expected");
                                message.executionPolicy = $root.build.bazel.remote.execution.v2.ExecutionPolicy.fromObject(object.executionPolicy);
                            }
                            if (object.resultsCachePolicy != null) {
                                if (typeof object.resultsCachePolicy !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteRequest.resultsCachePolicy: object expected");
                                message.resultsCachePolicy = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.fromObject(object.resultsCachePolicy);
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            if (object.inlineStdout != null)
                                message.inlineStdout = Boolean(object.inlineStdout);
                            if (object.inlineStderr != null)
                                message.inlineStderr = Boolean(object.inlineStderr);
                            if (object.inlineOutputFiles) {
                                if (!Array.isArray(object.inlineOutputFiles))
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteRequest.inlineOutputFiles: array expected");
                                message.inlineOutputFiles = [];
                                for (let i = 0; i < object.inlineOutputFiles.length; ++i)
                                    message.inlineOutputFiles[i] = String(object.inlineOutputFiles[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an ExecuteRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.ExecuteRequest} message ExecuteRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ExecuteRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.inlineOutputFiles = [];
                            if (options.defaults) {
                                object.instanceName = "";
                                object.skipCacheLookup = false;
                                object.actionDigest = null;
                                object.executionPolicy = null;
                                object.resultsCachePolicy = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                                object.inlineStdout = false;
                                object.inlineStderr = false;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.skipCacheLookup != null && message.hasOwnProperty("skipCacheLookup"))
                                object.skipCacheLookup = message.skipCacheLookup;
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest"))
                                object.actionDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.actionDigest, options);
                            if (message.executionPolicy != null && message.hasOwnProperty("executionPolicy"))
                                object.executionPolicy = $root.build.bazel.remote.execution.v2.ExecutionPolicy.toObject(message.executionPolicy, options);
                            if (message.resultsCachePolicy != null && message.hasOwnProperty("resultsCachePolicy"))
                                object.resultsCachePolicy = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.toObject(message.resultsCachePolicy, options);
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            if (message.inlineStdout != null && message.hasOwnProperty("inlineStdout"))
                                object.inlineStdout = message.inlineStdout;
                            if (message.inlineStderr != null && message.hasOwnProperty("inlineStderr"))
                                object.inlineStderr = message.inlineStderr;
                            if (message.inlineOutputFiles && message.inlineOutputFiles.length) {
                                object.inlineOutputFiles = [];
                                for (let j = 0; j < message.inlineOutputFiles.length; ++j)
                                    object.inlineOutputFiles[j] = message.inlineOutputFiles[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this ExecuteRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ExecuteRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ExecuteRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ExecuteRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ExecuteRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ExecuteRequest";
                        };

                        return ExecuteRequest;
                    })();

                    v2.LogFile = (function() {

                        /**
                         * Properties of a LogFile.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface ILogFile
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [digest] LogFile digest
                         * @property {boolean|null} [humanReadable] LogFile humanReadable
                         */

                        /**
                         * Constructs a new LogFile.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a LogFile.
                         * @implements ILogFile
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.ILogFile=} [properties] Properties to set
                         */
                        function LogFile(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * LogFile digest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} digest
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @instance
                         */
                        LogFile.prototype.digest = null;

                        /**
                         * LogFile humanReadable.
                         * @member {boolean} humanReadable
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @instance
                         */
                        LogFile.prototype.humanReadable = false;

                        /**
                         * Creates a new LogFile instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.ILogFile=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.LogFile} LogFile instance
                         */
                        LogFile.create = function create(properties) {
                            return new LogFile(properties);
                        };

                        /**
                         * Encodes the specified LogFile message. Does not implicitly {@link build.bazel.remote.execution.v2.LogFile.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.ILogFile} message LogFile message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        LogFile.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.digest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.humanReadable != null && Object.hasOwnProperty.call(message, "humanReadable"))
                                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.humanReadable);
                            return writer;
                        };

                        /**
                         * Encodes the specified LogFile message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.LogFile.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.ILogFile} message LogFile message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        LogFile.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a LogFile message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.LogFile} LogFile
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        LogFile.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.LogFile();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.digest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.humanReadable = reader.bool();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a LogFile message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.LogFile} LogFile
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        LogFile.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a LogFile message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        LogFile.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.digest != null && message.hasOwnProperty("digest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digest);
                                if (error)
                                    return "digest." + error;
                            }
                            if (message.humanReadable != null && message.hasOwnProperty("humanReadable"))
                                if (typeof message.humanReadable !== "boolean")
                                    return "humanReadable: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a LogFile message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.LogFile} LogFile
                         */
                        LogFile.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.LogFile)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.LogFile();
                            if (object.digest != null) {
                                if (typeof object.digest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.LogFile.digest: object expected");
                                message.digest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digest);
                            }
                            if (object.humanReadable != null)
                                message.humanReadable = Boolean(object.humanReadable);
                            return message;
                        };

                        /**
                         * Creates a plain object from a LogFile message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {build.bazel.remote.execution.v2.LogFile} message LogFile
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        LogFile.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.digest = null;
                                object.humanReadable = false;
                            }
                            if (message.digest != null && message.hasOwnProperty("digest"))
                                object.digest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digest, options);
                            if (message.humanReadable != null && message.hasOwnProperty("humanReadable"))
                                object.humanReadable = message.humanReadable;
                            return object;
                        };

                        /**
                         * Converts this LogFile to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        LogFile.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for LogFile
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.LogFile
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        LogFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.LogFile";
                        };

                        return LogFile;
                    })();

                    v2.ExecuteResponse = (function() {

                        /**
                         * Properties of an ExecuteResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IExecuteResponse
                         * @property {build.bazel.remote.execution.v2.IActionResult|null} [result] ExecuteResponse result
                         * @property {boolean|null} [cachedResult] ExecuteResponse cachedResult
                         * @property {google.rpc.IStatus|null} [status] ExecuteResponse status
                         * @property {Object.<string,build.bazel.remote.execution.v2.ILogFile>|null} [serverLogs] ExecuteResponse serverLogs
                         * @property {string|null} [message] ExecuteResponse message
                         */

                        /**
                         * Constructs a new ExecuteResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ExecuteResponse.
                         * @implements IExecuteResponse
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IExecuteResponse=} [properties] Properties to set
                         */
                        function ExecuteResponse(properties) {
                            this.serverLogs = {};
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ExecuteResponse result.
                         * @member {build.bazel.remote.execution.v2.IActionResult|null|undefined} result
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @instance
                         */
                        ExecuteResponse.prototype.result = null;

                        /**
                         * ExecuteResponse cachedResult.
                         * @member {boolean} cachedResult
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @instance
                         */
                        ExecuteResponse.prototype.cachedResult = false;

                        /**
                         * ExecuteResponse status.
                         * @member {google.rpc.IStatus|null|undefined} status
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @instance
                         */
                        ExecuteResponse.prototype.status = null;

                        /**
                         * ExecuteResponse serverLogs.
                         * @member {Object.<string,build.bazel.remote.execution.v2.ILogFile>} serverLogs
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @instance
                         */
                        ExecuteResponse.prototype.serverLogs = $util.emptyObject;

                        /**
                         * ExecuteResponse message.
                         * @member {string} message
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @instance
                         */
                        ExecuteResponse.prototype.message = "";

                        /**
                         * Creates a new ExecuteResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ExecuteResponse} ExecuteResponse instance
                         */
                        ExecuteResponse.create = function create(properties) {
                            return new ExecuteResponse(properties);
                        };

                        /**
                         * Encodes the specified ExecuteResponse message. Does not implicitly {@link build.bazel.remote.execution.v2.ExecuteResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteResponse} message ExecuteResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecuteResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                                $root.build.bazel.remote.execution.v2.ActionResult.encode(message.result, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.cachedResult != null && Object.hasOwnProperty.call(message, "cachedResult"))
                                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.cachedResult);
                            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                                $root.google.rpc.Status.encode(message.status, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.serverLogs != null && Object.hasOwnProperty.call(message, "serverLogs"))
                                for (let keys = Object.keys(message.serverLogs), i = 0; i < keys.length; ++i) {
                                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                                    $root.build.bazel.remote.execution.v2.LogFile.encode(message.serverLogs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                                }
                            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);
                            return writer;
                        };

                        /**
                         * Encodes the specified ExecuteResponse message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ExecuteResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteResponse} message ExecuteResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecuteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ExecuteResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ExecuteResponse} ExecuteResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecuteResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ExecuteResponse(), key, value;
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.result = $root.build.bazel.remote.execution.v2.ActionResult.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.cachedResult = reader.bool();
                                        break;
                                    }
                                case 3: {
                                        message.status = $root.google.rpc.Status.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        if (message.serverLogs === $util.emptyObject)
                                            message.serverLogs = {};
                                        let end2 = reader.uint32() + reader.pos;
                                        key = "";
                                        value = null;
                                        while (reader.pos < end2) {
                                            let tag2 = reader.uint32();
                                            switch (tag2 >>> 3) {
                                            case 1:
                                                key = reader.string();
                                                break;
                                            case 2:
                                                value = $root.build.bazel.remote.execution.v2.LogFile.decode(reader, reader.uint32());
                                                break;
                                            default:
                                                reader.skipType(tag2 & 7);
                                                break;
                                            }
                                        }
                                        message.serverLogs[key] = value;
                                        break;
                                    }
                                case 5: {
                                        message.message = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ExecuteResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ExecuteResponse} ExecuteResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecuteResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ExecuteResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ExecuteResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.result != null && message.hasOwnProperty("result")) {
                                let error = $root.build.bazel.remote.execution.v2.ActionResult.verify(message.result);
                                if (error)
                                    return "result." + error;
                            }
                            if (message.cachedResult != null && message.hasOwnProperty("cachedResult"))
                                if (typeof message.cachedResult !== "boolean")
                                    return "cachedResult: boolean expected";
                            if (message.status != null && message.hasOwnProperty("status")) {
                                let error = $root.google.rpc.Status.verify(message.status);
                                if (error)
                                    return "status." + error;
                            }
                            if (message.serverLogs != null && message.hasOwnProperty("serverLogs")) {
                                if (!$util.isObject(message.serverLogs))
                                    return "serverLogs: object expected";
                                let key = Object.keys(message.serverLogs);
                                for (let i = 0; i < key.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.LogFile.verify(message.serverLogs[key[i]]);
                                    if (error)
                                        return "serverLogs." + error;
                                }
                            }
                            if (message.message != null && message.hasOwnProperty("message"))
                                if (!$util.isString(message.message))
                                    return "message: string expected";
                            return null;
                        };

                        /**
                         * Creates an ExecuteResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ExecuteResponse} ExecuteResponse
                         */
                        ExecuteResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ExecuteResponse)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ExecuteResponse();
                            if (object.result != null) {
                                if (typeof object.result !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteResponse.result: object expected");
                                message.result = $root.build.bazel.remote.execution.v2.ActionResult.fromObject(object.result);
                            }
                            if (object.cachedResult != null)
                                message.cachedResult = Boolean(object.cachedResult);
                            if (object.status != null) {
                                if (typeof object.status !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteResponse.status: object expected");
                                message.status = $root.google.rpc.Status.fromObject(object.status);
                            }
                            if (object.serverLogs) {
                                if (typeof object.serverLogs !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteResponse.serverLogs: object expected");
                                message.serverLogs = {};
                                for (let keys = Object.keys(object.serverLogs), i = 0; i < keys.length; ++i) {
                                    if (typeof object.serverLogs[keys[i]] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.ExecuteResponse.serverLogs: object expected");
                                    message.serverLogs[keys[i]] = $root.build.bazel.remote.execution.v2.LogFile.fromObject(object.serverLogs[keys[i]]);
                                }
                            }
                            if (object.message != null)
                                message.message = String(object.message);
                            return message;
                        };

                        /**
                         * Creates a plain object from an ExecuteResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.ExecuteResponse} message ExecuteResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ExecuteResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.objects || options.defaults)
                                object.serverLogs = {};
                            if (options.defaults) {
                                object.result = null;
                                object.cachedResult = false;
                                object.status = null;
                                object.message = "";
                            }
                            if (message.result != null && message.hasOwnProperty("result"))
                                object.result = $root.build.bazel.remote.execution.v2.ActionResult.toObject(message.result, options);
                            if (message.cachedResult != null && message.hasOwnProperty("cachedResult"))
                                object.cachedResult = message.cachedResult;
                            if (message.status != null && message.hasOwnProperty("status"))
                                object.status = $root.google.rpc.Status.toObject(message.status, options);
                            let keys2;
                            if (message.serverLogs && (keys2 = Object.keys(message.serverLogs)).length) {
                                object.serverLogs = {};
                                for (let j = 0; j < keys2.length; ++j)
                                    object.serverLogs[keys2[j]] = $root.build.bazel.remote.execution.v2.LogFile.toObject(message.serverLogs[keys2[j]], options);
                            }
                            if (message.message != null && message.hasOwnProperty("message"))
                                object.message = message.message;
                            return object;
                        };

                        /**
                         * Converts this ExecuteResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ExecuteResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ExecuteResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ExecuteResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ExecuteResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ExecuteResponse";
                        };

                        return ExecuteResponse;
                    })();

                    v2.ExecutionStage = (function() {

                        /**
                         * Properties of an ExecutionStage.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IExecutionStage
                         */

                        /**
                         * Constructs a new ExecutionStage.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ExecutionStage.
                         * @implements IExecutionStage
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IExecutionStage=} [properties] Properties to set
                         */
                        function ExecutionStage(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new ExecutionStage instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionStage=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ExecutionStage} ExecutionStage instance
                         */
                        ExecutionStage.create = function create(properties) {
                            return new ExecutionStage(properties);
                        };

                        /**
                         * Encodes the specified ExecutionStage message. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutionStage.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionStage} message ExecutionStage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutionStage.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified ExecutionStage message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutionStage.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionStage} message ExecutionStage message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutionStage.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ExecutionStage message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ExecutionStage} ExecutionStage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutionStage.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ExecutionStage();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ExecutionStage message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ExecutionStage} ExecutionStage
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutionStage.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ExecutionStage message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ExecutionStage.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates an ExecutionStage message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ExecutionStage} ExecutionStage
                         */
                        ExecutionStage.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ExecutionStage)
                                return object;
                            return new $root.build.bazel.remote.execution.v2.ExecutionStage();
                        };

                        /**
                         * Creates a plain object from an ExecutionStage message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {build.bazel.remote.execution.v2.ExecutionStage} message ExecutionStage
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ExecutionStage.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this ExecutionStage to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ExecutionStage.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ExecutionStage
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ExecutionStage
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ExecutionStage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ExecutionStage";
                        };

                        /**
                         * Value enum.
                         * @name build.bazel.remote.execution.v2.ExecutionStage.Value
                         * @enum {number}
                         * @property {number} UNKNOWN=0 UNKNOWN value
                         * @property {number} CACHE_CHECK=1 CACHE_CHECK value
                         * @property {number} QUEUED=2 QUEUED value
                         * @property {number} EXECUTING=3 EXECUTING value
                         * @property {number} COMPLETED=4 COMPLETED value
                         */
                        ExecutionStage.Value = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNKNOWN"] = 0;
                            values[valuesById[1] = "CACHE_CHECK"] = 1;
                            values[valuesById[2] = "QUEUED"] = 2;
                            values[valuesById[3] = "EXECUTING"] = 3;
                            values[valuesById[4] = "COMPLETED"] = 4;
                            return values;
                        })();

                        return ExecutionStage;
                    })();

                    v2.ExecuteOperationMetadata = (function() {

                        /**
                         * Properties of an ExecuteOperationMetadata.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IExecuteOperationMetadata
                         * @property {build.bazel.remote.execution.v2.ExecutionStage.Value|null} [stage] ExecuteOperationMetadata stage
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [actionDigest] ExecuteOperationMetadata actionDigest
                         * @property {string|null} [stdoutStreamName] ExecuteOperationMetadata stdoutStreamName
                         * @property {string|null} [stderrStreamName] ExecuteOperationMetadata stderrStreamName
                         * @property {build.bazel.remote.execution.v2.IExecutedActionMetadata|null} [partialExecutionMetadata] ExecuteOperationMetadata partialExecutionMetadata
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] ExecuteOperationMetadata digestFunction
                         */

                        /**
                         * Constructs a new ExecuteOperationMetadata.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ExecuteOperationMetadata.
                         * @implements IExecuteOperationMetadata
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IExecuteOperationMetadata=} [properties] Properties to set
                         */
                        function ExecuteOperationMetadata(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ExecuteOperationMetadata stage.
                         * @member {build.bazel.remote.execution.v2.ExecutionStage.Value} stage
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @instance
                         */
                        ExecuteOperationMetadata.prototype.stage = 0;

                        /**
                         * ExecuteOperationMetadata actionDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} actionDigest
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @instance
                         */
                        ExecuteOperationMetadata.prototype.actionDigest = null;

                        /**
                         * ExecuteOperationMetadata stdoutStreamName.
                         * @member {string} stdoutStreamName
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @instance
                         */
                        ExecuteOperationMetadata.prototype.stdoutStreamName = "";

                        /**
                         * ExecuteOperationMetadata stderrStreamName.
                         * @member {string} stderrStreamName
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @instance
                         */
                        ExecuteOperationMetadata.prototype.stderrStreamName = "";

                        /**
                         * ExecuteOperationMetadata partialExecutionMetadata.
                         * @member {build.bazel.remote.execution.v2.IExecutedActionMetadata|null|undefined} partialExecutionMetadata
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @instance
                         */
                        ExecuteOperationMetadata.prototype.partialExecutionMetadata = null;

                        /**
                         * ExecuteOperationMetadata digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @instance
                         */
                        ExecuteOperationMetadata.prototype.digestFunction = 0;

                        /**
                         * Creates a new ExecuteOperationMetadata instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteOperationMetadata=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ExecuteOperationMetadata} ExecuteOperationMetadata instance
                         */
                        ExecuteOperationMetadata.create = function create(properties) {
                            return new ExecuteOperationMetadata(properties);
                        };

                        /**
                         * Encodes the specified ExecuteOperationMetadata message. Does not implicitly {@link build.bazel.remote.execution.v2.ExecuteOperationMetadata.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteOperationMetadata} message ExecuteOperationMetadata message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecuteOperationMetadata.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stage);
                            if (message.actionDigest != null && Object.hasOwnProperty.call(message, "actionDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.actionDigest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.stdoutStreamName != null && Object.hasOwnProperty.call(message, "stdoutStreamName"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stdoutStreamName);
                            if (message.stderrStreamName != null && Object.hasOwnProperty.call(message, "stderrStreamName"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.stderrStreamName);
                            if (message.partialExecutionMetadata != null && Object.hasOwnProperty.call(message, "partialExecutionMetadata"))
                                $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.encode(message.partialExecutionMetadata, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified ExecuteOperationMetadata message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ExecuteOperationMetadata.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecuteOperationMetadata} message ExecuteOperationMetadata message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecuteOperationMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ExecuteOperationMetadata message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ExecuteOperationMetadata} ExecuteOperationMetadata
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecuteOperationMetadata.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ExecuteOperationMetadata();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.stage = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.stdoutStreamName = reader.string();
                                        break;
                                    }
                                case 4: {
                                        message.stderrStreamName = reader.string();
                                        break;
                                    }
                                case 5: {
                                        message.partialExecutionMetadata = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ExecuteOperationMetadata message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ExecuteOperationMetadata} ExecuteOperationMetadata
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecuteOperationMetadata.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ExecuteOperationMetadata message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ExecuteOperationMetadata.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.stage != null && message.hasOwnProperty("stage"))
                                switch (message.stage) {
                                default:
                                    return "stage: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.actionDigest);
                                if (error)
                                    return "actionDigest." + error;
                            }
                            if (message.stdoutStreamName != null && message.hasOwnProperty("stdoutStreamName"))
                                if (!$util.isString(message.stdoutStreamName))
                                    return "stdoutStreamName: string expected";
                            if (message.stderrStreamName != null && message.hasOwnProperty("stderrStreamName"))
                                if (!$util.isString(message.stderrStreamName))
                                    return "stderrStreamName: string expected";
                            if (message.partialExecutionMetadata != null && message.hasOwnProperty("partialExecutionMetadata")) {
                                let error = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.verify(message.partialExecutionMetadata);
                                if (error)
                                    return "partialExecutionMetadata." + error;
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates an ExecuteOperationMetadata message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ExecuteOperationMetadata} ExecuteOperationMetadata
                         */
                        ExecuteOperationMetadata.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ExecuteOperationMetadata)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ExecuteOperationMetadata();
                            switch (object.stage) {
                            default:
                                if (typeof object.stage === "number") {
                                    message.stage = object.stage;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.stage = 0;
                                break;
                            case "CACHE_CHECK":
                            case 1:
                                message.stage = 1;
                                break;
                            case "QUEUED":
                            case 2:
                                message.stage = 2;
                                break;
                            case "EXECUTING":
                            case 3:
                                message.stage = 3;
                                break;
                            case "COMPLETED":
                            case 4:
                                message.stage = 4;
                                break;
                            }
                            if (object.actionDigest != null) {
                                if (typeof object.actionDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteOperationMetadata.actionDigest: object expected");
                                message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.actionDigest);
                            }
                            if (object.stdoutStreamName != null)
                                message.stdoutStreamName = String(object.stdoutStreamName);
                            if (object.stderrStreamName != null)
                                message.stderrStreamName = String(object.stderrStreamName);
                            if (object.partialExecutionMetadata != null) {
                                if (typeof object.partialExecutionMetadata !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecuteOperationMetadata.partialExecutionMetadata: object expected");
                                message.partialExecutionMetadata = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.fromObject(object.partialExecutionMetadata);
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an ExecuteOperationMetadata message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.ExecuteOperationMetadata} message ExecuteOperationMetadata
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ExecuteOperationMetadata.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.stage = options.enums === String ? "UNKNOWN" : 0;
                                object.actionDigest = null;
                                object.stdoutStreamName = "";
                                object.stderrStreamName = "";
                                object.partialExecutionMetadata = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.stage != null && message.hasOwnProperty("stage"))
                                object.stage = options.enums === String ? $root.build.bazel.remote.execution.v2.ExecutionStage.Value[message.stage] === undefined ? message.stage : $root.build.bazel.remote.execution.v2.ExecutionStage.Value[message.stage] : message.stage;
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest"))
                                object.actionDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.actionDigest, options);
                            if (message.stdoutStreamName != null && message.hasOwnProperty("stdoutStreamName"))
                                object.stdoutStreamName = message.stdoutStreamName;
                            if (message.stderrStreamName != null && message.hasOwnProperty("stderrStreamName"))
                                object.stderrStreamName = message.stderrStreamName;
                            if (message.partialExecutionMetadata != null && message.hasOwnProperty("partialExecutionMetadata"))
                                object.partialExecutionMetadata = $root.build.bazel.remote.execution.v2.ExecutedActionMetadata.toObject(message.partialExecutionMetadata, options);
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this ExecuteOperationMetadata to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ExecuteOperationMetadata.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ExecuteOperationMetadata
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ExecuteOperationMetadata
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ExecuteOperationMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ExecuteOperationMetadata";
                        };

                        return ExecuteOperationMetadata;
                    })();

                    v2.WaitExecutionRequest = (function() {

                        /**
                         * Properties of a WaitExecutionRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IWaitExecutionRequest
                         * @property {string|null} [name] WaitExecutionRequest name
                         */

                        /**
                         * Constructs a new WaitExecutionRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a WaitExecutionRequest.
                         * @implements IWaitExecutionRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IWaitExecutionRequest=} [properties] Properties to set
                         */
                        function WaitExecutionRequest(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * WaitExecutionRequest name.
                         * @member {string} name
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @instance
                         */
                        WaitExecutionRequest.prototype.name = "";

                        /**
                         * Creates a new WaitExecutionRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IWaitExecutionRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.WaitExecutionRequest} WaitExecutionRequest instance
                         */
                        WaitExecutionRequest.create = function create(properties) {
                            return new WaitExecutionRequest(properties);
                        };

                        /**
                         * Encodes the specified WaitExecutionRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.WaitExecutionRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IWaitExecutionRequest} message WaitExecutionRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        WaitExecutionRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            return writer;
                        };

                        /**
                         * Encodes the specified WaitExecutionRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.WaitExecutionRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IWaitExecutionRequest} message WaitExecutionRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        WaitExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a WaitExecutionRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.WaitExecutionRequest} WaitExecutionRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        WaitExecutionRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.WaitExecutionRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.name = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a WaitExecutionRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.WaitExecutionRequest} WaitExecutionRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        WaitExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a WaitExecutionRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        WaitExecutionRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            return null;
                        };

                        /**
                         * Creates a WaitExecutionRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.WaitExecutionRequest} WaitExecutionRequest
                         */
                        WaitExecutionRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.WaitExecutionRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.WaitExecutionRequest();
                            if (object.name != null)
                                message.name = String(object.name);
                            return message;
                        };

                        /**
                         * Creates a plain object from a WaitExecutionRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.WaitExecutionRequest} message WaitExecutionRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        WaitExecutionRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.name = "";
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            return object;
                        };

                        /**
                         * Converts this WaitExecutionRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        WaitExecutionRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for WaitExecutionRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.WaitExecutionRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        WaitExecutionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.WaitExecutionRequest";
                        };

                        return WaitExecutionRequest;
                    })();

                    v2.GetActionResultRequest = (function() {

                        /**
                         * Properties of a GetActionResultRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IGetActionResultRequest
                         * @property {string|null} [instanceName] GetActionResultRequest instanceName
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [actionDigest] GetActionResultRequest actionDigest
                         * @property {boolean|null} [inlineStdout] GetActionResultRequest inlineStdout
                         * @property {boolean|null} [inlineStderr] GetActionResultRequest inlineStderr
                         * @property {Array.<string>|null} [inlineOutputFiles] GetActionResultRequest inlineOutputFiles
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] GetActionResultRequest digestFunction
                         */

                        /**
                         * Constructs a new GetActionResultRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a GetActionResultRequest.
                         * @implements IGetActionResultRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IGetActionResultRequest=} [properties] Properties to set
                         */
                        function GetActionResultRequest(properties) {
                            this.inlineOutputFiles = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GetActionResultRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @instance
                         */
                        GetActionResultRequest.prototype.instanceName = "";

                        /**
                         * GetActionResultRequest actionDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} actionDigest
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @instance
                         */
                        GetActionResultRequest.prototype.actionDigest = null;

                        /**
                         * GetActionResultRequest inlineStdout.
                         * @member {boolean} inlineStdout
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @instance
                         */
                        GetActionResultRequest.prototype.inlineStdout = false;

                        /**
                         * GetActionResultRequest inlineStderr.
                         * @member {boolean} inlineStderr
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @instance
                         */
                        GetActionResultRequest.prototype.inlineStderr = false;

                        /**
                         * GetActionResultRequest inlineOutputFiles.
                         * @member {Array.<string>} inlineOutputFiles
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @instance
                         */
                        GetActionResultRequest.prototype.inlineOutputFiles = $util.emptyArray;

                        /**
                         * GetActionResultRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @instance
                         */
                        GetActionResultRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new GetActionResultRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetActionResultRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.GetActionResultRequest} GetActionResultRequest instance
                         */
                        GetActionResultRequest.create = function create(properties) {
                            return new GetActionResultRequest(properties);
                        };

                        /**
                         * Encodes the specified GetActionResultRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.GetActionResultRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetActionResultRequest} message GetActionResultRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetActionResultRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.actionDigest != null && Object.hasOwnProperty.call(message, "actionDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.actionDigest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.inlineStdout != null && Object.hasOwnProperty.call(message, "inlineStdout"))
                                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.inlineStdout);
                            if (message.inlineStderr != null && Object.hasOwnProperty.call(message, "inlineStderr"))
                                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.inlineStderr);
                            if (message.inlineOutputFiles != null && message.inlineOutputFiles.length)
                                for (let i = 0; i < message.inlineOutputFiles.length; ++i)
                                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.inlineOutputFiles[i]);
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified GetActionResultRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.GetActionResultRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetActionResultRequest} message GetActionResultRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetActionResultRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GetActionResultRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.GetActionResultRequest} GetActionResultRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetActionResultRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.GetActionResultRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.inlineStdout = reader.bool();
                                        break;
                                    }
                                case 4: {
                                        message.inlineStderr = reader.bool();
                                        break;
                                    }
                                case 5: {
                                        if (!(message.inlineOutputFiles && message.inlineOutputFiles.length))
                                            message.inlineOutputFiles = [];
                                        message.inlineOutputFiles.push(reader.string());
                                        break;
                                    }
                                case 6: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GetActionResultRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.GetActionResultRequest} GetActionResultRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetActionResultRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GetActionResultRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GetActionResultRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.actionDigest);
                                if (error)
                                    return "actionDigest." + error;
                            }
                            if (message.inlineStdout != null && message.hasOwnProperty("inlineStdout"))
                                if (typeof message.inlineStdout !== "boolean")
                                    return "inlineStdout: boolean expected";
                            if (message.inlineStderr != null && message.hasOwnProperty("inlineStderr"))
                                if (typeof message.inlineStderr !== "boolean")
                                    return "inlineStderr: boolean expected";
                            if (message.inlineOutputFiles != null && message.hasOwnProperty("inlineOutputFiles")) {
                                if (!Array.isArray(message.inlineOutputFiles))
                                    return "inlineOutputFiles: array expected";
                                for (let i = 0; i < message.inlineOutputFiles.length; ++i)
                                    if (!$util.isString(message.inlineOutputFiles[i]))
                                        return "inlineOutputFiles: string[] expected";
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a GetActionResultRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.GetActionResultRequest} GetActionResultRequest
                         */
                        GetActionResultRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.GetActionResultRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.GetActionResultRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.actionDigest != null) {
                                if (typeof object.actionDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.GetActionResultRequest.actionDigest: object expected");
                                message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.actionDigest);
                            }
                            if (object.inlineStdout != null)
                                message.inlineStdout = Boolean(object.inlineStdout);
                            if (object.inlineStderr != null)
                                message.inlineStderr = Boolean(object.inlineStderr);
                            if (object.inlineOutputFiles) {
                                if (!Array.isArray(object.inlineOutputFiles))
                                    throw TypeError(".build.bazel.remote.execution.v2.GetActionResultRequest.inlineOutputFiles: array expected");
                                message.inlineOutputFiles = [];
                                for (let i = 0; i < object.inlineOutputFiles.length; ++i)
                                    message.inlineOutputFiles[i] = String(object.inlineOutputFiles[i]);
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a GetActionResultRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.GetActionResultRequest} message GetActionResultRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GetActionResultRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.inlineOutputFiles = [];
                            if (options.defaults) {
                                object.instanceName = "";
                                object.actionDigest = null;
                                object.inlineStdout = false;
                                object.inlineStderr = false;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest"))
                                object.actionDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.actionDigest, options);
                            if (message.inlineStdout != null && message.hasOwnProperty("inlineStdout"))
                                object.inlineStdout = message.inlineStdout;
                            if (message.inlineStderr != null && message.hasOwnProperty("inlineStderr"))
                                object.inlineStderr = message.inlineStderr;
                            if (message.inlineOutputFiles && message.inlineOutputFiles.length) {
                                object.inlineOutputFiles = [];
                                for (let j = 0; j < message.inlineOutputFiles.length; ++j)
                                    object.inlineOutputFiles[j] = message.inlineOutputFiles[j];
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this GetActionResultRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GetActionResultRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for GetActionResultRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.GetActionResultRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        GetActionResultRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.GetActionResultRequest";
                        };

                        return GetActionResultRequest;
                    })();

                    v2.UpdateActionResultRequest = (function() {

                        /**
                         * Properties of an UpdateActionResultRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IUpdateActionResultRequest
                         * @property {string|null} [instanceName] UpdateActionResultRequest instanceName
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [actionDigest] UpdateActionResultRequest actionDigest
                         * @property {build.bazel.remote.execution.v2.IActionResult|null} [actionResult] UpdateActionResultRequest actionResult
                         * @property {build.bazel.remote.execution.v2.IResultsCachePolicy|null} [resultsCachePolicy] UpdateActionResultRequest resultsCachePolicy
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] UpdateActionResultRequest digestFunction
                         */

                        /**
                         * Constructs a new UpdateActionResultRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an UpdateActionResultRequest.
                         * @implements IUpdateActionResultRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IUpdateActionResultRequest=} [properties] Properties to set
                         */
                        function UpdateActionResultRequest(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * UpdateActionResultRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @instance
                         */
                        UpdateActionResultRequest.prototype.instanceName = "";

                        /**
                         * UpdateActionResultRequest actionDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} actionDigest
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @instance
                         */
                        UpdateActionResultRequest.prototype.actionDigest = null;

                        /**
                         * UpdateActionResultRequest actionResult.
                         * @member {build.bazel.remote.execution.v2.IActionResult|null|undefined} actionResult
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @instance
                         */
                        UpdateActionResultRequest.prototype.actionResult = null;

                        /**
                         * UpdateActionResultRequest resultsCachePolicy.
                         * @member {build.bazel.remote.execution.v2.IResultsCachePolicy|null|undefined} resultsCachePolicy
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @instance
                         */
                        UpdateActionResultRequest.prototype.resultsCachePolicy = null;

                        /**
                         * UpdateActionResultRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @instance
                         */
                        UpdateActionResultRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new UpdateActionResultRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IUpdateActionResultRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.UpdateActionResultRequest} UpdateActionResultRequest instance
                         */
                        UpdateActionResultRequest.create = function create(properties) {
                            return new UpdateActionResultRequest(properties);
                        };

                        /**
                         * Encodes the specified UpdateActionResultRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.UpdateActionResultRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IUpdateActionResultRequest} message UpdateActionResultRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        UpdateActionResultRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.actionDigest != null && Object.hasOwnProperty.call(message, "actionDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.actionDigest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.actionResult != null && Object.hasOwnProperty.call(message, "actionResult"))
                                $root.build.bazel.remote.execution.v2.ActionResult.encode(message.actionResult, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.resultsCachePolicy != null && Object.hasOwnProperty.call(message, "resultsCachePolicy"))
                                $root.build.bazel.remote.execution.v2.ResultsCachePolicy.encode(message.resultsCachePolicy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified UpdateActionResultRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.UpdateActionResultRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IUpdateActionResultRequest} message UpdateActionResultRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        UpdateActionResultRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an UpdateActionResultRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.UpdateActionResultRequest} UpdateActionResultRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        UpdateActionResultRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.UpdateActionResultRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.actionResult = $root.build.bazel.remote.execution.v2.ActionResult.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.resultsCachePolicy = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 5: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an UpdateActionResultRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.UpdateActionResultRequest} UpdateActionResultRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        UpdateActionResultRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an UpdateActionResultRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        UpdateActionResultRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.actionDigest);
                                if (error)
                                    return "actionDigest." + error;
                            }
                            if (message.actionResult != null && message.hasOwnProperty("actionResult")) {
                                let error = $root.build.bazel.remote.execution.v2.ActionResult.verify(message.actionResult);
                                if (error)
                                    return "actionResult." + error;
                            }
                            if (message.resultsCachePolicy != null && message.hasOwnProperty("resultsCachePolicy")) {
                                let error = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.verify(message.resultsCachePolicy);
                                if (error)
                                    return "resultsCachePolicy." + error;
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates an UpdateActionResultRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.UpdateActionResultRequest} UpdateActionResultRequest
                         */
                        UpdateActionResultRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.UpdateActionResultRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.UpdateActionResultRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.actionDigest != null) {
                                if (typeof object.actionDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.UpdateActionResultRequest.actionDigest: object expected");
                                message.actionDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.actionDigest);
                            }
                            if (object.actionResult != null) {
                                if (typeof object.actionResult !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.UpdateActionResultRequest.actionResult: object expected");
                                message.actionResult = $root.build.bazel.remote.execution.v2.ActionResult.fromObject(object.actionResult);
                            }
                            if (object.resultsCachePolicy != null) {
                                if (typeof object.resultsCachePolicy !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.UpdateActionResultRequest.resultsCachePolicy: object expected");
                                message.resultsCachePolicy = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.fromObject(object.resultsCachePolicy);
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an UpdateActionResultRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.UpdateActionResultRequest} message UpdateActionResultRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        UpdateActionResultRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.instanceName = "";
                                object.actionDigest = null;
                                object.actionResult = null;
                                object.resultsCachePolicy = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.actionDigest != null && message.hasOwnProperty("actionDigest"))
                                object.actionDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.actionDigest, options);
                            if (message.actionResult != null && message.hasOwnProperty("actionResult"))
                                object.actionResult = $root.build.bazel.remote.execution.v2.ActionResult.toObject(message.actionResult, options);
                            if (message.resultsCachePolicy != null && message.hasOwnProperty("resultsCachePolicy"))
                                object.resultsCachePolicy = $root.build.bazel.remote.execution.v2.ResultsCachePolicy.toObject(message.resultsCachePolicy, options);
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this UpdateActionResultRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        UpdateActionResultRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for UpdateActionResultRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.UpdateActionResultRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        UpdateActionResultRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.UpdateActionResultRequest";
                        };

                        return UpdateActionResultRequest;
                    })();

                    v2.FindMissingBlobsRequest = (function() {

                        /**
                         * Properties of a FindMissingBlobsRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IFindMissingBlobsRequest
                         * @property {string|null} [instanceName] FindMissingBlobsRequest instanceName
                         * @property {Array.<build.bazel.remote.execution.v2.IDigest>|null} [blobDigests] FindMissingBlobsRequest blobDigests
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] FindMissingBlobsRequest digestFunction
                         */

                        /**
                         * Constructs a new FindMissingBlobsRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a FindMissingBlobsRequest.
                         * @implements IFindMissingBlobsRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsRequest=} [properties] Properties to set
                         */
                        function FindMissingBlobsRequest(properties) {
                            this.blobDigests = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FindMissingBlobsRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @instance
                         */
                        FindMissingBlobsRequest.prototype.instanceName = "";

                        /**
                         * FindMissingBlobsRequest blobDigests.
                         * @member {Array.<build.bazel.remote.execution.v2.IDigest>} blobDigests
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @instance
                         */
                        FindMissingBlobsRequest.prototype.blobDigests = $util.emptyArray;

                        /**
                         * FindMissingBlobsRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @instance
                         */
                        FindMissingBlobsRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new FindMissingBlobsRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsRequest} FindMissingBlobsRequest instance
                         */
                        FindMissingBlobsRequest.create = function create(properties) {
                            return new FindMissingBlobsRequest(properties);
                        };

                        /**
                         * Encodes the specified FindMissingBlobsRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.FindMissingBlobsRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsRequest} message FindMissingBlobsRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FindMissingBlobsRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.blobDigests != null && message.blobDigests.length)
                                for (let i = 0; i < message.blobDigests.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.blobDigests[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified FindMissingBlobsRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.FindMissingBlobsRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsRequest} message FindMissingBlobsRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FindMissingBlobsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FindMissingBlobsRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsRequest} FindMissingBlobsRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FindMissingBlobsRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.FindMissingBlobsRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        if (!(message.blobDigests && message.blobDigests.length))
                                            message.blobDigests = [];
                                        message.blobDigests.push($root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 3: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FindMissingBlobsRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsRequest} FindMissingBlobsRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FindMissingBlobsRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FindMissingBlobsRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FindMissingBlobsRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.blobDigests != null && message.hasOwnProperty("blobDigests")) {
                                if (!Array.isArray(message.blobDigests))
                                    return "blobDigests: array expected";
                                for (let i = 0; i < message.blobDigests.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.blobDigests[i]);
                                    if (error)
                                        return "blobDigests." + error;
                                }
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a FindMissingBlobsRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsRequest} FindMissingBlobsRequest
                         */
                        FindMissingBlobsRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.FindMissingBlobsRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.FindMissingBlobsRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.blobDigests) {
                                if (!Array.isArray(object.blobDigests))
                                    throw TypeError(".build.bazel.remote.execution.v2.FindMissingBlobsRequest.blobDigests: array expected");
                                message.blobDigests = [];
                                for (let i = 0; i < object.blobDigests.length; ++i) {
                                    if (typeof object.blobDigests[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.FindMissingBlobsRequest.blobDigests: object expected");
                                    message.blobDigests[i] = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.blobDigests[i]);
                                }
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FindMissingBlobsRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.FindMissingBlobsRequest} message FindMissingBlobsRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FindMissingBlobsRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.blobDigests = [];
                            if (options.defaults) {
                                object.instanceName = "";
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.blobDigests && message.blobDigests.length) {
                                object.blobDigests = [];
                                for (let j = 0; j < message.blobDigests.length; ++j)
                                    object.blobDigests[j] = $root.build.bazel.remote.execution.v2.Digest.toObject(message.blobDigests[j], options);
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this FindMissingBlobsRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FindMissingBlobsRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FindMissingBlobsRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FindMissingBlobsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.FindMissingBlobsRequest";
                        };

                        return FindMissingBlobsRequest;
                    })();

                    v2.FindMissingBlobsResponse = (function() {

                        /**
                         * Properties of a FindMissingBlobsResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IFindMissingBlobsResponse
                         * @property {Array.<build.bazel.remote.execution.v2.IDigest>|null} [missingBlobDigests] FindMissingBlobsResponse missingBlobDigests
                         */

                        /**
                         * Constructs a new FindMissingBlobsResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a FindMissingBlobsResponse.
                         * @implements IFindMissingBlobsResponse
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsResponse=} [properties] Properties to set
                         */
                        function FindMissingBlobsResponse(properties) {
                            this.missingBlobDigests = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FindMissingBlobsResponse missingBlobDigests.
                         * @member {Array.<build.bazel.remote.execution.v2.IDigest>} missingBlobDigests
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @instance
                         */
                        FindMissingBlobsResponse.prototype.missingBlobDigests = $util.emptyArray;

                        /**
                         * Creates a new FindMissingBlobsResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsResponse} FindMissingBlobsResponse instance
                         */
                        FindMissingBlobsResponse.create = function create(properties) {
                            return new FindMissingBlobsResponse(properties);
                        };

                        /**
                         * Encodes the specified FindMissingBlobsResponse message. Does not implicitly {@link build.bazel.remote.execution.v2.FindMissingBlobsResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsResponse} message FindMissingBlobsResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FindMissingBlobsResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.missingBlobDigests != null && message.missingBlobDigests.length)
                                for (let i = 0; i < message.missingBlobDigests.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.missingBlobDigests[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified FindMissingBlobsResponse message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.FindMissingBlobsResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IFindMissingBlobsResponse} message FindMissingBlobsResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FindMissingBlobsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FindMissingBlobsResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsResponse} FindMissingBlobsResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FindMissingBlobsResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.FindMissingBlobsResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 2: {
                                        if (!(message.missingBlobDigests && message.missingBlobDigests.length))
                                            message.missingBlobDigests = [];
                                        message.missingBlobDigests.push($root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FindMissingBlobsResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsResponse} FindMissingBlobsResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FindMissingBlobsResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FindMissingBlobsResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FindMissingBlobsResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.missingBlobDigests != null && message.hasOwnProperty("missingBlobDigests")) {
                                if (!Array.isArray(message.missingBlobDigests))
                                    return "missingBlobDigests: array expected";
                                for (let i = 0; i < message.missingBlobDigests.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.missingBlobDigests[i]);
                                    if (error)
                                        return "missingBlobDigests." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a FindMissingBlobsResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.FindMissingBlobsResponse} FindMissingBlobsResponse
                         */
                        FindMissingBlobsResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.FindMissingBlobsResponse)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.FindMissingBlobsResponse();
                            if (object.missingBlobDigests) {
                                if (!Array.isArray(object.missingBlobDigests))
                                    throw TypeError(".build.bazel.remote.execution.v2.FindMissingBlobsResponse.missingBlobDigests: array expected");
                                message.missingBlobDigests = [];
                                for (let i = 0; i < object.missingBlobDigests.length; ++i) {
                                    if (typeof object.missingBlobDigests[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.FindMissingBlobsResponse.missingBlobDigests: object expected");
                                    message.missingBlobDigests[i] = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.missingBlobDigests[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FindMissingBlobsResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.FindMissingBlobsResponse} message FindMissingBlobsResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FindMissingBlobsResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.missingBlobDigests = [];
                            if (message.missingBlobDigests && message.missingBlobDigests.length) {
                                object.missingBlobDigests = [];
                                for (let j = 0; j < message.missingBlobDigests.length; ++j)
                                    object.missingBlobDigests[j] = $root.build.bazel.remote.execution.v2.Digest.toObject(message.missingBlobDigests[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this FindMissingBlobsResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FindMissingBlobsResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FindMissingBlobsResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.FindMissingBlobsResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FindMissingBlobsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.FindMissingBlobsResponse";
                        };

                        return FindMissingBlobsResponse;
                    })();

                    v2.BatchUpdateBlobsRequest = (function() {

                        /**
                         * Properties of a BatchUpdateBlobsRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IBatchUpdateBlobsRequest
                         * @property {string|null} [instanceName] BatchUpdateBlobsRequest instanceName
                         * @property {Array.<build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.IRequest>|null} [requests] BatchUpdateBlobsRequest requests
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] BatchUpdateBlobsRequest digestFunction
                         */

                        /**
                         * Constructs a new BatchUpdateBlobsRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a BatchUpdateBlobsRequest.
                         * @implements IBatchUpdateBlobsRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsRequest=} [properties] Properties to set
                         */
                        function BatchUpdateBlobsRequest(properties) {
                            this.requests = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * BatchUpdateBlobsRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @instance
                         */
                        BatchUpdateBlobsRequest.prototype.instanceName = "";

                        /**
                         * BatchUpdateBlobsRequest requests.
                         * @member {Array.<build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.IRequest>} requests
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @instance
                         */
                        BatchUpdateBlobsRequest.prototype.requests = $util.emptyArray;

                        /**
                         * BatchUpdateBlobsRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @instance
                         */
                        BatchUpdateBlobsRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new BatchUpdateBlobsRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest} BatchUpdateBlobsRequest instance
                         */
                        BatchUpdateBlobsRequest.create = function create(properties) {
                            return new BatchUpdateBlobsRequest(properties);
                        };

                        /**
                         * Encodes the specified BatchUpdateBlobsRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsRequest} message BatchUpdateBlobsRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchUpdateBlobsRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.requests != null && message.requests.length)
                                for (let i = 0; i < message.requests.length; ++i)
                                    $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.encode(message.requests[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified BatchUpdateBlobsRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsRequest} message BatchUpdateBlobsRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchUpdateBlobsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a BatchUpdateBlobsRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest} BatchUpdateBlobsRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchUpdateBlobsRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        if (!(message.requests && message.requests.length))
                                            message.requests = [];
                                        message.requests.push($root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 5: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a BatchUpdateBlobsRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest} BatchUpdateBlobsRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchUpdateBlobsRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a BatchUpdateBlobsRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BatchUpdateBlobsRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.requests != null && message.hasOwnProperty("requests")) {
                                if (!Array.isArray(message.requests))
                                    return "requests: array expected";
                                for (let i = 0; i < message.requests.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.verify(message.requests[i]);
                                    if (error)
                                        return "requests." + error;
                                }
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a BatchUpdateBlobsRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest} BatchUpdateBlobsRequest
                         */
                        BatchUpdateBlobsRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.requests) {
                                if (!Array.isArray(object.requests))
                                    throw TypeError(".build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.requests: array expected");
                                message.requests = [];
                                for (let i = 0; i < object.requests.length; ++i) {
                                    if (typeof object.requests[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.requests: object expected");
                                    message.requests[i] = $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.fromObject(object.requests[i]);
                                }
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a BatchUpdateBlobsRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest} message BatchUpdateBlobsRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BatchUpdateBlobsRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.requests = [];
                            if (options.defaults) {
                                object.instanceName = "";
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.requests && message.requests.length) {
                                object.requests = [];
                                for (let j = 0; j < message.requests.length; ++j)
                                    object.requests[j] = $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.toObject(message.requests[j], options);
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this BatchUpdateBlobsRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BatchUpdateBlobsRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for BatchUpdateBlobsRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        BatchUpdateBlobsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.BatchUpdateBlobsRequest";
                        };

                        BatchUpdateBlobsRequest.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                             * @interface IRequest
                             * @property {build.bazel.remote.execution.v2.IDigest|null} [digest] Request digest
                             * @property {Uint8Array|null} [data] Request data
                             * @property {build.bazel.remote.execution.v2.Compressor.Value|null} [compressor] Request compressor
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request digest.
                             * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} digest
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @instance
                             */
                            Request.prototype.digest = null;

                            /**
                             * Request data.
                             * @member {Uint8Array} data
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @instance
                             */
                            Request.prototype.data = $util.newBuffer([]);

                            /**
                             * Request compressor.
                             * @member {build.bazel.remote.execution.v2.Compressor.Value} compressor
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @instance
                             */
                            Request.prototype.compressor = 0;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.IRequest=} [properties] Properties to set
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.verify|verify} messages.
                             * @function encode
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.digest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                                if (message.compressor != null && Object.hasOwnProperty.call(message, "compressor"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.compressor);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.digest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 2: {
                                            message.data = reader.bytes();
                                            break;
                                        }
                                    case 3: {
                                            message.compressor = reader.int32();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.digest != null && message.hasOwnProperty("digest")) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digest);
                                    if (error)
                                        return "digest." + error;
                                }
                                if (message.data != null && message.hasOwnProperty("data"))
                                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                        return "data: buffer expected";
                                if (message.compressor != null && message.hasOwnProperty("compressor"))
                                    switch (message.compressor) {
                                    default:
                                        return "compressor: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                        break;
                                    }
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request)
                                    return object;
                                let message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request();
                                if (object.digest != null) {
                                    if (typeof object.digest !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request.digest: object expected");
                                    message.digest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digest);
                                }
                                if (object.data != null)
                                    if (typeof object.data === "string")
                                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                                    else if (object.data.length >= 0)
                                        message.data = object.data;
                                switch (object.compressor) {
                                default:
                                    if (typeof object.compressor === "number") {
                                        message.compressor = object.compressor;
                                        break;
                                    }
                                    break;
                                case "IDENTITY":
                                case 0:
                                    message.compressor = 0;
                                    break;
                                case "ZSTD":
                                case 1:
                                    message.compressor = 1;
                                    break;
                                case "DEFLATE":
                                case 2:
                                    message.compressor = 2;
                                    break;
                                case "BROTLI":
                                case 3:
                                    message.compressor = 3;
                                    break;
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.digest = null;
                                    if (options.bytes === String)
                                        object.data = "";
                                    else {
                                        object.data = [];
                                        if (options.bytes !== Array)
                                            object.data = $util.newBuffer(object.data);
                                    }
                                    object.compressor = options.enums === String ? "IDENTITY" : 0;
                                }
                                if (message.digest != null && message.hasOwnProperty("digest"))
                                    object.digest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digest, options);
                                if (message.data != null && message.hasOwnProperty("data"))
                                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                                if (message.compressor != null && message.hasOwnProperty("compressor"))
                                    object.compressor = options.enums === String ? $root.build.bazel.remote.execution.v2.Compressor.Value[message.compressor] === undefined ? message.compressor : $root.build.bazel.remote.execution.v2.Compressor.Value[message.compressor] : message.compressor;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for Request
                             * @function getTypeUrl
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/build.bazel.remote.execution.v2.BatchUpdateBlobsRequest.Request";
                            };

                            return Request;
                        })();

                        return BatchUpdateBlobsRequest;
                    })();

                    v2.BatchUpdateBlobsResponse = (function() {

                        /**
                         * Properties of a BatchUpdateBlobsResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IBatchUpdateBlobsResponse
                         * @property {Array.<build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.IResponse>|null} [responses] BatchUpdateBlobsResponse responses
                         */

                        /**
                         * Constructs a new BatchUpdateBlobsResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a BatchUpdateBlobsResponse.
                         * @implements IBatchUpdateBlobsResponse
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsResponse=} [properties] Properties to set
                         */
                        function BatchUpdateBlobsResponse(properties) {
                            this.responses = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * BatchUpdateBlobsResponse responses.
                         * @member {Array.<build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.IResponse>} responses
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @instance
                         */
                        BatchUpdateBlobsResponse.prototype.responses = $util.emptyArray;

                        /**
                         * Creates a new BatchUpdateBlobsResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse} BatchUpdateBlobsResponse instance
                         */
                        BatchUpdateBlobsResponse.create = function create(properties) {
                            return new BatchUpdateBlobsResponse(properties);
                        };

                        /**
                         * Encodes the specified BatchUpdateBlobsResponse message. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsResponse} message BatchUpdateBlobsResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchUpdateBlobsResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.responses != null && message.responses.length)
                                for (let i = 0; i < message.responses.length; ++i)
                                    $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.encode(message.responses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified BatchUpdateBlobsResponse message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchUpdateBlobsResponse} message BatchUpdateBlobsResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchUpdateBlobsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a BatchUpdateBlobsResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse} BatchUpdateBlobsResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchUpdateBlobsResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.responses && message.responses.length))
                                            message.responses = [];
                                        message.responses.push($root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a BatchUpdateBlobsResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse} BatchUpdateBlobsResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchUpdateBlobsResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a BatchUpdateBlobsResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BatchUpdateBlobsResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.responses != null && message.hasOwnProperty("responses")) {
                                if (!Array.isArray(message.responses))
                                    return "responses: array expected";
                                for (let i = 0; i < message.responses.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.verify(message.responses[i]);
                                    if (error)
                                        return "responses." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a BatchUpdateBlobsResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse} BatchUpdateBlobsResponse
                         */
                        BatchUpdateBlobsResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse();
                            if (object.responses) {
                                if (!Array.isArray(object.responses))
                                    throw TypeError(".build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.responses: array expected");
                                message.responses = [];
                                for (let i = 0; i < object.responses.length; ++i) {
                                    if (typeof object.responses[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.responses: object expected");
                                    message.responses[i] = $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.fromObject(object.responses[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a BatchUpdateBlobsResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse} message BatchUpdateBlobsResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BatchUpdateBlobsResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.responses = [];
                            if (message.responses && message.responses.length) {
                                object.responses = [];
                                for (let j = 0; j < message.responses.length; ++j)
                                    object.responses[j] = $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.toObject(message.responses[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this BatchUpdateBlobsResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BatchUpdateBlobsResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for BatchUpdateBlobsResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        BatchUpdateBlobsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.BatchUpdateBlobsResponse";
                        };

                        BatchUpdateBlobsResponse.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                             * @interface IResponse
                             * @property {build.bazel.remote.execution.v2.IDigest|null} [digest] Response digest
                             * @property {google.rpc.IStatus|null} [status] Response status
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response digest.
                             * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} digest
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @instance
                             */
                            Response.prototype.digest = null;

                            /**
                             * Response status.
                             * @member {google.rpc.IStatus|null|undefined} status
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @instance
                             */
                            Response.prototype.status = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.IResponse=} [properties] Properties to set
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.verify|verify} messages.
                             * @function encode
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.digest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                                    $root.google.rpc.Status.encode(message.status, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.digest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 2: {
                                            message.status = $root.google.rpc.Status.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.digest != null && message.hasOwnProperty("digest")) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digest);
                                    if (error)
                                        return "digest." + error;
                                }
                                if (message.status != null && message.hasOwnProperty("status")) {
                                    let error = $root.google.rpc.Status.verify(message.status);
                                    if (error)
                                        return "status." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response)
                                    return object;
                                let message = new $root.build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response();
                                if (object.digest != null) {
                                    if (typeof object.digest !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.digest: object expected");
                                    message.digest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digest);
                                }
                                if (object.status != null) {
                                    if (typeof object.status !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response.status: object expected");
                                    message.status = $root.google.rpc.Status.fromObject(object.status);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.digest = null;
                                    object.status = null;
                                }
                                if (message.digest != null && message.hasOwnProperty("digest"))
                                    object.digest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digest, options);
                                if (message.status != null && message.hasOwnProperty("status"))
                                    object.status = $root.google.rpc.Status.toObject(message.status, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for Response
                             * @function getTypeUrl
                             * @memberof build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/build.bazel.remote.execution.v2.BatchUpdateBlobsResponse.Response";
                            };

                            return Response;
                        })();

                        return BatchUpdateBlobsResponse;
                    })();

                    v2.BatchReadBlobsRequest = (function() {

                        /**
                         * Properties of a BatchReadBlobsRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IBatchReadBlobsRequest
                         * @property {string|null} [instanceName] BatchReadBlobsRequest instanceName
                         * @property {Array.<build.bazel.remote.execution.v2.IDigest>|null} [digests] BatchReadBlobsRequest digests
                         * @property {Array.<build.bazel.remote.execution.v2.Compressor.Value>|null} [acceptableCompressors] BatchReadBlobsRequest acceptableCompressors
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] BatchReadBlobsRequest digestFunction
                         */

                        /**
                         * Constructs a new BatchReadBlobsRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a BatchReadBlobsRequest.
                         * @implements IBatchReadBlobsRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsRequest=} [properties] Properties to set
                         */
                        function BatchReadBlobsRequest(properties) {
                            this.digests = [];
                            this.acceptableCompressors = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * BatchReadBlobsRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @instance
                         */
                        BatchReadBlobsRequest.prototype.instanceName = "";

                        /**
                         * BatchReadBlobsRequest digests.
                         * @member {Array.<build.bazel.remote.execution.v2.IDigest>} digests
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @instance
                         */
                        BatchReadBlobsRequest.prototype.digests = $util.emptyArray;

                        /**
                         * BatchReadBlobsRequest acceptableCompressors.
                         * @member {Array.<build.bazel.remote.execution.v2.Compressor.Value>} acceptableCompressors
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @instance
                         */
                        BatchReadBlobsRequest.prototype.acceptableCompressors = $util.emptyArray;

                        /**
                         * BatchReadBlobsRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @instance
                         */
                        BatchReadBlobsRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new BatchReadBlobsRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsRequest} BatchReadBlobsRequest instance
                         */
                        BatchReadBlobsRequest.create = function create(properties) {
                            return new BatchReadBlobsRequest(properties);
                        };

                        /**
                         * Encodes the specified BatchReadBlobsRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.BatchReadBlobsRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsRequest} message BatchReadBlobsRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchReadBlobsRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.digests != null && message.digests.length)
                                for (let i = 0; i < message.digests.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.digests[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.acceptableCompressors != null && message.acceptableCompressors.length) {
                                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                                for (let i = 0; i < message.acceptableCompressors.length; ++i)
                                    writer.int32(message.acceptableCompressors[i]);
                                writer.ldelim();
                            }
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified BatchReadBlobsRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.BatchReadBlobsRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsRequest} message BatchReadBlobsRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchReadBlobsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a BatchReadBlobsRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsRequest} BatchReadBlobsRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchReadBlobsRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.BatchReadBlobsRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        if (!(message.digests && message.digests.length))
                                            message.digests = [];
                                        message.digests.push($root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 3: {
                                        if (!(message.acceptableCompressors && message.acceptableCompressors.length))
                                            message.acceptableCompressors = [];
                                        if ((tag & 7) === 2) {
                                            let end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.acceptableCompressors.push(reader.int32());
                                        } else
                                            message.acceptableCompressors.push(reader.int32());
                                        break;
                                    }
                                case 4: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a BatchReadBlobsRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsRequest} BatchReadBlobsRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchReadBlobsRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a BatchReadBlobsRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BatchReadBlobsRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.digests != null && message.hasOwnProperty("digests")) {
                                if (!Array.isArray(message.digests))
                                    return "digests: array expected";
                                for (let i = 0; i < message.digests.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digests[i]);
                                    if (error)
                                        return "digests." + error;
                                }
                            }
                            if (message.acceptableCompressors != null && message.hasOwnProperty("acceptableCompressors")) {
                                if (!Array.isArray(message.acceptableCompressors))
                                    return "acceptableCompressors: array expected";
                                for (let i = 0; i < message.acceptableCompressors.length; ++i)
                                    switch (message.acceptableCompressors[i]) {
                                    default:
                                        return "acceptableCompressors: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                        break;
                                    }
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a BatchReadBlobsRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsRequest} BatchReadBlobsRequest
                         */
                        BatchReadBlobsRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.BatchReadBlobsRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.BatchReadBlobsRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.digests) {
                                if (!Array.isArray(object.digests))
                                    throw TypeError(".build.bazel.remote.execution.v2.BatchReadBlobsRequest.digests: array expected");
                                message.digests = [];
                                for (let i = 0; i < object.digests.length; ++i) {
                                    if (typeof object.digests[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchReadBlobsRequest.digests: object expected");
                                    message.digests[i] = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digests[i]);
                                }
                            }
                            if (object.acceptableCompressors) {
                                if (!Array.isArray(object.acceptableCompressors))
                                    throw TypeError(".build.bazel.remote.execution.v2.BatchReadBlobsRequest.acceptableCompressors: array expected");
                                message.acceptableCompressors = [];
                                for (let i = 0; i < object.acceptableCompressors.length; ++i)
                                    switch (object.acceptableCompressors[i]) {
                                    default:
                                        if (typeof object.acceptableCompressors[i] === "number") {
                                            message.acceptableCompressors[i] = object.acceptableCompressors[i];
                                            break;
                                        }
                                    case "IDENTITY":
                                    case 0:
                                        message.acceptableCompressors[i] = 0;
                                        break;
                                    case "ZSTD":
                                    case 1:
                                        message.acceptableCompressors[i] = 1;
                                        break;
                                    case "DEFLATE":
                                    case 2:
                                        message.acceptableCompressors[i] = 2;
                                        break;
                                    case "BROTLI":
                                    case 3:
                                        message.acceptableCompressors[i] = 3;
                                        break;
                                    }
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a BatchReadBlobsRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.BatchReadBlobsRequest} message BatchReadBlobsRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BatchReadBlobsRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.digests = [];
                                object.acceptableCompressors = [];
                            }
                            if (options.defaults) {
                                object.instanceName = "";
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.digests && message.digests.length) {
                                object.digests = [];
                                for (let j = 0; j < message.digests.length; ++j)
                                    object.digests[j] = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digests[j], options);
                            }
                            if (message.acceptableCompressors && message.acceptableCompressors.length) {
                                object.acceptableCompressors = [];
                                for (let j = 0; j < message.acceptableCompressors.length; ++j)
                                    object.acceptableCompressors[j] = options.enums === String ? $root.build.bazel.remote.execution.v2.Compressor.Value[message.acceptableCompressors[j]] === undefined ? message.acceptableCompressors[j] : $root.build.bazel.remote.execution.v2.Compressor.Value[message.acceptableCompressors[j]] : message.acceptableCompressors[j];
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this BatchReadBlobsRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BatchReadBlobsRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for BatchReadBlobsRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        BatchReadBlobsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.BatchReadBlobsRequest";
                        };

                        return BatchReadBlobsRequest;
                    })();

                    v2.BatchReadBlobsResponse = (function() {

                        /**
                         * Properties of a BatchReadBlobsResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IBatchReadBlobsResponse
                         * @property {Array.<build.bazel.remote.execution.v2.BatchReadBlobsResponse.IResponse>|null} [responses] BatchReadBlobsResponse responses
                         */

                        /**
                         * Constructs a new BatchReadBlobsResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a BatchReadBlobsResponse.
                         * @implements IBatchReadBlobsResponse
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsResponse=} [properties] Properties to set
                         */
                        function BatchReadBlobsResponse(properties) {
                            this.responses = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * BatchReadBlobsResponse responses.
                         * @member {Array.<build.bazel.remote.execution.v2.BatchReadBlobsResponse.IResponse>} responses
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @instance
                         */
                        BatchReadBlobsResponse.prototype.responses = $util.emptyArray;

                        /**
                         * Creates a new BatchReadBlobsResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse} BatchReadBlobsResponse instance
                         */
                        BatchReadBlobsResponse.create = function create(properties) {
                            return new BatchReadBlobsResponse(properties);
                        };

                        /**
                         * Encodes the specified BatchReadBlobsResponse message. Does not implicitly {@link build.bazel.remote.execution.v2.BatchReadBlobsResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsResponse} message BatchReadBlobsResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchReadBlobsResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.responses != null && message.responses.length)
                                for (let i = 0; i < message.responses.length; ++i)
                                    $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.encode(message.responses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified BatchReadBlobsResponse message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.BatchReadBlobsResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IBatchReadBlobsResponse} message BatchReadBlobsResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BatchReadBlobsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a BatchReadBlobsResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse} BatchReadBlobsResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchReadBlobsResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.responses && message.responses.length))
                                            message.responses = [];
                                        message.responses.push($root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a BatchReadBlobsResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse} BatchReadBlobsResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BatchReadBlobsResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a BatchReadBlobsResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BatchReadBlobsResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.responses != null && message.hasOwnProperty("responses")) {
                                if (!Array.isArray(message.responses))
                                    return "responses: array expected";
                                for (let i = 0; i < message.responses.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.verify(message.responses[i]);
                                    if (error)
                                        return "responses." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a BatchReadBlobsResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse} BatchReadBlobsResponse
                         */
                        BatchReadBlobsResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse();
                            if (object.responses) {
                                if (!Array.isArray(object.responses))
                                    throw TypeError(".build.bazel.remote.execution.v2.BatchReadBlobsResponse.responses: array expected");
                                message.responses = [];
                                for (let i = 0; i < object.responses.length; ++i) {
                                    if (typeof object.responses[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchReadBlobsResponse.responses: object expected");
                                    message.responses[i] = $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.fromObject(object.responses[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a BatchReadBlobsResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.BatchReadBlobsResponse} message BatchReadBlobsResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BatchReadBlobsResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.responses = [];
                            if (message.responses && message.responses.length) {
                                object.responses = [];
                                for (let j = 0; j < message.responses.length; ++j)
                                    object.responses[j] = $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.toObject(message.responses[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this BatchReadBlobsResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BatchReadBlobsResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for BatchReadBlobsResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        BatchReadBlobsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.BatchReadBlobsResponse";
                        };

                        BatchReadBlobsResponse.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                             * @interface IResponse
                             * @property {build.bazel.remote.execution.v2.IDigest|null} [digest] Response digest
                             * @property {Uint8Array|null} [data] Response data
                             * @property {build.bazel.remote.execution.v2.Compressor.Value|null} [compressor] Response compressor
                             * @property {google.rpc.IStatus|null} [status] Response status
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {build.bazel.remote.execution.v2.BatchReadBlobsResponse.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response digest.
                             * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} digest
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @instance
                             */
                            Response.prototype.digest = null;

                            /**
                             * Response data.
                             * @member {Uint8Array} data
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @instance
                             */
                            Response.prototype.data = $util.newBuffer([]);

                            /**
                             * Response compressor.
                             * @member {build.bazel.remote.execution.v2.Compressor.Value} compressor
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @instance
                             */
                            Response.prototype.compressor = 0;

                            /**
                             * Response status.
                             * @member {google.rpc.IStatus|null|undefined} status
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @instance
                             */
                            Response.prototype.status = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchReadBlobsResponse.IResponse=} [properties] Properties to set
                             * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.verify|verify} messages.
                             * @function encode
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchReadBlobsResponse.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.digest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                                    $root.google.rpc.Status.encode(message.status, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                                if (message.compressor != null && Object.hasOwnProperty.call(message, "compressor"))
                                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.compressor);
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchReadBlobsResponse.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.digest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                            break;
                                        }
                                    case 2: {
                                            message.data = reader.bytes();
                                            break;
                                        }
                                    case 4: {
                                            message.compressor = reader.int32();
                                            break;
                                        }
                                    case 3: {
                                            message.status = $root.google.rpc.Status.decode(reader, reader.uint32());
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.digest != null && message.hasOwnProperty("digest")) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.digest);
                                    if (error)
                                        return "digest." + error;
                                }
                                if (message.data != null && message.hasOwnProperty("data"))
                                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                        return "data: buffer expected";
                                if (message.compressor != null && message.hasOwnProperty("compressor"))
                                    switch (message.compressor) {
                                    default:
                                        return "compressor: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                        break;
                                    }
                                if (message.status != null && message.hasOwnProperty("status")) {
                                    let error = $root.google.rpc.Status.verify(message.status);
                                    if (error)
                                        return "status." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response)
                                    return object;
                                let message = new $root.build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response();
                                if (object.digest != null) {
                                    if (typeof object.digest !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.digest: object expected");
                                    message.digest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.digest);
                                }
                                if (object.data != null)
                                    if (typeof object.data === "string")
                                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                                    else if (object.data.length >= 0)
                                        message.data = object.data;
                                switch (object.compressor) {
                                default:
                                    if (typeof object.compressor === "number") {
                                        message.compressor = object.compressor;
                                        break;
                                    }
                                    break;
                                case "IDENTITY":
                                case 0:
                                    message.compressor = 0;
                                    break;
                                case "ZSTD":
                                case 1:
                                    message.compressor = 1;
                                    break;
                                case "DEFLATE":
                                case 2:
                                    message.compressor = 2;
                                    break;
                                case "BROTLI":
                                case 3:
                                    message.compressor = 3;
                                    break;
                                }
                                if (object.status != null) {
                                    if (typeof object.status !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response.status: object expected");
                                    message.status = $root.google.rpc.Status.fromObject(object.status);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.digest = null;
                                    if (options.bytes === String)
                                        object.data = "";
                                    else {
                                        object.data = [];
                                        if (options.bytes !== Array)
                                            object.data = $util.newBuffer(object.data);
                                    }
                                    object.status = null;
                                    object.compressor = options.enums === String ? "IDENTITY" : 0;
                                }
                                if (message.digest != null && message.hasOwnProperty("digest"))
                                    object.digest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.digest, options);
                                if (message.data != null && message.hasOwnProperty("data"))
                                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                                if (message.status != null && message.hasOwnProperty("status"))
                                    object.status = $root.google.rpc.Status.toObject(message.status, options);
                                if (message.compressor != null && message.hasOwnProperty("compressor"))
                                    object.compressor = options.enums === String ? $root.build.bazel.remote.execution.v2.Compressor.Value[message.compressor] === undefined ? message.compressor : $root.build.bazel.remote.execution.v2.Compressor.Value[message.compressor] : message.compressor;
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for Response
                             * @function getTypeUrl
                             * @memberof build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/build.bazel.remote.execution.v2.BatchReadBlobsResponse.Response";
                            };

                            return Response;
                        })();

                        return BatchReadBlobsResponse;
                    })();

                    v2.GetTreeRequest = (function() {

                        /**
                         * Properties of a GetTreeRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IGetTreeRequest
                         * @property {string|null} [instanceName] GetTreeRequest instanceName
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [rootDigest] GetTreeRequest rootDigest
                         * @property {number|null} [pageSize] GetTreeRequest pageSize
                         * @property {string|null} [pageToken] GetTreeRequest pageToken
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] GetTreeRequest digestFunction
                         */

                        /**
                         * Constructs a new GetTreeRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a GetTreeRequest.
                         * @implements IGetTreeRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IGetTreeRequest=} [properties] Properties to set
                         */
                        function GetTreeRequest(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GetTreeRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @instance
                         */
                        GetTreeRequest.prototype.instanceName = "";

                        /**
                         * GetTreeRequest rootDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} rootDigest
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @instance
                         */
                        GetTreeRequest.prototype.rootDigest = null;

                        /**
                         * GetTreeRequest pageSize.
                         * @member {number} pageSize
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @instance
                         */
                        GetTreeRequest.prototype.pageSize = 0;

                        /**
                         * GetTreeRequest pageToken.
                         * @member {string} pageToken
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @instance
                         */
                        GetTreeRequest.prototype.pageToken = "";

                        /**
                         * GetTreeRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @instance
                         */
                        GetTreeRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new GetTreeRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetTreeRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.GetTreeRequest} GetTreeRequest instance
                         */
                        GetTreeRequest.create = function create(properties) {
                            return new GetTreeRequest(properties);
                        };

                        /**
                         * Encodes the specified GetTreeRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.GetTreeRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetTreeRequest} message GetTreeRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetTreeRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.rootDigest != null && Object.hasOwnProperty.call(message, "rootDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.rootDigest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.pageSize != null && Object.hasOwnProperty.call(message, "pageSize"))
                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pageSize);
                            if (message.pageToken != null && Object.hasOwnProperty.call(message, "pageToken"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.pageToken);
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified GetTreeRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.GetTreeRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetTreeRequest} message GetTreeRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetTreeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GetTreeRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.GetTreeRequest} GetTreeRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetTreeRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.GetTreeRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.rootDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.pageSize = reader.int32();
                                        break;
                                    }
                                case 4: {
                                        message.pageToken = reader.string();
                                        break;
                                    }
                                case 5: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GetTreeRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.GetTreeRequest} GetTreeRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetTreeRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GetTreeRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GetTreeRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.rootDigest != null && message.hasOwnProperty("rootDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.rootDigest);
                                if (error)
                                    return "rootDigest." + error;
                            }
                            if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                                if (!$util.isInteger(message.pageSize))
                                    return "pageSize: integer expected";
                            if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                                if (!$util.isString(message.pageToken))
                                    return "pageToken: string expected";
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a GetTreeRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.GetTreeRequest} GetTreeRequest
                         */
                        GetTreeRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.GetTreeRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.GetTreeRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.rootDigest != null) {
                                if (typeof object.rootDigest !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.GetTreeRequest.rootDigest: object expected");
                                message.rootDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.rootDigest);
                            }
                            if (object.pageSize != null)
                                message.pageSize = object.pageSize | 0;
                            if (object.pageToken != null)
                                message.pageToken = String(object.pageToken);
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a GetTreeRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.GetTreeRequest} message GetTreeRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GetTreeRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.instanceName = "";
                                object.rootDigest = null;
                                object.pageSize = 0;
                                object.pageToken = "";
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.rootDigest != null && message.hasOwnProperty("rootDigest"))
                                object.rootDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.rootDigest, options);
                            if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                                object.pageSize = message.pageSize;
                            if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                                object.pageToken = message.pageToken;
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this GetTreeRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GetTreeRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for GetTreeRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.GetTreeRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        GetTreeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.GetTreeRequest";
                        };

                        return GetTreeRequest;
                    })();

                    v2.GetTreeResponse = (function() {

                        /**
                         * Properties of a GetTreeResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IGetTreeResponse
                         * @property {Array.<build.bazel.remote.execution.v2.IDirectory>|null} [directories] GetTreeResponse directories
                         * @property {string|null} [nextPageToken] GetTreeResponse nextPageToken
                         */

                        /**
                         * Constructs a new GetTreeResponse.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a GetTreeResponse.
                         * @implements IGetTreeResponse
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IGetTreeResponse=} [properties] Properties to set
                         */
                        function GetTreeResponse(properties) {
                            this.directories = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GetTreeResponse directories.
                         * @member {Array.<build.bazel.remote.execution.v2.IDirectory>} directories
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @instance
                         */
                        GetTreeResponse.prototype.directories = $util.emptyArray;

                        /**
                         * GetTreeResponse nextPageToken.
                         * @member {string} nextPageToken
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @instance
                         */
                        GetTreeResponse.prototype.nextPageToken = "";

                        /**
                         * Creates a new GetTreeResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetTreeResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.GetTreeResponse} GetTreeResponse instance
                         */
                        GetTreeResponse.create = function create(properties) {
                            return new GetTreeResponse(properties);
                        };

                        /**
                         * Encodes the specified GetTreeResponse message. Does not implicitly {@link build.bazel.remote.execution.v2.GetTreeResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetTreeResponse} message GetTreeResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetTreeResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.directories != null && message.directories.length)
                                for (let i = 0; i < message.directories.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Directory.encode(message.directories[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
                            return writer;
                        };

                        /**
                         * Encodes the specified GetTreeResponse message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.GetTreeResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetTreeResponse} message GetTreeResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetTreeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GetTreeResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.GetTreeResponse} GetTreeResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetTreeResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.GetTreeResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.directories && message.directories.length))
                                            message.directories = [];
                                        message.directories.push($root.build.bazel.remote.execution.v2.Directory.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 2: {
                                        message.nextPageToken = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GetTreeResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.GetTreeResponse} GetTreeResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetTreeResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GetTreeResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GetTreeResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.directories != null && message.hasOwnProperty("directories")) {
                                if (!Array.isArray(message.directories))
                                    return "directories: array expected";
                                for (let i = 0; i < message.directories.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Directory.verify(message.directories[i]);
                                    if (error)
                                        return "directories." + error;
                                }
                            }
                            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                                if (!$util.isString(message.nextPageToken))
                                    return "nextPageToken: string expected";
                            return null;
                        };

                        /**
                         * Creates a GetTreeResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.GetTreeResponse} GetTreeResponse
                         */
                        GetTreeResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.GetTreeResponse)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.GetTreeResponse();
                            if (object.directories) {
                                if (!Array.isArray(object.directories))
                                    throw TypeError(".build.bazel.remote.execution.v2.GetTreeResponse.directories: array expected");
                                message.directories = [];
                                for (let i = 0; i < object.directories.length; ++i) {
                                    if (typeof object.directories[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.GetTreeResponse.directories: object expected");
                                    message.directories[i] = $root.build.bazel.remote.execution.v2.Directory.fromObject(object.directories[i]);
                                }
                            }
                            if (object.nextPageToken != null)
                                message.nextPageToken = String(object.nextPageToken);
                            return message;
                        };

                        /**
                         * Creates a plain object from a GetTreeResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {build.bazel.remote.execution.v2.GetTreeResponse} message GetTreeResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GetTreeResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.directories = [];
                            if (options.defaults)
                                object.nextPageToken = "";
                            if (message.directories && message.directories.length) {
                                object.directories = [];
                                for (let j = 0; j < message.directories.length; ++j)
                                    object.directories[j] = $root.build.bazel.remote.execution.v2.Directory.toObject(message.directories[j], options);
                            }
                            if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                                object.nextPageToken = message.nextPageToken;
                            return object;
                        };

                        /**
                         * Converts this GetTreeResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GetTreeResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for GetTreeResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.GetTreeResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        GetTreeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.GetTreeResponse";
                        };

                        return GetTreeResponse;
                    })();

                    v2.GetCapabilitiesRequest = (function() {

                        /**
                         * Properties of a GetCapabilitiesRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IGetCapabilitiesRequest
                         * @property {string|null} [instanceName] GetCapabilitiesRequest instanceName
                         */

                        /**
                         * Constructs a new GetCapabilitiesRequest.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a GetCapabilitiesRequest.
                         * @implements IGetCapabilitiesRequest
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IGetCapabilitiesRequest=} [properties] Properties to set
                         */
                        function GetCapabilitiesRequest(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GetCapabilitiesRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @instance
                         */
                        GetCapabilitiesRequest.prototype.instanceName = "";

                        /**
                         * Creates a new GetCapabilitiesRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetCapabilitiesRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.GetCapabilitiesRequest} GetCapabilitiesRequest instance
                         */
                        GetCapabilitiesRequest.create = function create(properties) {
                            return new GetCapabilitiesRequest(properties);
                        };

                        /**
                         * Encodes the specified GetCapabilitiesRequest message. Does not implicitly {@link build.bazel.remote.execution.v2.GetCapabilitiesRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetCapabilitiesRequest} message GetCapabilitiesRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetCapabilitiesRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            return writer;
                        };

                        /**
                         * Encodes the specified GetCapabilitiesRequest message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.GetCapabilitiesRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.IGetCapabilitiesRequest} message GetCapabilitiesRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        GetCapabilitiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a GetCapabilitiesRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.GetCapabilitiesRequest} GetCapabilitiesRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetCapabilitiesRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.GetCapabilitiesRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a GetCapabilitiesRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.GetCapabilitiesRequest} GetCapabilitiesRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GetCapabilitiesRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a GetCapabilitiesRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GetCapabilitiesRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            return null;
                        };

                        /**
                         * Creates a GetCapabilitiesRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.GetCapabilitiesRequest} GetCapabilitiesRequest
                         */
                        GetCapabilitiesRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.GetCapabilitiesRequest)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.GetCapabilitiesRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            return message;
                        };

                        /**
                         * Creates a plain object from a GetCapabilitiesRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {build.bazel.remote.execution.v2.GetCapabilitiesRequest} message GetCapabilitiesRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GetCapabilitiesRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.instanceName = "";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            return object;
                        };

                        /**
                         * Converts this GetCapabilitiesRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GetCapabilitiesRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for GetCapabilitiesRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.GetCapabilitiesRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        GetCapabilitiesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.GetCapabilitiesRequest";
                        };

                        return GetCapabilitiesRequest;
                    })();

                    v2.ServerCapabilities = (function() {

                        /**
                         * Properties of a ServerCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IServerCapabilities
                         * @property {build.bazel.remote.execution.v2.ICacheCapabilities|null} [cacheCapabilities] ServerCapabilities cacheCapabilities
                         * @property {build.bazel.remote.execution.v2.IExecutionCapabilities|null} [executionCapabilities] ServerCapabilities executionCapabilities
                         * @property {build.bazel.semver.ISemVer|null} [deprecatedApiVersion] ServerCapabilities deprecatedApiVersion
                         * @property {build.bazel.semver.ISemVer|null} [lowApiVersion] ServerCapabilities lowApiVersion
                         * @property {build.bazel.semver.ISemVer|null} [highApiVersion] ServerCapabilities highApiVersion
                         */

                        /**
                         * Constructs a new ServerCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a ServerCapabilities.
                         * @implements IServerCapabilities
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IServerCapabilities=} [properties] Properties to set
                         */
                        function ServerCapabilities(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ServerCapabilities cacheCapabilities.
                         * @member {build.bazel.remote.execution.v2.ICacheCapabilities|null|undefined} cacheCapabilities
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @instance
                         */
                        ServerCapabilities.prototype.cacheCapabilities = null;

                        /**
                         * ServerCapabilities executionCapabilities.
                         * @member {build.bazel.remote.execution.v2.IExecutionCapabilities|null|undefined} executionCapabilities
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @instance
                         */
                        ServerCapabilities.prototype.executionCapabilities = null;

                        /**
                         * ServerCapabilities deprecatedApiVersion.
                         * @member {build.bazel.semver.ISemVer|null|undefined} deprecatedApiVersion
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @instance
                         */
                        ServerCapabilities.prototype.deprecatedApiVersion = null;

                        /**
                         * ServerCapabilities lowApiVersion.
                         * @member {build.bazel.semver.ISemVer|null|undefined} lowApiVersion
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @instance
                         */
                        ServerCapabilities.prototype.lowApiVersion = null;

                        /**
                         * ServerCapabilities highApiVersion.
                         * @member {build.bazel.semver.ISemVer|null|undefined} highApiVersion
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @instance
                         */
                        ServerCapabilities.prototype.highApiVersion = null;

                        /**
                         * Creates a new ServerCapabilities instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IServerCapabilities=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ServerCapabilities} ServerCapabilities instance
                         */
                        ServerCapabilities.create = function create(properties) {
                            return new ServerCapabilities(properties);
                        };

                        /**
                         * Encodes the specified ServerCapabilities message. Does not implicitly {@link build.bazel.remote.execution.v2.ServerCapabilities.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IServerCapabilities} message ServerCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ServerCapabilities.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.cacheCapabilities != null && Object.hasOwnProperty.call(message, "cacheCapabilities"))
                                $root.build.bazel.remote.execution.v2.CacheCapabilities.encode(message.cacheCapabilities, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.executionCapabilities != null && Object.hasOwnProperty.call(message, "executionCapabilities"))
                                $root.build.bazel.remote.execution.v2.ExecutionCapabilities.encode(message.executionCapabilities, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.deprecatedApiVersion != null && Object.hasOwnProperty.call(message, "deprecatedApiVersion"))
                                $root.build.bazel.semver.SemVer.encode(message.deprecatedApiVersion, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.lowApiVersion != null && Object.hasOwnProperty.call(message, "lowApiVersion"))
                                $root.build.bazel.semver.SemVer.encode(message.lowApiVersion, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.highApiVersion != null && Object.hasOwnProperty.call(message, "highApiVersion"))
                                $root.build.bazel.semver.SemVer.encode(message.highApiVersion, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified ServerCapabilities message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ServerCapabilities.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IServerCapabilities} message ServerCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ServerCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ServerCapabilities message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ServerCapabilities} ServerCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ServerCapabilities.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ServerCapabilities();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.cacheCapabilities = $root.build.bazel.remote.execution.v2.CacheCapabilities.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.executionCapabilities = $root.build.bazel.remote.execution.v2.ExecutionCapabilities.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.deprecatedApiVersion = $root.build.bazel.semver.SemVer.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.lowApiVersion = $root.build.bazel.semver.SemVer.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 5: {
                                        message.highApiVersion = $root.build.bazel.semver.SemVer.decode(reader, reader.uint32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ServerCapabilities message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ServerCapabilities} ServerCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ServerCapabilities.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ServerCapabilities message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ServerCapabilities.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.cacheCapabilities != null && message.hasOwnProperty("cacheCapabilities")) {
                                let error = $root.build.bazel.remote.execution.v2.CacheCapabilities.verify(message.cacheCapabilities);
                                if (error)
                                    return "cacheCapabilities." + error;
                            }
                            if (message.executionCapabilities != null && message.hasOwnProperty("executionCapabilities")) {
                                let error = $root.build.bazel.remote.execution.v2.ExecutionCapabilities.verify(message.executionCapabilities);
                                if (error)
                                    return "executionCapabilities." + error;
                            }
                            if (message.deprecatedApiVersion != null && message.hasOwnProperty("deprecatedApiVersion")) {
                                let error = $root.build.bazel.semver.SemVer.verify(message.deprecatedApiVersion);
                                if (error)
                                    return "deprecatedApiVersion." + error;
                            }
                            if (message.lowApiVersion != null && message.hasOwnProperty("lowApiVersion")) {
                                let error = $root.build.bazel.semver.SemVer.verify(message.lowApiVersion);
                                if (error)
                                    return "lowApiVersion." + error;
                            }
                            if (message.highApiVersion != null && message.hasOwnProperty("highApiVersion")) {
                                let error = $root.build.bazel.semver.SemVer.verify(message.highApiVersion);
                                if (error)
                                    return "highApiVersion." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a ServerCapabilities message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ServerCapabilities} ServerCapabilities
                         */
                        ServerCapabilities.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ServerCapabilities)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ServerCapabilities();
                            if (object.cacheCapabilities != null) {
                                if (typeof object.cacheCapabilities !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ServerCapabilities.cacheCapabilities: object expected");
                                message.cacheCapabilities = $root.build.bazel.remote.execution.v2.CacheCapabilities.fromObject(object.cacheCapabilities);
                            }
                            if (object.executionCapabilities != null) {
                                if (typeof object.executionCapabilities !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ServerCapabilities.executionCapabilities: object expected");
                                message.executionCapabilities = $root.build.bazel.remote.execution.v2.ExecutionCapabilities.fromObject(object.executionCapabilities);
                            }
                            if (object.deprecatedApiVersion != null) {
                                if (typeof object.deprecatedApiVersion !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ServerCapabilities.deprecatedApiVersion: object expected");
                                message.deprecatedApiVersion = $root.build.bazel.semver.SemVer.fromObject(object.deprecatedApiVersion);
                            }
                            if (object.lowApiVersion != null) {
                                if (typeof object.lowApiVersion !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ServerCapabilities.lowApiVersion: object expected");
                                message.lowApiVersion = $root.build.bazel.semver.SemVer.fromObject(object.lowApiVersion);
                            }
                            if (object.highApiVersion != null) {
                                if (typeof object.highApiVersion !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ServerCapabilities.highApiVersion: object expected");
                                message.highApiVersion = $root.build.bazel.semver.SemVer.fromObject(object.highApiVersion);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a ServerCapabilities message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.ServerCapabilities} message ServerCapabilities
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ServerCapabilities.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.cacheCapabilities = null;
                                object.executionCapabilities = null;
                                object.deprecatedApiVersion = null;
                                object.lowApiVersion = null;
                                object.highApiVersion = null;
                            }
                            if (message.cacheCapabilities != null && message.hasOwnProperty("cacheCapabilities"))
                                object.cacheCapabilities = $root.build.bazel.remote.execution.v2.CacheCapabilities.toObject(message.cacheCapabilities, options);
                            if (message.executionCapabilities != null && message.hasOwnProperty("executionCapabilities"))
                                object.executionCapabilities = $root.build.bazel.remote.execution.v2.ExecutionCapabilities.toObject(message.executionCapabilities, options);
                            if (message.deprecatedApiVersion != null && message.hasOwnProperty("deprecatedApiVersion"))
                                object.deprecatedApiVersion = $root.build.bazel.semver.SemVer.toObject(message.deprecatedApiVersion, options);
                            if (message.lowApiVersion != null && message.hasOwnProperty("lowApiVersion"))
                                object.lowApiVersion = $root.build.bazel.semver.SemVer.toObject(message.lowApiVersion, options);
                            if (message.highApiVersion != null && message.hasOwnProperty("highApiVersion"))
                                object.highApiVersion = $root.build.bazel.semver.SemVer.toObject(message.highApiVersion, options);
                            return object;
                        };

                        /**
                         * Converts this ServerCapabilities to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ServerCapabilities.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ServerCapabilities
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ServerCapabilities
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ServerCapabilities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ServerCapabilities";
                        };

                        return ServerCapabilities;
                    })();

                    v2.DigestFunction = (function() {

                        /**
                         * Properties of a DigestFunction.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IDigestFunction
                         */

                        /**
                         * Constructs a new DigestFunction.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a DigestFunction.
                         * @implements IDigestFunction
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IDigestFunction=} [properties] Properties to set
                         */
                        function DigestFunction(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new DigestFunction instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDigestFunction=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.DigestFunction} DigestFunction instance
                         */
                        DigestFunction.create = function create(properties) {
                            return new DigestFunction(properties);
                        };

                        /**
                         * Encodes the specified DigestFunction message. Does not implicitly {@link build.bazel.remote.execution.v2.DigestFunction.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDigestFunction} message DigestFunction message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        DigestFunction.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified DigestFunction message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.DigestFunction.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {build.bazel.remote.execution.v2.IDigestFunction} message DigestFunction message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        DigestFunction.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a DigestFunction message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.DigestFunction} DigestFunction
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        DigestFunction.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.DigestFunction();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a DigestFunction message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.DigestFunction} DigestFunction
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        DigestFunction.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a DigestFunction message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        DigestFunction.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a DigestFunction message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.DigestFunction} DigestFunction
                         */
                        DigestFunction.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.DigestFunction)
                                return object;
                            return new $root.build.bazel.remote.execution.v2.DigestFunction();
                        };

                        /**
                         * Creates a plain object from a DigestFunction message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {build.bazel.remote.execution.v2.DigestFunction} message DigestFunction
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        DigestFunction.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this DigestFunction to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        DigestFunction.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for DigestFunction
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.DigestFunction
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        DigestFunction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.DigestFunction";
                        };

                        /**
                         * Value enum.
                         * @name build.bazel.remote.execution.v2.DigestFunction.Value
                         * @enum {number}
                         * @property {number} UNKNOWN=0 UNKNOWN value
                         * @property {number} SHA256=1 SHA256 value
                         * @property {number} SHA1=2 SHA1 value
                         * @property {number} MD5=3 MD5 value
                         * @property {number} VSO=4 VSO value
                         * @property {number} SHA384=5 SHA384 value
                         * @property {number} SHA512=6 SHA512 value
                         * @property {number} MURMUR3=7 MURMUR3 value
                         * @property {number} SHA256TREE=8 SHA256TREE value
                         * @property {number} BLAKE3=9 BLAKE3 value
                         */
                        DigestFunction.Value = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNKNOWN"] = 0;
                            values[valuesById[1] = "SHA256"] = 1;
                            values[valuesById[2] = "SHA1"] = 2;
                            values[valuesById[3] = "MD5"] = 3;
                            values[valuesById[4] = "VSO"] = 4;
                            values[valuesById[5] = "SHA384"] = 5;
                            values[valuesById[6] = "SHA512"] = 6;
                            values[valuesById[7] = "MURMUR3"] = 7;
                            values[valuesById[8] = "SHA256TREE"] = 8;
                            values[valuesById[9] = "BLAKE3"] = 9;
                            return values;
                        })();

                        return DigestFunction;
                    })();

                    v2.ActionCacheUpdateCapabilities = (function() {

                        /**
                         * Properties of an ActionCacheUpdateCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IActionCacheUpdateCapabilities
                         * @property {boolean|null} [updateEnabled] ActionCacheUpdateCapabilities updateEnabled
                         */

                        /**
                         * Constructs a new ActionCacheUpdateCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ActionCacheUpdateCapabilities.
                         * @implements IActionCacheUpdateCapabilities
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IActionCacheUpdateCapabilities=} [properties] Properties to set
                         */
                        function ActionCacheUpdateCapabilities(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ActionCacheUpdateCapabilities updateEnabled.
                         * @member {boolean} updateEnabled
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @instance
                         */
                        ActionCacheUpdateCapabilities.prototype.updateEnabled = false;

                        /**
                         * Creates a new ActionCacheUpdateCapabilities instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IActionCacheUpdateCapabilities=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities} ActionCacheUpdateCapabilities instance
                         */
                        ActionCacheUpdateCapabilities.create = function create(properties) {
                            return new ActionCacheUpdateCapabilities(properties);
                        };

                        /**
                         * Encodes the specified ActionCacheUpdateCapabilities message. Does not implicitly {@link build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IActionCacheUpdateCapabilities} message ActionCacheUpdateCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ActionCacheUpdateCapabilities.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.updateEnabled != null && Object.hasOwnProperty.call(message, "updateEnabled"))
                                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.updateEnabled);
                            return writer;
                        };

                        /**
                         * Encodes the specified ActionCacheUpdateCapabilities message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IActionCacheUpdateCapabilities} message ActionCacheUpdateCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ActionCacheUpdateCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ActionCacheUpdateCapabilities message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities} ActionCacheUpdateCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ActionCacheUpdateCapabilities.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.updateEnabled = reader.bool();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ActionCacheUpdateCapabilities message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities} ActionCacheUpdateCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ActionCacheUpdateCapabilities.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ActionCacheUpdateCapabilities message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ActionCacheUpdateCapabilities.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.updateEnabled != null && message.hasOwnProperty("updateEnabled"))
                                if (typeof message.updateEnabled !== "boolean")
                                    return "updateEnabled: boolean expected";
                            return null;
                        };

                        /**
                         * Creates an ActionCacheUpdateCapabilities message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities} ActionCacheUpdateCapabilities
                         */
                        ActionCacheUpdateCapabilities.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities();
                            if (object.updateEnabled != null)
                                message.updateEnabled = Boolean(object.updateEnabled);
                            return message;
                        };

                        /**
                         * Creates a plain object from an ActionCacheUpdateCapabilities message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities} message ActionCacheUpdateCapabilities
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ActionCacheUpdateCapabilities.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.updateEnabled = false;
                            if (message.updateEnabled != null && message.hasOwnProperty("updateEnabled"))
                                object.updateEnabled = message.updateEnabled;
                            return object;
                        };

                        /**
                         * Converts this ActionCacheUpdateCapabilities to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ActionCacheUpdateCapabilities.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ActionCacheUpdateCapabilities
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ActionCacheUpdateCapabilities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities";
                        };

                        return ActionCacheUpdateCapabilities;
                    })();

                    v2.PriorityCapabilities = (function() {

                        /**
                         * Properties of a PriorityCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IPriorityCapabilities
                         * @property {Array.<build.bazel.remote.execution.v2.PriorityCapabilities.IPriorityRange>|null} [priorities] PriorityCapabilities priorities
                         */

                        /**
                         * Constructs a new PriorityCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a PriorityCapabilities.
                         * @implements IPriorityCapabilities
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IPriorityCapabilities=} [properties] Properties to set
                         */
                        function PriorityCapabilities(properties) {
                            this.priorities = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PriorityCapabilities priorities.
                         * @member {Array.<build.bazel.remote.execution.v2.PriorityCapabilities.IPriorityRange>} priorities
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @instance
                         */
                        PriorityCapabilities.prototype.priorities = $util.emptyArray;

                        /**
                         * Creates a new PriorityCapabilities instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IPriorityCapabilities=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.PriorityCapabilities} PriorityCapabilities instance
                         */
                        PriorityCapabilities.create = function create(properties) {
                            return new PriorityCapabilities(properties);
                        };

                        /**
                         * Encodes the specified PriorityCapabilities message. Does not implicitly {@link build.bazel.remote.execution.v2.PriorityCapabilities.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IPriorityCapabilities} message PriorityCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PriorityCapabilities.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.priorities != null && message.priorities.length)
                                for (let i = 0; i < message.priorities.length; ++i)
                                    $root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange.encode(message.priorities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified PriorityCapabilities message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.PriorityCapabilities.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IPriorityCapabilities} message PriorityCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PriorityCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PriorityCapabilities message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.PriorityCapabilities} PriorityCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PriorityCapabilities.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.PriorityCapabilities();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.priorities && message.priorities.length))
                                            message.priorities = [];
                                        message.priorities.push($root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange.decode(reader, reader.uint32()));
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PriorityCapabilities message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.PriorityCapabilities} PriorityCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PriorityCapabilities.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PriorityCapabilities message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PriorityCapabilities.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.priorities != null && message.hasOwnProperty("priorities")) {
                                if (!Array.isArray(message.priorities))
                                    return "priorities: array expected";
                                for (let i = 0; i < message.priorities.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange.verify(message.priorities[i]);
                                    if (error)
                                        return "priorities." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a PriorityCapabilities message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.PriorityCapabilities} PriorityCapabilities
                         */
                        PriorityCapabilities.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.PriorityCapabilities)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.PriorityCapabilities();
                            if (object.priorities) {
                                if (!Array.isArray(object.priorities))
                                    throw TypeError(".build.bazel.remote.execution.v2.PriorityCapabilities.priorities: array expected");
                                message.priorities = [];
                                for (let i = 0; i < object.priorities.length; ++i) {
                                    if (typeof object.priorities[i] !== "object")
                                        throw TypeError(".build.bazel.remote.execution.v2.PriorityCapabilities.priorities: object expected");
                                    message.priorities[i] = $root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange.fromObject(object.priorities[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a PriorityCapabilities message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.PriorityCapabilities} message PriorityCapabilities
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PriorityCapabilities.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.priorities = [];
                            if (message.priorities && message.priorities.length) {
                                object.priorities = [];
                                for (let j = 0; j < message.priorities.length; ++j)
                                    object.priorities[j] = $root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange.toObject(message.priorities[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this PriorityCapabilities to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PriorityCapabilities.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PriorityCapabilities
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PriorityCapabilities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.PriorityCapabilities";
                        };

                        PriorityCapabilities.PriorityRange = (function() {

                            /**
                             * Properties of a PriorityRange.
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                             * @interface IPriorityRange
                             * @property {number|null} [minPriority] PriorityRange minPriority
                             * @property {number|null} [maxPriority] PriorityRange maxPriority
                             */

                            /**
                             * Constructs a new PriorityRange.
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities
                             * @classdesc Represents a PriorityRange.
                             * @implements IPriorityRange
                             * @constructor
                             * @param {build.bazel.remote.execution.v2.PriorityCapabilities.IPriorityRange=} [properties] Properties to set
                             */
                            function PriorityRange(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PriorityRange minPriority.
                             * @member {number} minPriority
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @instance
                             */
                            PriorityRange.prototype.minPriority = 0;

                            /**
                             * PriorityRange maxPriority.
                             * @member {number} maxPriority
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @instance
                             */
                            PriorityRange.prototype.maxPriority = 0;

                            /**
                             * Creates a new PriorityRange instance using the specified properties.
                             * @function create
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {build.bazel.remote.execution.v2.PriorityCapabilities.IPriorityRange=} [properties] Properties to set
                             * @returns {build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange} PriorityRange instance
                             */
                            PriorityRange.create = function create(properties) {
                                return new PriorityRange(properties);
                            };

                            /**
                             * Encodes the specified PriorityRange message. Does not implicitly {@link build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange.verify|verify} messages.
                             * @function encode
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {build.bazel.remote.execution.v2.PriorityCapabilities.IPriorityRange} message PriorityRange message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PriorityRange.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.minPriority != null && Object.hasOwnProperty.call(message, "minPriority"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minPriority);
                                if (message.maxPriority != null && Object.hasOwnProperty.call(message, "maxPriority"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxPriority);
                                return writer;
                            };

                            /**
                             * Encodes the specified PriorityRange message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {build.bazel.remote.execution.v2.PriorityCapabilities.IPriorityRange} message PriorityRange message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            PriorityRange.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a PriorityRange message from the specified reader or buffer.
                             * @function decode
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange} PriorityRange
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PriorityRange.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange();
                                while (reader.pos < end) {
                                    let tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1: {
                                            message.minPriority = reader.int32();
                                            break;
                                        }
                                    case 2: {
                                            message.maxPriority = reader.int32();
                                            break;
                                        }
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a PriorityRange message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange} PriorityRange
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PriorityRange.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a PriorityRange message.
                             * @function verify
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            PriorityRange.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.minPriority != null && message.hasOwnProperty("minPriority"))
                                    if (!$util.isInteger(message.minPriority))
                                        return "minPriority: integer expected";
                                if (message.maxPriority != null && message.hasOwnProperty("maxPriority"))
                                    if (!$util.isInteger(message.maxPriority))
                                        return "maxPriority: integer expected";
                                return null;
                            };

                            /**
                             * Creates a PriorityRange message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange} PriorityRange
                             */
                            PriorityRange.fromObject = function fromObject(object) {
                                if (object instanceof $root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange)
                                    return object;
                                let message = new $root.build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange();
                                if (object.minPriority != null)
                                    message.minPriority = object.minPriority | 0;
                                if (object.maxPriority != null)
                                    message.maxPriority = object.maxPriority | 0;
                                return message;
                            };

                            /**
                             * Creates a plain object from a PriorityRange message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange} message PriorityRange
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            PriorityRange.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.minPriority = 0;
                                    object.maxPriority = 0;
                                }
                                if (message.minPriority != null && message.hasOwnProperty("minPriority"))
                                    object.minPriority = message.minPriority;
                                if (message.maxPriority != null && message.hasOwnProperty("maxPriority"))
                                    object.maxPriority = message.maxPriority;
                                return object;
                            };

                            /**
                             * Converts this PriorityRange to JSON.
                             * @function toJSON
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            PriorityRange.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Gets the default type url for PriorityRange
                             * @function getTypeUrl
                             * @memberof build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange
                             * @static
                             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                             * @returns {string} The default type url
                             */
                            PriorityRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                                if (typeUrlPrefix === undefined) {
                                    typeUrlPrefix = "type.googleapis.com";
                                }
                                return typeUrlPrefix + "/build.bazel.remote.execution.v2.PriorityCapabilities.PriorityRange";
                            };

                            return PriorityRange;
                        })();

                        return PriorityCapabilities;
                    })();

                    v2.SymlinkAbsolutePathStrategy = (function() {

                        /**
                         * Properties of a SymlinkAbsolutePathStrategy.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface ISymlinkAbsolutePathStrategy
                         */

                        /**
                         * Constructs a new SymlinkAbsolutePathStrategy.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a SymlinkAbsolutePathStrategy.
                         * @implements ISymlinkAbsolutePathStrategy
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.ISymlinkAbsolutePathStrategy=} [properties] Properties to set
                         */
                        function SymlinkAbsolutePathStrategy(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new SymlinkAbsolutePathStrategy instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {build.bazel.remote.execution.v2.ISymlinkAbsolutePathStrategy=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy} SymlinkAbsolutePathStrategy instance
                         */
                        SymlinkAbsolutePathStrategy.create = function create(properties) {
                            return new SymlinkAbsolutePathStrategy(properties);
                        };

                        /**
                         * Encodes the specified SymlinkAbsolutePathStrategy message. Does not implicitly {@link build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {build.bazel.remote.execution.v2.ISymlinkAbsolutePathStrategy} message SymlinkAbsolutePathStrategy message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SymlinkAbsolutePathStrategy.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified SymlinkAbsolutePathStrategy message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {build.bazel.remote.execution.v2.ISymlinkAbsolutePathStrategy} message SymlinkAbsolutePathStrategy message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        SymlinkAbsolutePathStrategy.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a SymlinkAbsolutePathStrategy message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy} SymlinkAbsolutePathStrategy
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SymlinkAbsolutePathStrategy.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a SymlinkAbsolutePathStrategy message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy} SymlinkAbsolutePathStrategy
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        SymlinkAbsolutePathStrategy.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a SymlinkAbsolutePathStrategy message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SymlinkAbsolutePathStrategy.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a SymlinkAbsolutePathStrategy message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy} SymlinkAbsolutePathStrategy
                         */
                        SymlinkAbsolutePathStrategy.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy)
                                return object;
                            return new $root.build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy();
                        };

                        /**
                         * Creates a plain object from a SymlinkAbsolutePathStrategy message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy} message SymlinkAbsolutePathStrategy
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SymlinkAbsolutePathStrategy.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this SymlinkAbsolutePathStrategy to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SymlinkAbsolutePathStrategy.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for SymlinkAbsolutePathStrategy
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        SymlinkAbsolutePathStrategy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy";
                        };

                        /**
                         * Value enum.
                         * @name build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy.Value
                         * @enum {number}
                         * @property {number} UNKNOWN=0 UNKNOWN value
                         * @property {number} DISALLOWED=1 DISALLOWED value
                         * @property {number} ALLOWED=2 ALLOWED value
                         */
                        SymlinkAbsolutePathStrategy.Value = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNKNOWN"] = 0;
                            values[valuesById[1] = "DISALLOWED"] = 1;
                            values[valuesById[2] = "ALLOWED"] = 2;
                            return values;
                        })();

                        return SymlinkAbsolutePathStrategy;
                    })();

                    v2.Compressor = (function() {

                        /**
                         * Properties of a Compressor.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface ICompressor
                         */

                        /**
                         * Constructs a new Compressor.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a Compressor.
                         * @implements ICompressor
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.ICompressor=} [properties] Properties to set
                         */
                        function Compressor(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Compressor instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICompressor=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.Compressor} Compressor instance
                         */
                        Compressor.create = function create(properties) {
                            return new Compressor(properties);
                        };

                        /**
                         * Encodes the specified Compressor message. Does not implicitly {@link build.bazel.remote.execution.v2.Compressor.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICompressor} message Compressor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Compressor.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Compressor message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.Compressor.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICompressor} message Compressor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Compressor.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Compressor message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.Compressor} Compressor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Compressor.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.Compressor();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Compressor message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.Compressor} Compressor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Compressor.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Compressor message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Compressor.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Compressor message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.Compressor} Compressor
                         */
                        Compressor.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.Compressor)
                                return object;
                            return new $root.build.bazel.remote.execution.v2.Compressor();
                        };

                        /**
                         * Creates a plain object from a Compressor message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {build.bazel.remote.execution.v2.Compressor} message Compressor
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Compressor.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Compressor to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Compressor.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Compressor
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.Compressor
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Compressor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.Compressor";
                        };

                        /**
                         * Value enum.
                         * @name build.bazel.remote.execution.v2.Compressor.Value
                         * @enum {number}
                         * @property {number} IDENTITY=0 IDENTITY value
                         * @property {number} ZSTD=1 ZSTD value
                         * @property {number} DEFLATE=2 DEFLATE value
                         * @property {number} BROTLI=3 BROTLI value
                         */
                        Compressor.Value = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "IDENTITY"] = 0;
                            values[valuesById[1] = "ZSTD"] = 1;
                            values[valuesById[2] = "DEFLATE"] = 2;
                            values[valuesById[3] = "BROTLI"] = 3;
                            return values;
                        })();

                        return Compressor;
                    })();

                    v2.CacheCapabilities = (function() {

                        /**
                         * Properties of a CacheCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface ICacheCapabilities
                         * @property {Array.<build.bazel.remote.execution.v2.DigestFunction.Value>|null} [digestFunctions] CacheCapabilities digestFunctions
                         * @property {build.bazel.remote.execution.v2.IActionCacheUpdateCapabilities|null} [actionCacheUpdateCapabilities] CacheCapabilities actionCacheUpdateCapabilities
                         * @property {build.bazel.remote.execution.v2.IPriorityCapabilities|null} [cachePriorityCapabilities] CacheCapabilities cachePriorityCapabilities
                         * @property {number|Long|null} [maxBatchTotalSizeBytes] CacheCapabilities maxBatchTotalSizeBytes
                         * @property {build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy.Value|null} [symlinkAbsolutePathStrategy] CacheCapabilities symlinkAbsolutePathStrategy
                         * @property {Array.<build.bazel.remote.execution.v2.Compressor.Value>|null} [supportedCompressors] CacheCapabilities supportedCompressors
                         * @property {Array.<build.bazel.remote.execution.v2.Compressor.Value>|null} [supportedBatchUpdateCompressors] CacheCapabilities supportedBatchUpdateCompressors
                         */

                        /**
                         * Constructs a new CacheCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a CacheCapabilities.
                         * @implements ICacheCapabilities
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.ICacheCapabilities=} [properties] Properties to set
                         */
                        function CacheCapabilities(properties) {
                            this.digestFunctions = [];
                            this.supportedCompressors = [];
                            this.supportedBatchUpdateCompressors = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * CacheCapabilities digestFunctions.
                         * @member {Array.<build.bazel.remote.execution.v2.DigestFunction.Value>} digestFunctions
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         */
                        CacheCapabilities.prototype.digestFunctions = $util.emptyArray;

                        /**
                         * CacheCapabilities actionCacheUpdateCapabilities.
                         * @member {build.bazel.remote.execution.v2.IActionCacheUpdateCapabilities|null|undefined} actionCacheUpdateCapabilities
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         */
                        CacheCapabilities.prototype.actionCacheUpdateCapabilities = null;

                        /**
                         * CacheCapabilities cachePriorityCapabilities.
                         * @member {build.bazel.remote.execution.v2.IPriorityCapabilities|null|undefined} cachePriorityCapabilities
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         */
                        CacheCapabilities.prototype.cachePriorityCapabilities = null;

                        /**
                         * CacheCapabilities maxBatchTotalSizeBytes.
                         * @member {number|Long} maxBatchTotalSizeBytes
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         */
                        CacheCapabilities.prototype.maxBatchTotalSizeBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * CacheCapabilities symlinkAbsolutePathStrategy.
                         * @member {build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy.Value} symlinkAbsolutePathStrategy
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         */
                        CacheCapabilities.prototype.symlinkAbsolutePathStrategy = 0;

                        /**
                         * CacheCapabilities supportedCompressors.
                         * @member {Array.<build.bazel.remote.execution.v2.Compressor.Value>} supportedCompressors
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         */
                        CacheCapabilities.prototype.supportedCompressors = $util.emptyArray;

                        /**
                         * CacheCapabilities supportedBatchUpdateCompressors.
                         * @member {Array.<build.bazel.remote.execution.v2.Compressor.Value>} supportedBatchUpdateCompressors
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         */
                        CacheCapabilities.prototype.supportedBatchUpdateCompressors = $util.emptyArray;

                        /**
                         * Creates a new CacheCapabilities instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICacheCapabilities=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.CacheCapabilities} CacheCapabilities instance
                         */
                        CacheCapabilities.create = function create(properties) {
                            return new CacheCapabilities(properties);
                        };

                        /**
                         * Encodes the specified CacheCapabilities message. Does not implicitly {@link build.bazel.remote.execution.v2.CacheCapabilities.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICacheCapabilities} message CacheCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CacheCapabilities.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.digestFunctions != null && message.digestFunctions.length) {
                                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                                for (let i = 0; i < message.digestFunctions.length; ++i)
                                    writer.int32(message.digestFunctions[i]);
                                writer.ldelim();
                            }
                            if (message.actionCacheUpdateCapabilities != null && Object.hasOwnProperty.call(message, "actionCacheUpdateCapabilities"))
                                $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities.encode(message.actionCacheUpdateCapabilities, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.cachePriorityCapabilities != null && Object.hasOwnProperty.call(message, "cachePriorityCapabilities"))
                                $root.build.bazel.remote.execution.v2.PriorityCapabilities.encode(message.cachePriorityCapabilities, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.maxBatchTotalSizeBytes != null && Object.hasOwnProperty.call(message, "maxBatchTotalSizeBytes"))
                                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.maxBatchTotalSizeBytes);
                            if (message.symlinkAbsolutePathStrategy != null && Object.hasOwnProperty.call(message, "symlinkAbsolutePathStrategy"))
                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.symlinkAbsolutePathStrategy);
                            if (message.supportedCompressors != null && message.supportedCompressors.length) {
                                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                                for (let i = 0; i < message.supportedCompressors.length; ++i)
                                    writer.int32(message.supportedCompressors[i]);
                                writer.ldelim();
                            }
                            if (message.supportedBatchUpdateCompressors != null && message.supportedBatchUpdateCompressors.length) {
                                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                                for (let i = 0; i < message.supportedBatchUpdateCompressors.length; ++i)
                                    writer.int32(message.supportedBatchUpdateCompressors[i]);
                                writer.ldelim();
                            }
                            return writer;
                        };

                        /**
                         * Encodes the specified CacheCapabilities message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.CacheCapabilities.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.ICacheCapabilities} message CacheCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CacheCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a CacheCapabilities message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.CacheCapabilities} CacheCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CacheCapabilities.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.CacheCapabilities();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        if (!(message.digestFunctions && message.digestFunctions.length))
                                            message.digestFunctions = [];
                                        if ((tag & 7) === 2) {
                                            let end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.digestFunctions.push(reader.int32());
                                        } else
                                            message.digestFunctions.push(reader.int32());
                                        break;
                                    }
                                case 2: {
                                        message.actionCacheUpdateCapabilities = $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.cachePriorityCapabilities = $root.build.bazel.remote.execution.v2.PriorityCapabilities.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        message.maxBatchTotalSizeBytes = reader.int64();
                                        break;
                                    }
                                case 5: {
                                        message.symlinkAbsolutePathStrategy = reader.int32();
                                        break;
                                    }
                                case 6: {
                                        if (!(message.supportedCompressors && message.supportedCompressors.length))
                                            message.supportedCompressors = [];
                                        if ((tag & 7) === 2) {
                                            let end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.supportedCompressors.push(reader.int32());
                                        } else
                                            message.supportedCompressors.push(reader.int32());
                                        break;
                                    }
                                case 7: {
                                        if (!(message.supportedBatchUpdateCompressors && message.supportedBatchUpdateCompressors.length))
                                            message.supportedBatchUpdateCompressors = [];
                                        if ((tag & 7) === 2) {
                                            let end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.supportedBatchUpdateCompressors.push(reader.int32());
                                        } else
                                            message.supportedBatchUpdateCompressors.push(reader.int32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a CacheCapabilities message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.CacheCapabilities} CacheCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CacheCapabilities.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a CacheCapabilities message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CacheCapabilities.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.digestFunctions != null && message.hasOwnProperty("digestFunctions")) {
                                if (!Array.isArray(message.digestFunctions))
                                    return "digestFunctions: array expected";
                                for (let i = 0; i < message.digestFunctions.length; ++i)
                                    switch (message.digestFunctions[i]) {
                                    default:
                                        return "digestFunctions: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 7:
                                    case 8:
                                    case 9:
                                        break;
                                    }
                            }
                            if (message.actionCacheUpdateCapabilities != null && message.hasOwnProperty("actionCacheUpdateCapabilities")) {
                                let error = $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities.verify(message.actionCacheUpdateCapabilities);
                                if (error)
                                    return "actionCacheUpdateCapabilities." + error;
                            }
                            if (message.cachePriorityCapabilities != null && message.hasOwnProperty("cachePriorityCapabilities")) {
                                let error = $root.build.bazel.remote.execution.v2.PriorityCapabilities.verify(message.cachePriorityCapabilities);
                                if (error)
                                    return "cachePriorityCapabilities." + error;
                            }
                            if (message.maxBatchTotalSizeBytes != null && message.hasOwnProperty("maxBatchTotalSizeBytes"))
                                if (!$util.isInteger(message.maxBatchTotalSizeBytes) && !(message.maxBatchTotalSizeBytes && $util.isInteger(message.maxBatchTotalSizeBytes.low) && $util.isInteger(message.maxBatchTotalSizeBytes.high)))
                                    return "maxBatchTotalSizeBytes: integer|Long expected";
                            if (message.symlinkAbsolutePathStrategy != null && message.hasOwnProperty("symlinkAbsolutePathStrategy"))
                                switch (message.symlinkAbsolutePathStrategy) {
                                default:
                                    return "symlinkAbsolutePathStrategy: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.supportedCompressors != null && message.hasOwnProperty("supportedCompressors")) {
                                if (!Array.isArray(message.supportedCompressors))
                                    return "supportedCompressors: array expected";
                                for (let i = 0; i < message.supportedCompressors.length; ++i)
                                    switch (message.supportedCompressors[i]) {
                                    default:
                                        return "supportedCompressors: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                        break;
                                    }
                            }
                            if (message.supportedBatchUpdateCompressors != null && message.hasOwnProperty("supportedBatchUpdateCompressors")) {
                                if (!Array.isArray(message.supportedBatchUpdateCompressors))
                                    return "supportedBatchUpdateCompressors: array expected";
                                for (let i = 0; i < message.supportedBatchUpdateCompressors.length; ++i)
                                    switch (message.supportedBatchUpdateCompressors[i]) {
                                    default:
                                        return "supportedBatchUpdateCompressors: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                        break;
                                    }
                            }
                            return null;
                        };

                        /**
                         * Creates a CacheCapabilities message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.CacheCapabilities} CacheCapabilities
                         */
                        CacheCapabilities.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.CacheCapabilities)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.CacheCapabilities();
                            if (object.digestFunctions) {
                                if (!Array.isArray(object.digestFunctions))
                                    throw TypeError(".build.bazel.remote.execution.v2.CacheCapabilities.digestFunctions: array expected");
                                message.digestFunctions = [];
                                for (let i = 0; i < object.digestFunctions.length; ++i)
                                    switch (object.digestFunctions[i]) {
                                    default:
                                        if (typeof object.digestFunctions[i] === "number") {
                                            message.digestFunctions[i] = object.digestFunctions[i];
                                            break;
                                        }
                                    case "UNKNOWN":
                                    case 0:
                                        message.digestFunctions[i] = 0;
                                        break;
                                    case "SHA256":
                                    case 1:
                                        message.digestFunctions[i] = 1;
                                        break;
                                    case "SHA1":
                                    case 2:
                                        message.digestFunctions[i] = 2;
                                        break;
                                    case "MD5":
                                    case 3:
                                        message.digestFunctions[i] = 3;
                                        break;
                                    case "VSO":
                                    case 4:
                                        message.digestFunctions[i] = 4;
                                        break;
                                    case "SHA384":
                                    case 5:
                                        message.digestFunctions[i] = 5;
                                        break;
                                    case "SHA512":
                                    case 6:
                                        message.digestFunctions[i] = 6;
                                        break;
                                    case "MURMUR3":
                                    case 7:
                                        message.digestFunctions[i] = 7;
                                        break;
                                    case "SHA256TREE":
                                    case 8:
                                        message.digestFunctions[i] = 8;
                                        break;
                                    case "BLAKE3":
                                    case 9:
                                        message.digestFunctions[i] = 9;
                                        break;
                                    }
                            }
                            if (object.actionCacheUpdateCapabilities != null) {
                                if (typeof object.actionCacheUpdateCapabilities !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.CacheCapabilities.actionCacheUpdateCapabilities: object expected");
                                message.actionCacheUpdateCapabilities = $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities.fromObject(object.actionCacheUpdateCapabilities);
                            }
                            if (object.cachePriorityCapabilities != null) {
                                if (typeof object.cachePriorityCapabilities !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.CacheCapabilities.cachePriorityCapabilities: object expected");
                                message.cachePriorityCapabilities = $root.build.bazel.remote.execution.v2.PriorityCapabilities.fromObject(object.cachePriorityCapabilities);
                            }
                            if (object.maxBatchTotalSizeBytes != null)
                                if ($util.Long)
                                    (message.maxBatchTotalSizeBytes = $util.Long.fromValue(object.maxBatchTotalSizeBytes)).unsigned = false;
                                else if (typeof object.maxBatchTotalSizeBytes === "string")
                                    message.maxBatchTotalSizeBytes = parseInt(object.maxBatchTotalSizeBytes, 10);
                                else if (typeof object.maxBatchTotalSizeBytes === "number")
                                    message.maxBatchTotalSizeBytes = object.maxBatchTotalSizeBytes;
                                else if (typeof object.maxBatchTotalSizeBytes === "object")
                                    message.maxBatchTotalSizeBytes = new $util.LongBits(object.maxBatchTotalSizeBytes.low >>> 0, object.maxBatchTotalSizeBytes.high >>> 0).toNumber();
                            switch (object.symlinkAbsolutePathStrategy) {
                            default:
                                if (typeof object.symlinkAbsolutePathStrategy === "number") {
                                    message.symlinkAbsolutePathStrategy = object.symlinkAbsolutePathStrategy;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.symlinkAbsolutePathStrategy = 0;
                                break;
                            case "DISALLOWED":
                            case 1:
                                message.symlinkAbsolutePathStrategy = 1;
                                break;
                            case "ALLOWED":
                            case 2:
                                message.symlinkAbsolutePathStrategy = 2;
                                break;
                            }
                            if (object.supportedCompressors) {
                                if (!Array.isArray(object.supportedCompressors))
                                    throw TypeError(".build.bazel.remote.execution.v2.CacheCapabilities.supportedCompressors: array expected");
                                message.supportedCompressors = [];
                                for (let i = 0; i < object.supportedCompressors.length; ++i)
                                    switch (object.supportedCompressors[i]) {
                                    default:
                                        if (typeof object.supportedCompressors[i] === "number") {
                                            message.supportedCompressors[i] = object.supportedCompressors[i];
                                            break;
                                        }
                                    case "IDENTITY":
                                    case 0:
                                        message.supportedCompressors[i] = 0;
                                        break;
                                    case "ZSTD":
                                    case 1:
                                        message.supportedCompressors[i] = 1;
                                        break;
                                    case "DEFLATE":
                                    case 2:
                                        message.supportedCompressors[i] = 2;
                                        break;
                                    case "BROTLI":
                                    case 3:
                                        message.supportedCompressors[i] = 3;
                                        break;
                                    }
                            }
                            if (object.supportedBatchUpdateCompressors) {
                                if (!Array.isArray(object.supportedBatchUpdateCompressors))
                                    throw TypeError(".build.bazel.remote.execution.v2.CacheCapabilities.supportedBatchUpdateCompressors: array expected");
                                message.supportedBatchUpdateCompressors = [];
                                for (let i = 0; i < object.supportedBatchUpdateCompressors.length; ++i)
                                    switch (object.supportedBatchUpdateCompressors[i]) {
                                    default:
                                        if (typeof object.supportedBatchUpdateCompressors[i] === "number") {
                                            message.supportedBatchUpdateCompressors[i] = object.supportedBatchUpdateCompressors[i];
                                            break;
                                        }
                                    case "IDENTITY":
                                    case 0:
                                        message.supportedBatchUpdateCompressors[i] = 0;
                                        break;
                                    case "ZSTD":
                                    case 1:
                                        message.supportedBatchUpdateCompressors[i] = 1;
                                        break;
                                    case "DEFLATE":
                                    case 2:
                                        message.supportedBatchUpdateCompressors[i] = 2;
                                        break;
                                    case "BROTLI":
                                    case 3:
                                        message.supportedBatchUpdateCompressors[i] = 3;
                                        break;
                                    }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a CacheCapabilities message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.CacheCapabilities} message CacheCapabilities
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CacheCapabilities.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.digestFunctions = [];
                                object.supportedCompressors = [];
                                object.supportedBatchUpdateCompressors = [];
                            }
                            if (options.defaults) {
                                object.actionCacheUpdateCapabilities = null;
                                object.cachePriorityCapabilities = null;
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.maxBatchTotalSizeBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.maxBatchTotalSizeBytes = options.longs === String ? "0" : 0;
                                object.symlinkAbsolutePathStrategy = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.digestFunctions && message.digestFunctions.length) {
                                object.digestFunctions = [];
                                for (let j = 0; j < message.digestFunctions.length; ++j)
                                    object.digestFunctions[j] = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunctions[j]] === undefined ? message.digestFunctions[j] : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunctions[j]] : message.digestFunctions[j];
                            }
                            if (message.actionCacheUpdateCapabilities != null && message.hasOwnProperty("actionCacheUpdateCapabilities"))
                                object.actionCacheUpdateCapabilities = $root.build.bazel.remote.execution.v2.ActionCacheUpdateCapabilities.toObject(message.actionCacheUpdateCapabilities, options);
                            if (message.cachePriorityCapabilities != null && message.hasOwnProperty("cachePriorityCapabilities"))
                                object.cachePriorityCapabilities = $root.build.bazel.remote.execution.v2.PriorityCapabilities.toObject(message.cachePriorityCapabilities, options);
                            if (message.maxBatchTotalSizeBytes != null && message.hasOwnProperty("maxBatchTotalSizeBytes"))
                                if (typeof message.maxBatchTotalSizeBytes === "number")
                                    object.maxBatchTotalSizeBytes = options.longs === String ? String(message.maxBatchTotalSizeBytes) : message.maxBatchTotalSizeBytes;
                                else
                                    object.maxBatchTotalSizeBytes = options.longs === String ? $util.Long.prototype.toString.call(message.maxBatchTotalSizeBytes) : options.longs === Number ? new $util.LongBits(message.maxBatchTotalSizeBytes.low >>> 0, message.maxBatchTotalSizeBytes.high >>> 0).toNumber() : message.maxBatchTotalSizeBytes;
                            if (message.symlinkAbsolutePathStrategy != null && message.hasOwnProperty("symlinkAbsolutePathStrategy"))
                                object.symlinkAbsolutePathStrategy = options.enums === String ? $root.build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy.Value[message.symlinkAbsolutePathStrategy] === undefined ? message.symlinkAbsolutePathStrategy : $root.build.bazel.remote.execution.v2.SymlinkAbsolutePathStrategy.Value[message.symlinkAbsolutePathStrategy] : message.symlinkAbsolutePathStrategy;
                            if (message.supportedCompressors && message.supportedCompressors.length) {
                                object.supportedCompressors = [];
                                for (let j = 0; j < message.supportedCompressors.length; ++j)
                                    object.supportedCompressors[j] = options.enums === String ? $root.build.bazel.remote.execution.v2.Compressor.Value[message.supportedCompressors[j]] === undefined ? message.supportedCompressors[j] : $root.build.bazel.remote.execution.v2.Compressor.Value[message.supportedCompressors[j]] : message.supportedCompressors[j];
                            }
                            if (message.supportedBatchUpdateCompressors && message.supportedBatchUpdateCompressors.length) {
                                object.supportedBatchUpdateCompressors = [];
                                for (let j = 0; j < message.supportedBatchUpdateCompressors.length; ++j)
                                    object.supportedBatchUpdateCompressors[j] = options.enums === String ? $root.build.bazel.remote.execution.v2.Compressor.Value[message.supportedBatchUpdateCompressors[j]] === undefined ? message.supportedBatchUpdateCompressors[j] : $root.build.bazel.remote.execution.v2.Compressor.Value[message.supportedBatchUpdateCompressors[j]] : message.supportedBatchUpdateCompressors[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this CacheCapabilities to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CacheCapabilities.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for CacheCapabilities
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.CacheCapabilities
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        CacheCapabilities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.CacheCapabilities";
                        };

                        return CacheCapabilities;
                    })();

                    v2.ExecutionCapabilities = (function() {

                        /**
                         * Properties of an ExecutionCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IExecutionCapabilities
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] ExecutionCapabilities digestFunction
                         * @property {boolean|null} [execEnabled] ExecutionCapabilities execEnabled
                         * @property {build.bazel.remote.execution.v2.IPriorityCapabilities|null} [executionPriorityCapabilities] ExecutionCapabilities executionPriorityCapabilities
                         * @property {Array.<string>|null} [supportedNodeProperties] ExecutionCapabilities supportedNodeProperties
                         * @property {Array.<build.bazel.remote.execution.v2.DigestFunction.Value>|null} [digestFunctions] ExecutionCapabilities digestFunctions
                         */

                        /**
                         * Constructs a new ExecutionCapabilities.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents an ExecutionCapabilities.
                         * @implements IExecutionCapabilities
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IExecutionCapabilities=} [properties] Properties to set
                         */
                        function ExecutionCapabilities(properties) {
                            this.supportedNodeProperties = [];
                            this.digestFunctions = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ExecutionCapabilities digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @instance
                         */
                        ExecutionCapabilities.prototype.digestFunction = 0;

                        /**
                         * ExecutionCapabilities execEnabled.
                         * @member {boolean} execEnabled
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @instance
                         */
                        ExecutionCapabilities.prototype.execEnabled = false;

                        /**
                         * ExecutionCapabilities executionPriorityCapabilities.
                         * @member {build.bazel.remote.execution.v2.IPriorityCapabilities|null|undefined} executionPriorityCapabilities
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @instance
                         */
                        ExecutionCapabilities.prototype.executionPriorityCapabilities = null;

                        /**
                         * ExecutionCapabilities supportedNodeProperties.
                         * @member {Array.<string>} supportedNodeProperties
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @instance
                         */
                        ExecutionCapabilities.prototype.supportedNodeProperties = $util.emptyArray;

                        /**
                         * ExecutionCapabilities digestFunctions.
                         * @member {Array.<build.bazel.remote.execution.v2.DigestFunction.Value>} digestFunctions
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @instance
                         */
                        ExecutionCapabilities.prototype.digestFunctions = $util.emptyArray;

                        /**
                         * Creates a new ExecutionCapabilities instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionCapabilities=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ExecutionCapabilities} ExecutionCapabilities instance
                         */
                        ExecutionCapabilities.create = function create(properties) {
                            return new ExecutionCapabilities(properties);
                        };

                        /**
                         * Encodes the specified ExecutionCapabilities message. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutionCapabilities.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionCapabilities} message ExecutionCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutionCapabilities.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.digestFunction);
                            if (message.execEnabled != null && Object.hasOwnProperty.call(message, "execEnabled"))
                                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.execEnabled);
                            if (message.executionPriorityCapabilities != null && Object.hasOwnProperty.call(message, "executionPriorityCapabilities"))
                                $root.build.bazel.remote.execution.v2.PriorityCapabilities.encode(message.executionPriorityCapabilities, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.supportedNodeProperties != null && message.supportedNodeProperties.length)
                                for (let i = 0; i < message.supportedNodeProperties.length; ++i)
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.supportedNodeProperties[i]);
                            if (message.digestFunctions != null && message.digestFunctions.length) {
                                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                                for (let i = 0; i < message.digestFunctions.length; ++i)
                                    writer.int32(message.digestFunctions[i]);
                                writer.ldelim();
                            }
                            return writer;
                        };

                        /**
                         * Encodes the specified ExecutionCapabilities message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ExecutionCapabilities.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.IExecutionCapabilities} message ExecutionCapabilities message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ExecutionCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an ExecutionCapabilities message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ExecutionCapabilities} ExecutionCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutionCapabilities.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ExecutionCapabilities();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                case 2: {
                                        message.execEnabled = reader.bool();
                                        break;
                                    }
                                case 3: {
                                        message.executionPriorityCapabilities = $root.build.bazel.remote.execution.v2.PriorityCapabilities.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        if (!(message.supportedNodeProperties && message.supportedNodeProperties.length))
                                            message.supportedNodeProperties = [];
                                        message.supportedNodeProperties.push(reader.string());
                                        break;
                                    }
                                case 5: {
                                        if (!(message.digestFunctions && message.digestFunctions.length))
                                            message.digestFunctions = [];
                                        if ((tag & 7) === 2) {
                                            let end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.digestFunctions.push(reader.int32());
                                        } else
                                            message.digestFunctions.push(reader.int32());
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an ExecutionCapabilities message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ExecutionCapabilities} ExecutionCapabilities
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ExecutionCapabilities.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an ExecutionCapabilities message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ExecutionCapabilities.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            if (message.execEnabled != null && message.hasOwnProperty("execEnabled"))
                                if (typeof message.execEnabled !== "boolean")
                                    return "execEnabled: boolean expected";
                            if (message.executionPriorityCapabilities != null && message.hasOwnProperty("executionPriorityCapabilities")) {
                                let error = $root.build.bazel.remote.execution.v2.PriorityCapabilities.verify(message.executionPriorityCapabilities);
                                if (error)
                                    return "executionPriorityCapabilities." + error;
                            }
                            if (message.supportedNodeProperties != null && message.hasOwnProperty("supportedNodeProperties")) {
                                if (!Array.isArray(message.supportedNodeProperties))
                                    return "supportedNodeProperties: array expected";
                                for (let i = 0; i < message.supportedNodeProperties.length; ++i)
                                    if (!$util.isString(message.supportedNodeProperties[i]))
                                        return "supportedNodeProperties: string[] expected";
                            }
                            if (message.digestFunctions != null && message.hasOwnProperty("digestFunctions")) {
                                if (!Array.isArray(message.digestFunctions))
                                    return "digestFunctions: array expected";
                                for (let i = 0; i < message.digestFunctions.length; ++i)
                                    switch (message.digestFunctions[i]) {
                                    default:
                                        return "digestFunctions: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 7:
                                    case 8:
                                    case 9:
                                        break;
                                    }
                            }
                            return null;
                        };

                        /**
                         * Creates an ExecutionCapabilities message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ExecutionCapabilities} ExecutionCapabilities
                         */
                        ExecutionCapabilities.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ExecutionCapabilities)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ExecutionCapabilities();
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            if (object.execEnabled != null)
                                message.execEnabled = Boolean(object.execEnabled);
                            if (object.executionPriorityCapabilities != null) {
                                if (typeof object.executionPriorityCapabilities !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutionCapabilities.executionPriorityCapabilities: object expected");
                                message.executionPriorityCapabilities = $root.build.bazel.remote.execution.v2.PriorityCapabilities.fromObject(object.executionPriorityCapabilities);
                            }
                            if (object.supportedNodeProperties) {
                                if (!Array.isArray(object.supportedNodeProperties))
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutionCapabilities.supportedNodeProperties: array expected");
                                message.supportedNodeProperties = [];
                                for (let i = 0; i < object.supportedNodeProperties.length; ++i)
                                    message.supportedNodeProperties[i] = String(object.supportedNodeProperties[i]);
                            }
                            if (object.digestFunctions) {
                                if (!Array.isArray(object.digestFunctions))
                                    throw TypeError(".build.bazel.remote.execution.v2.ExecutionCapabilities.digestFunctions: array expected");
                                message.digestFunctions = [];
                                for (let i = 0; i < object.digestFunctions.length; ++i)
                                    switch (object.digestFunctions[i]) {
                                    default:
                                        if (typeof object.digestFunctions[i] === "number") {
                                            message.digestFunctions[i] = object.digestFunctions[i];
                                            break;
                                        }
                                    case "UNKNOWN":
                                    case 0:
                                        message.digestFunctions[i] = 0;
                                        break;
                                    case "SHA256":
                                    case 1:
                                        message.digestFunctions[i] = 1;
                                        break;
                                    case "SHA1":
                                    case 2:
                                        message.digestFunctions[i] = 2;
                                        break;
                                    case "MD5":
                                    case 3:
                                        message.digestFunctions[i] = 3;
                                        break;
                                    case "VSO":
                                    case 4:
                                        message.digestFunctions[i] = 4;
                                        break;
                                    case "SHA384":
                                    case 5:
                                        message.digestFunctions[i] = 5;
                                        break;
                                    case "SHA512":
                                    case 6:
                                        message.digestFunctions[i] = 6;
                                        break;
                                    case "MURMUR3":
                                    case 7:
                                        message.digestFunctions[i] = 7;
                                        break;
                                    case "SHA256TREE":
                                    case 8:
                                        message.digestFunctions[i] = 8;
                                        break;
                                    case "BLAKE3":
                                    case 9:
                                        message.digestFunctions[i] = 9;
                                        break;
                                    }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an ExecutionCapabilities message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {build.bazel.remote.execution.v2.ExecutionCapabilities} message ExecutionCapabilities
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ExecutionCapabilities.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.supportedNodeProperties = [];
                                object.digestFunctions = [];
                            }
                            if (options.defaults) {
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                                object.execEnabled = false;
                                object.executionPriorityCapabilities = null;
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            if (message.execEnabled != null && message.hasOwnProperty("execEnabled"))
                                object.execEnabled = message.execEnabled;
                            if (message.executionPriorityCapabilities != null && message.hasOwnProperty("executionPriorityCapabilities"))
                                object.executionPriorityCapabilities = $root.build.bazel.remote.execution.v2.PriorityCapabilities.toObject(message.executionPriorityCapabilities, options);
                            if (message.supportedNodeProperties && message.supportedNodeProperties.length) {
                                object.supportedNodeProperties = [];
                                for (let j = 0; j < message.supportedNodeProperties.length; ++j)
                                    object.supportedNodeProperties[j] = message.supportedNodeProperties[j];
                            }
                            if (message.digestFunctions && message.digestFunctions.length) {
                                object.digestFunctions = [];
                                for (let j = 0; j < message.digestFunctions.length; ++j)
                                    object.digestFunctions[j] = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunctions[j]] === undefined ? message.digestFunctions[j] : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunctions[j]] : message.digestFunctions[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this ExecutionCapabilities to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ExecutionCapabilities.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ExecutionCapabilities
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ExecutionCapabilities
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ExecutionCapabilities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ExecutionCapabilities";
                        };

                        return ExecutionCapabilities;
                    })();

                    v2.ToolDetails = (function() {

                        /**
                         * Properties of a ToolDetails.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IToolDetails
                         * @property {string|null} [toolName] ToolDetails toolName
                         * @property {string|null} [toolVersion] ToolDetails toolVersion
                         */

                        /**
                         * Constructs a new ToolDetails.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a ToolDetails.
                         * @implements IToolDetails
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IToolDetails=} [properties] Properties to set
                         */
                        function ToolDetails(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ToolDetails toolName.
                         * @member {string} toolName
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @instance
                         */
                        ToolDetails.prototype.toolName = "";

                        /**
                         * ToolDetails toolVersion.
                         * @member {string} toolVersion
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @instance
                         */
                        ToolDetails.prototype.toolVersion = "";

                        /**
                         * Creates a new ToolDetails instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {build.bazel.remote.execution.v2.IToolDetails=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.ToolDetails} ToolDetails instance
                         */
                        ToolDetails.create = function create(properties) {
                            return new ToolDetails(properties);
                        };

                        /**
                         * Encodes the specified ToolDetails message. Does not implicitly {@link build.bazel.remote.execution.v2.ToolDetails.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {build.bazel.remote.execution.v2.IToolDetails} message ToolDetails message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ToolDetails.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.toolName != null && Object.hasOwnProperty.call(message, "toolName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.toolName);
                            if (message.toolVersion != null && Object.hasOwnProperty.call(message, "toolVersion"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.toolVersion);
                            return writer;
                        };

                        /**
                         * Encodes the specified ToolDetails message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.ToolDetails.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {build.bazel.remote.execution.v2.IToolDetails} message ToolDetails message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        ToolDetails.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a ToolDetails message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.ToolDetails} ToolDetails
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ToolDetails.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.ToolDetails();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.toolName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.toolVersion = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a ToolDetails message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.ToolDetails} ToolDetails
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        ToolDetails.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a ToolDetails message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ToolDetails.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.toolName != null && message.hasOwnProperty("toolName"))
                                if (!$util.isString(message.toolName))
                                    return "toolName: string expected";
                            if (message.toolVersion != null && message.hasOwnProperty("toolVersion"))
                                if (!$util.isString(message.toolVersion))
                                    return "toolVersion: string expected";
                            return null;
                        };

                        /**
                         * Creates a ToolDetails message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.ToolDetails} ToolDetails
                         */
                        ToolDetails.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.ToolDetails)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.ToolDetails();
                            if (object.toolName != null)
                                message.toolName = String(object.toolName);
                            if (object.toolVersion != null)
                                message.toolVersion = String(object.toolVersion);
                            return message;
                        };

                        /**
                         * Creates a plain object from a ToolDetails message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {build.bazel.remote.execution.v2.ToolDetails} message ToolDetails
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ToolDetails.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.toolName = "";
                                object.toolVersion = "";
                            }
                            if (message.toolName != null && message.hasOwnProperty("toolName"))
                                object.toolName = message.toolName;
                            if (message.toolVersion != null && message.hasOwnProperty("toolVersion"))
                                object.toolVersion = message.toolVersion;
                            return object;
                        };

                        /**
                         * Converts this ToolDetails to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ToolDetails.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for ToolDetails
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.ToolDetails
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        ToolDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.ToolDetails";
                        };

                        return ToolDetails;
                    })();

                    v2.RequestMetadata = (function() {

                        /**
                         * Properties of a RequestMetadata.
                         * @memberof build.bazel.remote.execution.v2
                         * @interface IRequestMetadata
                         * @property {build.bazel.remote.execution.v2.IToolDetails|null} [toolDetails] RequestMetadata toolDetails
                         * @property {string|null} [actionId] RequestMetadata actionId
                         * @property {string|null} [toolInvocationId] RequestMetadata toolInvocationId
                         * @property {string|null} [correlatedInvocationsId] RequestMetadata correlatedInvocationsId
                         * @property {string|null} [actionMnemonic] RequestMetadata actionMnemonic
                         * @property {string|null} [targetId] RequestMetadata targetId
                         * @property {string|null} [configurationId] RequestMetadata configurationId
                         */

                        /**
                         * Constructs a new RequestMetadata.
                         * @memberof build.bazel.remote.execution.v2
                         * @classdesc Represents a RequestMetadata.
                         * @implements IRequestMetadata
                         * @constructor
                         * @param {build.bazel.remote.execution.v2.IRequestMetadata=} [properties] Properties to set
                         */
                        function RequestMetadata(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * RequestMetadata toolDetails.
                         * @member {build.bazel.remote.execution.v2.IToolDetails|null|undefined} toolDetails
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         */
                        RequestMetadata.prototype.toolDetails = null;

                        /**
                         * RequestMetadata actionId.
                         * @member {string} actionId
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         */
                        RequestMetadata.prototype.actionId = "";

                        /**
                         * RequestMetadata toolInvocationId.
                         * @member {string} toolInvocationId
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         */
                        RequestMetadata.prototype.toolInvocationId = "";

                        /**
                         * RequestMetadata correlatedInvocationsId.
                         * @member {string} correlatedInvocationsId
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         */
                        RequestMetadata.prototype.correlatedInvocationsId = "";

                        /**
                         * RequestMetadata actionMnemonic.
                         * @member {string} actionMnemonic
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         */
                        RequestMetadata.prototype.actionMnemonic = "";

                        /**
                         * RequestMetadata targetId.
                         * @member {string} targetId
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         */
                        RequestMetadata.prototype.targetId = "";

                        /**
                         * RequestMetadata configurationId.
                         * @member {string} configurationId
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         */
                        RequestMetadata.prototype.configurationId = "";

                        /**
                         * Creates a new RequestMetadata instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IRequestMetadata=} [properties] Properties to set
                         * @returns {build.bazel.remote.execution.v2.RequestMetadata} RequestMetadata instance
                         */
                        RequestMetadata.create = function create(properties) {
                            return new RequestMetadata(properties);
                        };

                        /**
                         * Encodes the specified RequestMetadata message. Does not implicitly {@link build.bazel.remote.execution.v2.RequestMetadata.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IRequestMetadata} message RequestMetadata message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RequestMetadata.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.toolDetails != null && Object.hasOwnProperty.call(message, "toolDetails"))
                                $root.build.bazel.remote.execution.v2.ToolDetails.encode(message.toolDetails, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.actionId != null && Object.hasOwnProperty.call(message, "actionId"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.actionId);
                            if (message.toolInvocationId != null && Object.hasOwnProperty.call(message, "toolInvocationId"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.toolInvocationId);
                            if (message.correlatedInvocationsId != null && Object.hasOwnProperty.call(message, "correlatedInvocationsId"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.correlatedInvocationsId);
                            if (message.actionMnemonic != null && Object.hasOwnProperty.call(message, "actionMnemonic"))
                                writer.uint32(/* id 5, wireType 2 =*/42).string(message.actionMnemonic);
                            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.targetId);
                            if (message.configurationId != null && Object.hasOwnProperty.call(message, "configurationId"))
                                writer.uint32(/* id 7, wireType 2 =*/58).string(message.configurationId);
                            return writer;
                        };

                        /**
                         * Encodes the specified RequestMetadata message, length delimited. Does not implicitly {@link build.bazel.remote.execution.v2.RequestMetadata.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.IRequestMetadata} message RequestMetadata message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        RequestMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a RequestMetadata message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.execution.v2.RequestMetadata} RequestMetadata
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RequestMetadata.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.execution.v2.RequestMetadata();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.toolDetails = $root.build.bazel.remote.execution.v2.ToolDetails.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.actionId = reader.string();
                                        break;
                                    }
                                case 3: {
                                        message.toolInvocationId = reader.string();
                                        break;
                                    }
                                case 4: {
                                        message.correlatedInvocationsId = reader.string();
                                        break;
                                    }
                                case 5: {
                                        message.actionMnemonic = reader.string();
                                        break;
                                    }
                                case 6: {
                                        message.targetId = reader.string();
                                        break;
                                    }
                                case 7: {
                                        message.configurationId = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a RequestMetadata message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.execution.v2.RequestMetadata} RequestMetadata
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        RequestMetadata.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a RequestMetadata message.
                         * @function verify
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RequestMetadata.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.toolDetails != null && message.hasOwnProperty("toolDetails")) {
                                let error = $root.build.bazel.remote.execution.v2.ToolDetails.verify(message.toolDetails);
                                if (error)
                                    return "toolDetails." + error;
                            }
                            if (message.actionId != null && message.hasOwnProperty("actionId"))
                                if (!$util.isString(message.actionId))
                                    return "actionId: string expected";
                            if (message.toolInvocationId != null && message.hasOwnProperty("toolInvocationId"))
                                if (!$util.isString(message.toolInvocationId))
                                    return "toolInvocationId: string expected";
                            if (message.correlatedInvocationsId != null && message.hasOwnProperty("correlatedInvocationsId"))
                                if (!$util.isString(message.correlatedInvocationsId))
                                    return "correlatedInvocationsId: string expected";
                            if (message.actionMnemonic != null && message.hasOwnProperty("actionMnemonic"))
                                if (!$util.isString(message.actionMnemonic))
                                    return "actionMnemonic: string expected";
                            if (message.targetId != null && message.hasOwnProperty("targetId"))
                                if (!$util.isString(message.targetId))
                                    return "targetId: string expected";
                            if (message.configurationId != null && message.hasOwnProperty("configurationId"))
                                if (!$util.isString(message.configurationId))
                                    return "configurationId: string expected";
                            return null;
                        };

                        /**
                         * Creates a RequestMetadata message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.execution.v2.RequestMetadata} RequestMetadata
                         */
                        RequestMetadata.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.execution.v2.RequestMetadata)
                                return object;
                            let message = new $root.build.bazel.remote.execution.v2.RequestMetadata();
                            if (object.toolDetails != null) {
                                if (typeof object.toolDetails !== "object")
                                    throw TypeError(".build.bazel.remote.execution.v2.RequestMetadata.toolDetails: object expected");
                                message.toolDetails = $root.build.bazel.remote.execution.v2.ToolDetails.fromObject(object.toolDetails);
                            }
                            if (object.actionId != null)
                                message.actionId = String(object.actionId);
                            if (object.toolInvocationId != null)
                                message.toolInvocationId = String(object.toolInvocationId);
                            if (object.correlatedInvocationsId != null)
                                message.correlatedInvocationsId = String(object.correlatedInvocationsId);
                            if (object.actionMnemonic != null)
                                message.actionMnemonic = String(object.actionMnemonic);
                            if (object.targetId != null)
                                message.targetId = String(object.targetId);
                            if (object.configurationId != null)
                                message.configurationId = String(object.configurationId);
                            return message;
                        };

                        /**
                         * Creates a plain object from a RequestMetadata message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {build.bazel.remote.execution.v2.RequestMetadata} message RequestMetadata
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RequestMetadata.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.toolDetails = null;
                                object.actionId = "";
                                object.toolInvocationId = "";
                                object.correlatedInvocationsId = "";
                                object.actionMnemonic = "";
                                object.targetId = "";
                                object.configurationId = "";
                            }
                            if (message.toolDetails != null && message.hasOwnProperty("toolDetails"))
                                object.toolDetails = $root.build.bazel.remote.execution.v2.ToolDetails.toObject(message.toolDetails, options);
                            if (message.actionId != null && message.hasOwnProperty("actionId"))
                                object.actionId = message.actionId;
                            if (message.toolInvocationId != null && message.hasOwnProperty("toolInvocationId"))
                                object.toolInvocationId = message.toolInvocationId;
                            if (message.correlatedInvocationsId != null && message.hasOwnProperty("correlatedInvocationsId"))
                                object.correlatedInvocationsId = message.correlatedInvocationsId;
                            if (message.actionMnemonic != null && message.hasOwnProperty("actionMnemonic"))
                                object.actionMnemonic = message.actionMnemonic;
                            if (message.targetId != null && message.hasOwnProperty("targetId"))
                                object.targetId = message.targetId;
                            if (message.configurationId != null && message.hasOwnProperty("configurationId"))
                                object.configurationId = message.configurationId;
                            return object;
                        };

                        /**
                         * Converts this RequestMetadata to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RequestMetadata.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for RequestMetadata
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.execution.v2.RequestMetadata
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        RequestMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.execution.v2.RequestMetadata";
                        };

                        return RequestMetadata;
                    })();

                    return v2;
                })();

                return execution;
            })();

            remote.asset = (function() {

                /**
                 * Namespace asset.
                 * @memberof build.bazel.remote
                 * @namespace
                 */
                const asset = {};

                asset.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof build.bazel.remote.asset
                     * @namespace
                     */
                    const v1 = {};

                    v1.Qualifier = (function() {

                        /**
                         * Properties of a Qualifier.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IQualifier
                         * @property {string|null} [name] Qualifier name
                         * @property {string|null} [value] Qualifier value
                         */

                        /**
                         * Constructs a new Qualifier.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a Qualifier.
                         * @implements IQualifier
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IQualifier=} [properties] Properties to set
                         */
                        function Qualifier(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Qualifier name.
                         * @member {string} name
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @instance
                         */
                        Qualifier.prototype.name = "";

                        /**
                         * Qualifier value.
                         * @member {string} value
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @instance
                         */
                        Qualifier.prototype.value = "";

                        /**
                         * Creates a new Qualifier instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {build.bazel.remote.asset.v1.IQualifier=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.Qualifier} Qualifier instance
                         */
                        Qualifier.create = function create(properties) {
                            return new Qualifier(properties);
                        };

                        /**
                         * Encodes the specified Qualifier message. Does not implicitly {@link build.bazel.remote.asset.v1.Qualifier.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {build.bazel.remote.asset.v1.IQualifier} message Qualifier message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Qualifier.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Qualifier message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.Qualifier.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {build.bazel.remote.asset.v1.IQualifier} message Qualifier message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Qualifier.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Qualifier message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.Qualifier} Qualifier
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Qualifier.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.Qualifier();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.name = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.value = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Qualifier message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.Qualifier} Qualifier
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Qualifier.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Qualifier message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Qualifier.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a Qualifier message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.Qualifier} Qualifier
                         */
                        Qualifier.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.Qualifier)
                                return object;
                            let message = new $root.build.bazel.remote.asset.v1.Qualifier();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Qualifier message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {build.bazel.remote.asset.v1.Qualifier} message Qualifier
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Qualifier.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.name = "";
                                object.value = "";
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this Qualifier to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Qualifier.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for Qualifier
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.Qualifier
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        Qualifier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.Qualifier";
                        };

                        return Qualifier;
                    })();

                    v1.Fetch = (function() {

                        /**
                         * Constructs a new Fetch service.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a Fetch
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function Fetch(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (Fetch.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Fetch;

                        /**
                         * Creates new Fetch service using the specified rpc implementation.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.Fetch
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {Fetch} RPC service. Useful where requests and/or responses are streamed.
                         */
                        Fetch.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link build.bazel.remote.asset.v1.Fetch#fetchBlob}.
                         * @memberof build.bazel.remote.asset.v1.Fetch
                         * @typedef FetchBlobCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.asset.v1.FetchBlobResponse} [response] FetchBlobResponse
                         */

                        /**
                         * Calls FetchBlob.
                         * @function fetchBlob
                         * @memberof build.bazel.remote.asset.v1.Fetch
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IFetchBlobRequest} request FetchBlobRequest message or plain object
                         * @param {build.bazel.remote.asset.v1.Fetch.FetchBlobCallback} callback Node-style callback called with the error, if any, and FetchBlobResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(Fetch.prototype.fetchBlob = function fetchBlob(request, callback) {
                            return this.rpcCall(fetchBlob, $root.build.bazel.remote.asset.v1.FetchBlobRequest, $root.build.bazel.remote.asset.v1.FetchBlobResponse, request, callback);
                        }, "name", { value: "FetchBlob" });

                        /**
                         * Calls FetchBlob.
                         * @function fetchBlob
                         * @memberof build.bazel.remote.asset.v1.Fetch
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IFetchBlobRequest} request FetchBlobRequest message or plain object
                         * @returns {Promise<build.bazel.remote.asset.v1.FetchBlobResponse>} Promise
                         * @variation 2
                         */

                        /**
                         * Callback as used by {@link build.bazel.remote.asset.v1.Fetch#fetchDirectory}.
                         * @memberof build.bazel.remote.asset.v1.Fetch
                         * @typedef FetchDirectoryCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.asset.v1.FetchDirectoryResponse} [response] FetchDirectoryResponse
                         */

                        /**
                         * Calls FetchDirectory.
                         * @function fetchDirectory
                         * @memberof build.bazel.remote.asset.v1.Fetch
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryRequest} request FetchDirectoryRequest message or plain object
                         * @param {build.bazel.remote.asset.v1.Fetch.FetchDirectoryCallback} callback Node-style callback called with the error, if any, and FetchDirectoryResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(Fetch.prototype.fetchDirectory = function fetchDirectory(request, callback) {
                            return this.rpcCall(fetchDirectory, $root.build.bazel.remote.asset.v1.FetchDirectoryRequest, $root.build.bazel.remote.asset.v1.FetchDirectoryResponse, request, callback);
                        }, "name", { value: "FetchDirectory" });

                        /**
                         * Calls FetchDirectory.
                         * @function fetchDirectory
                         * @memberof build.bazel.remote.asset.v1.Fetch
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryRequest} request FetchDirectoryRequest message or plain object
                         * @returns {Promise<build.bazel.remote.asset.v1.FetchDirectoryResponse>} Promise
                         * @variation 2
                         */

                        return Fetch;
                    })();

                    v1.FetchBlobRequest = (function() {

                        /**
                         * Properties of a FetchBlobRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IFetchBlobRequest
                         * @property {string|null} [instanceName] FetchBlobRequest instanceName
                         * @property {google.protobuf.IDuration|null} [timeout] FetchBlobRequest timeout
                         * @property {google.protobuf.ITimestamp|null} [oldestContentAccepted] FetchBlobRequest oldestContentAccepted
                         * @property {Array.<string>|null} [uris] FetchBlobRequest uris
                         * @property {Array.<build.bazel.remote.asset.v1.IQualifier>|null} [qualifiers] FetchBlobRequest qualifiers
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] FetchBlobRequest digestFunction
                         */

                        /**
                         * Constructs a new FetchBlobRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a FetchBlobRequest.
                         * @implements IFetchBlobRequest
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IFetchBlobRequest=} [properties] Properties to set
                         */
                        function FetchBlobRequest(properties) {
                            this.uris = [];
                            this.qualifiers = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FetchBlobRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @instance
                         */
                        FetchBlobRequest.prototype.instanceName = "";

                        /**
                         * FetchBlobRequest timeout.
                         * @member {google.protobuf.IDuration|null|undefined} timeout
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @instance
                         */
                        FetchBlobRequest.prototype.timeout = null;

                        /**
                         * FetchBlobRequest oldestContentAccepted.
                         * @member {google.protobuf.ITimestamp|null|undefined} oldestContentAccepted
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @instance
                         */
                        FetchBlobRequest.prototype.oldestContentAccepted = null;

                        /**
                         * FetchBlobRequest uris.
                         * @member {Array.<string>} uris
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @instance
                         */
                        FetchBlobRequest.prototype.uris = $util.emptyArray;

                        /**
                         * FetchBlobRequest qualifiers.
                         * @member {Array.<build.bazel.remote.asset.v1.IQualifier>} qualifiers
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @instance
                         */
                        FetchBlobRequest.prototype.qualifiers = $util.emptyArray;

                        /**
                         * FetchBlobRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @instance
                         */
                        FetchBlobRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new FetchBlobRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchBlobRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.FetchBlobRequest} FetchBlobRequest instance
                         */
                        FetchBlobRequest.create = function create(properties) {
                            return new FetchBlobRequest(properties);
                        };

                        /**
                         * Encodes the specified FetchBlobRequest message. Does not implicitly {@link build.bazel.remote.asset.v1.FetchBlobRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchBlobRequest} message FetchBlobRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchBlobRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                                $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.oldestContentAccepted != null && Object.hasOwnProperty.call(message, "oldestContentAccepted"))
                                $root.google.protobuf.Timestamp.encode(message.oldestContentAccepted, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.uris != null && message.uris.length)
                                for (let i = 0; i < message.uris.length; ++i)
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.uris[i]);
                            if (message.qualifiers != null && message.qualifiers.length)
                                for (let i = 0; i < message.qualifiers.length; ++i)
                                    $root.build.bazel.remote.asset.v1.Qualifier.encode(message.qualifiers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified FetchBlobRequest message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.FetchBlobRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchBlobRequest} message FetchBlobRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchBlobRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FetchBlobRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.FetchBlobRequest} FetchBlobRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchBlobRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.FetchBlobRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.oldestContentAccepted = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        if (!(message.uris && message.uris.length))
                                            message.uris = [];
                                        message.uris.push(reader.string());
                                        break;
                                    }
                                case 5: {
                                        if (!(message.qualifiers && message.qualifiers.length))
                                            message.qualifiers = [];
                                        message.qualifiers.push($root.build.bazel.remote.asset.v1.Qualifier.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 6: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FetchBlobRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.FetchBlobRequest} FetchBlobRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchBlobRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FetchBlobRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FetchBlobRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.timeout != null && message.hasOwnProperty("timeout")) {
                                let error = $root.google.protobuf.Duration.verify(message.timeout);
                                if (error)
                                    return "timeout." + error;
                            }
                            if (message.oldestContentAccepted != null && message.hasOwnProperty("oldestContentAccepted")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.oldestContentAccepted);
                                if (error)
                                    return "oldestContentAccepted." + error;
                            }
                            if (message.uris != null && message.hasOwnProperty("uris")) {
                                if (!Array.isArray(message.uris))
                                    return "uris: array expected";
                                for (let i = 0; i < message.uris.length; ++i)
                                    if (!$util.isString(message.uris[i]))
                                        return "uris: string[] expected";
                            }
                            if (message.qualifiers != null && message.hasOwnProperty("qualifiers")) {
                                if (!Array.isArray(message.qualifiers))
                                    return "qualifiers: array expected";
                                for (let i = 0; i < message.qualifiers.length; ++i) {
                                    let error = $root.build.bazel.remote.asset.v1.Qualifier.verify(message.qualifiers[i]);
                                    if (error)
                                        return "qualifiers." + error;
                                }
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a FetchBlobRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.FetchBlobRequest} FetchBlobRequest
                         */
                        FetchBlobRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.FetchBlobRequest)
                                return object;
                            let message = new $root.build.bazel.remote.asset.v1.FetchBlobRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.timeout != null) {
                                if (typeof object.timeout !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobRequest.timeout: object expected");
                                message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                            }
                            if (object.oldestContentAccepted != null) {
                                if (typeof object.oldestContentAccepted !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobRequest.oldestContentAccepted: object expected");
                                message.oldestContentAccepted = $root.google.protobuf.Timestamp.fromObject(object.oldestContentAccepted);
                            }
                            if (object.uris) {
                                if (!Array.isArray(object.uris))
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobRequest.uris: array expected");
                                message.uris = [];
                                for (let i = 0; i < object.uris.length; ++i)
                                    message.uris[i] = String(object.uris[i]);
                            }
                            if (object.qualifiers) {
                                if (!Array.isArray(object.qualifiers))
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobRequest.qualifiers: array expected");
                                message.qualifiers = [];
                                for (let i = 0; i < object.qualifiers.length; ++i) {
                                    if (typeof object.qualifiers[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.FetchBlobRequest.qualifiers: object expected");
                                    message.qualifiers[i] = $root.build.bazel.remote.asset.v1.Qualifier.fromObject(object.qualifiers[i]);
                                }
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FetchBlobRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.FetchBlobRequest} message FetchBlobRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FetchBlobRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.uris = [];
                                object.qualifiers = [];
                            }
                            if (options.defaults) {
                                object.instanceName = "";
                                object.timeout = null;
                                object.oldestContentAccepted = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.timeout != null && message.hasOwnProperty("timeout"))
                                object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                            if (message.oldestContentAccepted != null && message.hasOwnProperty("oldestContentAccepted"))
                                object.oldestContentAccepted = $root.google.protobuf.Timestamp.toObject(message.oldestContentAccepted, options);
                            if (message.uris && message.uris.length) {
                                object.uris = [];
                                for (let j = 0; j < message.uris.length; ++j)
                                    object.uris[j] = message.uris[j];
                            }
                            if (message.qualifiers && message.qualifiers.length) {
                                object.qualifiers = [];
                                for (let j = 0; j < message.qualifiers.length; ++j)
                                    object.qualifiers[j] = $root.build.bazel.remote.asset.v1.Qualifier.toObject(message.qualifiers[j], options);
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this FetchBlobRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FetchBlobRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FetchBlobRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.FetchBlobRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FetchBlobRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.FetchBlobRequest";
                        };

                        return FetchBlobRequest;
                    })();

                    v1.FetchBlobResponse = (function() {

                        /**
                         * Properties of a FetchBlobResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IFetchBlobResponse
                         * @property {google.rpc.IStatus|null} [status] FetchBlobResponse status
                         * @property {string|null} [uri] FetchBlobResponse uri
                         * @property {Array.<build.bazel.remote.asset.v1.IQualifier>|null} [qualifiers] FetchBlobResponse qualifiers
                         * @property {google.protobuf.ITimestamp|null} [expiresAt] FetchBlobResponse expiresAt
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [blobDigest] FetchBlobResponse blobDigest
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] FetchBlobResponse digestFunction
                         */

                        /**
                         * Constructs a new FetchBlobResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a FetchBlobResponse.
                         * @implements IFetchBlobResponse
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IFetchBlobResponse=} [properties] Properties to set
                         */
                        function FetchBlobResponse(properties) {
                            this.qualifiers = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FetchBlobResponse status.
                         * @member {google.rpc.IStatus|null|undefined} status
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @instance
                         */
                        FetchBlobResponse.prototype.status = null;

                        /**
                         * FetchBlobResponse uri.
                         * @member {string} uri
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @instance
                         */
                        FetchBlobResponse.prototype.uri = "";

                        /**
                         * FetchBlobResponse qualifiers.
                         * @member {Array.<build.bazel.remote.asset.v1.IQualifier>} qualifiers
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @instance
                         */
                        FetchBlobResponse.prototype.qualifiers = $util.emptyArray;

                        /**
                         * FetchBlobResponse expiresAt.
                         * @member {google.protobuf.ITimestamp|null|undefined} expiresAt
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @instance
                         */
                        FetchBlobResponse.prototype.expiresAt = null;

                        /**
                         * FetchBlobResponse blobDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} blobDigest
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @instance
                         */
                        FetchBlobResponse.prototype.blobDigest = null;

                        /**
                         * FetchBlobResponse digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @instance
                         */
                        FetchBlobResponse.prototype.digestFunction = 0;

                        /**
                         * Creates a new FetchBlobResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchBlobResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.FetchBlobResponse} FetchBlobResponse instance
                         */
                        FetchBlobResponse.create = function create(properties) {
                            return new FetchBlobResponse(properties);
                        };

                        /**
                         * Encodes the specified FetchBlobResponse message. Does not implicitly {@link build.bazel.remote.asset.v1.FetchBlobResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchBlobResponse} message FetchBlobResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchBlobResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                                $root.google.rpc.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                            if (message.qualifiers != null && message.qualifiers.length)
                                for (let i = 0; i < message.qualifiers.length; ++i)
                                    $root.build.bazel.remote.asset.v1.Qualifier.encode(message.qualifiers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.expiresAt != null && Object.hasOwnProperty.call(message, "expiresAt"))
                                $root.google.protobuf.Timestamp.encode(message.expiresAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.blobDigest != null && Object.hasOwnProperty.call(message, "blobDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.blobDigest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified FetchBlobResponse message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.FetchBlobResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchBlobResponse} message FetchBlobResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchBlobResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FetchBlobResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.FetchBlobResponse} FetchBlobResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchBlobResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.FetchBlobResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.status = $root.google.rpc.Status.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.uri = reader.string();
                                        break;
                                    }
                                case 3: {
                                        if (!(message.qualifiers && message.qualifiers.length))
                                            message.qualifiers = [];
                                        message.qualifiers.push($root.build.bazel.remote.asset.v1.Qualifier.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 4: {
                                        message.expiresAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 5: {
                                        message.blobDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FetchBlobResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.FetchBlobResponse} FetchBlobResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchBlobResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FetchBlobResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FetchBlobResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.status != null && message.hasOwnProperty("status")) {
                                let error = $root.google.rpc.Status.verify(message.status);
                                if (error)
                                    return "status." + error;
                            }
                            if (message.uri != null && message.hasOwnProperty("uri"))
                                if (!$util.isString(message.uri))
                                    return "uri: string expected";
                            if (message.qualifiers != null && message.hasOwnProperty("qualifiers")) {
                                if (!Array.isArray(message.qualifiers))
                                    return "qualifiers: array expected";
                                for (let i = 0; i < message.qualifiers.length; ++i) {
                                    let error = $root.build.bazel.remote.asset.v1.Qualifier.verify(message.qualifiers[i]);
                                    if (error)
                                        return "qualifiers." + error;
                                }
                            }
                            if (message.expiresAt != null && message.hasOwnProperty("expiresAt")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.expiresAt);
                                if (error)
                                    return "expiresAt." + error;
                            }
                            if (message.blobDigest != null && message.hasOwnProperty("blobDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.blobDigest);
                                if (error)
                                    return "blobDigest." + error;
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a FetchBlobResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.FetchBlobResponse} FetchBlobResponse
                         */
                        FetchBlobResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.FetchBlobResponse)
                                return object;
                            let message = new $root.build.bazel.remote.asset.v1.FetchBlobResponse();
                            if (object.status != null) {
                                if (typeof object.status !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobResponse.status: object expected");
                                message.status = $root.google.rpc.Status.fromObject(object.status);
                            }
                            if (object.uri != null)
                                message.uri = String(object.uri);
                            if (object.qualifiers) {
                                if (!Array.isArray(object.qualifiers))
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobResponse.qualifiers: array expected");
                                message.qualifiers = [];
                                for (let i = 0; i < object.qualifiers.length; ++i) {
                                    if (typeof object.qualifiers[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.FetchBlobResponse.qualifiers: object expected");
                                    message.qualifiers[i] = $root.build.bazel.remote.asset.v1.Qualifier.fromObject(object.qualifiers[i]);
                                }
                            }
                            if (object.expiresAt != null) {
                                if (typeof object.expiresAt !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobResponse.expiresAt: object expected");
                                message.expiresAt = $root.google.protobuf.Timestamp.fromObject(object.expiresAt);
                            }
                            if (object.blobDigest != null) {
                                if (typeof object.blobDigest !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchBlobResponse.blobDigest: object expected");
                                message.blobDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.blobDigest);
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FetchBlobResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.FetchBlobResponse} message FetchBlobResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FetchBlobResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.qualifiers = [];
                            if (options.defaults) {
                                object.status = null;
                                object.uri = "";
                                object.expiresAt = null;
                                object.blobDigest = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.status != null && message.hasOwnProperty("status"))
                                object.status = $root.google.rpc.Status.toObject(message.status, options);
                            if (message.uri != null && message.hasOwnProperty("uri"))
                                object.uri = message.uri;
                            if (message.qualifiers && message.qualifiers.length) {
                                object.qualifiers = [];
                                for (let j = 0; j < message.qualifiers.length; ++j)
                                    object.qualifiers[j] = $root.build.bazel.remote.asset.v1.Qualifier.toObject(message.qualifiers[j], options);
                            }
                            if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                                object.expiresAt = $root.google.protobuf.Timestamp.toObject(message.expiresAt, options);
                            if (message.blobDigest != null && message.hasOwnProperty("blobDigest"))
                                object.blobDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.blobDigest, options);
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this FetchBlobResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FetchBlobResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FetchBlobResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.FetchBlobResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FetchBlobResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.FetchBlobResponse";
                        };

                        return FetchBlobResponse;
                    })();

                    v1.FetchDirectoryRequest = (function() {

                        /**
                         * Properties of a FetchDirectoryRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IFetchDirectoryRequest
                         * @property {string|null} [instanceName] FetchDirectoryRequest instanceName
                         * @property {google.protobuf.IDuration|null} [timeout] FetchDirectoryRequest timeout
                         * @property {google.protobuf.ITimestamp|null} [oldestContentAccepted] FetchDirectoryRequest oldestContentAccepted
                         * @property {Array.<string>|null} [uris] FetchDirectoryRequest uris
                         * @property {Array.<build.bazel.remote.asset.v1.IQualifier>|null} [qualifiers] FetchDirectoryRequest qualifiers
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] FetchDirectoryRequest digestFunction
                         */

                        /**
                         * Constructs a new FetchDirectoryRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a FetchDirectoryRequest.
                         * @implements IFetchDirectoryRequest
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryRequest=} [properties] Properties to set
                         */
                        function FetchDirectoryRequest(properties) {
                            this.uris = [];
                            this.qualifiers = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FetchDirectoryRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @instance
                         */
                        FetchDirectoryRequest.prototype.instanceName = "";

                        /**
                         * FetchDirectoryRequest timeout.
                         * @member {google.protobuf.IDuration|null|undefined} timeout
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @instance
                         */
                        FetchDirectoryRequest.prototype.timeout = null;

                        /**
                         * FetchDirectoryRequest oldestContentAccepted.
                         * @member {google.protobuf.ITimestamp|null|undefined} oldestContentAccepted
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @instance
                         */
                        FetchDirectoryRequest.prototype.oldestContentAccepted = null;

                        /**
                         * FetchDirectoryRequest uris.
                         * @member {Array.<string>} uris
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @instance
                         */
                        FetchDirectoryRequest.prototype.uris = $util.emptyArray;

                        /**
                         * FetchDirectoryRequest qualifiers.
                         * @member {Array.<build.bazel.remote.asset.v1.IQualifier>} qualifiers
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @instance
                         */
                        FetchDirectoryRequest.prototype.qualifiers = $util.emptyArray;

                        /**
                         * FetchDirectoryRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @instance
                         */
                        FetchDirectoryRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new FetchDirectoryRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryRequest} FetchDirectoryRequest instance
                         */
                        FetchDirectoryRequest.create = function create(properties) {
                            return new FetchDirectoryRequest(properties);
                        };

                        /**
                         * Encodes the specified FetchDirectoryRequest message. Does not implicitly {@link build.bazel.remote.asset.v1.FetchDirectoryRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryRequest} message FetchDirectoryRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchDirectoryRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                                $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            if (message.oldestContentAccepted != null && Object.hasOwnProperty.call(message, "oldestContentAccepted"))
                                $root.google.protobuf.Timestamp.encode(message.oldestContentAccepted, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.uris != null && message.uris.length)
                                for (let i = 0; i < message.uris.length; ++i)
                                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.uris[i]);
                            if (message.qualifiers != null && message.qualifiers.length)
                                for (let i = 0; i < message.qualifiers.length; ++i)
                                    $root.build.bazel.remote.asset.v1.Qualifier.encode(message.qualifiers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified FetchDirectoryRequest message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.FetchDirectoryRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryRequest} message FetchDirectoryRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FetchDirectoryRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryRequest} FetchDirectoryRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchDirectoryRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.FetchDirectoryRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 3: {
                                        message.oldestContentAccepted = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 4: {
                                        if (!(message.uris && message.uris.length))
                                            message.uris = [];
                                        message.uris.push(reader.string());
                                        break;
                                    }
                                case 5: {
                                        if (!(message.qualifiers && message.qualifiers.length))
                                            message.qualifiers = [];
                                        message.qualifiers.push($root.build.bazel.remote.asset.v1.Qualifier.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 6: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FetchDirectoryRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryRequest} FetchDirectoryRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FetchDirectoryRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FetchDirectoryRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.timeout != null && message.hasOwnProperty("timeout")) {
                                let error = $root.google.protobuf.Duration.verify(message.timeout);
                                if (error)
                                    return "timeout." + error;
                            }
                            if (message.oldestContentAccepted != null && message.hasOwnProperty("oldestContentAccepted")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.oldestContentAccepted);
                                if (error)
                                    return "oldestContentAccepted." + error;
                            }
                            if (message.uris != null && message.hasOwnProperty("uris")) {
                                if (!Array.isArray(message.uris))
                                    return "uris: array expected";
                                for (let i = 0; i < message.uris.length; ++i)
                                    if (!$util.isString(message.uris[i]))
                                        return "uris: string[] expected";
                            }
                            if (message.qualifiers != null && message.hasOwnProperty("qualifiers")) {
                                if (!Array.isArray(message.qualifiers))
                                    return "qualifiers: array expected";
                                for (let i = 0; i < message.qualifiers.length; ++i) {
                                    let error = $root.build.bazel.remote.asset.v1.Qualifier.verify(message.qualifiers[i]);
                                    if (error)
                                        return "qualifiers." + error;
                                }
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a FetchDirectoryRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryRequest} FetchDirectoryRequest
                         */
                        FetchDirectoryRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.FetchDirectoryRequest)
                                return object;
                            let message = new $root.build.bazel.remote.asset.v1.FetchDirectoryRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.timeout != null) {
                                if (typeof object.timeout !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryRequest.timeout: object expected");
                                message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                            }
                            if (object.oldestContentAccepted != null) {
                                if (typeof object.oldestContentAccepted !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryRequest.oldestContentAccepted: object expected");
                                message.oldestContentAccepted = $root.google.protobuf.Timestamp.fromObject(object.oldestContentAccepted);
                            }
                            if (object.uris) {
                                if (!Array.isArray(object.uris))
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryRequest.uris: array expected");
                                message.uris = [];
                                for (let i = 0; i < object.uris.length; ++i)
                                    message.uris[i] = String(object.uris[i]);
                            }
                            if (object.qualifiers) {
                                if (!Array.isArray(object.qualifiers))
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryRequest.qualifiers: array expected");
                                message.qualifiers = [];
                                for (let i = 0; i < object.qualifiers.length; ++i) {
                                    if (typeof object.qualifiers[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryRequest.qualifiers: object expected");
                                    message.qualifiers[i] = $root.build.bazel.remote.asset.v1.Qualifier.fromObject(object.qualifiers[i]);
                                }
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FetchDirectoryRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.FetchDirectoryRequest} message FetchDirectoryRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FetchDirectoryRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.uris = [];
                                object.qualifiers = [];
                            }
                            if (options.defaults) {
                                object.instanceName = "";
                                object.timeout = null;
                                object.oldestContentAccepted = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.timeout != null && message.hasOwnProperty("timeout"))
                                object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                            if (message.oldestContentAccepted != null && message.hasOwnProperty("oldestContentAccepted"))
                                object.oldestContentAccepted = $root.google.protobuf.Timestamp.toObject(message.oldestContentAccepted, options);
                            if (message.uris && message.uris.length) {
                                object.uris = [];
                                for (let j = 0; j < message.uris.length; ++j)
                                    object.uris[j] = message.uris[j];
                            }
                            if (message.qualifiers && message.qualifiers.length) {
                                object.qualifiers = [];
                                for (let j = 0; j < message.qualifiers.length; ++j)
                                    object.qualifiers[j] = $root.build.bazel.remote.asset.v1.Qualifier.toObject(message.qualifiers[j], options);
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this FetchDirectoryRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FetchDirectoryRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FetchDirectoryRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FetchDirectoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.FetchDirectoryRequest";
                        };

                        return FetchDirectoryRequest;
                    })();

                    v1.FetchDirectoryResponse = (function() {

                        /**
                         * Properties of a FetchDirectoryResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IFetchDirectoryResponse
                         * @property {google.rpc.IStatus|null} [status] FetchDirectoryResponse status
                         * @property {string|null} [uri] FetchDirectoryResponse uri
                         * @property {Array.<build.bazel.remote.asset.v1.IQualifier>|null} [qualifiers] FetchDirectoryResponse qualifiers
                         * @property {google.protobuf.ITimestamp|null} [expiresAt] FetchDirectoryResponse expiresAt
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [rootDirectoryDigest] FetchDirectoryResponse rootDirectoryDigest
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] FetchDirectoryResponse digestFunction
                         */

                        /**
                         * Constructs a new FetchDirectoryResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a FetchDirectoryResponse.
                         * @implements IFetchDirectoryResponse
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryResponse=} [properties] Properties to set
                         */
                        function FetchDirectoryResponse(properties) {
                            this.qualifiers = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FetchDirectoryResponse status.
                         * @member {google.rpc.IStatus|null|undefined} status
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @instance
                         */
                        FetchDirectoryResponse.prototype.status = null;

                        /**
                         * FetchDirectoryResponse uri.
                         * @member {string} uri
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @instance
                         */
                        FetchDirectoryResponse.prototype.uri = "";

                        /**
                         * FetchDirectoryResponse qualifiers.
                         * @member {Array.<build.bazel.remote.asset.v1.IQualifier>} qualifiers
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @instance
                         */
                        FetchDirectoryResponse.prototype.qualifiers = $util.emptyArray;

                        /**
                         * FetchDirectoryResponse expiresAt.
                         * @member {google.protobuf.ITimestamp|null|undefined} expiresAt
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @instance
                         */
                        FetchDirectoryResponse.prototype.expiresAt = null;

                        /**
                         * FetchDirectoryResponse rootDirectoryDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} rootDirectoryDigest
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @instance
                         */
                        FetchDirectoryResponse.prototype.rootDirectoryDigest = null;

                        /**
                         * FetchDirectoryResponse digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @instance
                         */
                        FetchDirectoryResponse.prototype.digestFunction = 0;

                        /**
                         * Creates a new FetchDirectoryResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryResponse} FetchDirectoryResponse instance
                         */
                        FetchDirectoryResponse.create = function create(properties) {
                            return new FetchDirectoryResponse(properties);
                        };

                        /**
                         * Encodes the specified FetchDirectoryResponse message. Does not implicitly {@link build.bazel.remote.asset.v1.FetchDirectoryResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryResponse} message FetchDirectoryResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchDirectoryResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                                $root.google.rpc.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.uri != null && Object.hasOwnProperty.call(message, "uri"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.uri);
                            if (message.qualifiers != null && message.qualifiers.length)
                                for (let i = 0; i < message.qualifiers.length; ++i)
                                    $root.build.bazel.remote.asset.v1.Qualifier.encode(message.qualifiers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.expiresAt != null && Object.hasOwnProperty.call(message, "expiresAt"))
                                $root.google.protobuf.Timestamp.encode(message.expiresAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.rootDirectoryDigest != null && Object.hasOwnProperty.call(message, "rootDirectoryDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.rootDirectoryDigest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified FetchDirectoryResponse message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.FetchDirectoryResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IFetchDirectoryResponse} message FetchDirectoryResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        FetchDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a FetchDirectoryResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryResponse} FetchDirectoryResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchDirectoryResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.FetchDirectoryResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.status = $root.google.rpc.Status.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 2: {
                                        message.uri = reader.string();
                                        break;
                                    }
                                case 3: {
                                        if (!(message.qualifiers && message.qualifiers.length))
                                            message.qualifiers = [];
                                        message.qualifiers.push($root.build.bazel.remote.asset.v1.Qualifier.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 4: {
                                        message.expiresAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 5: {
                                        message.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a FetchDirectoryResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryResponse} FetchDirectoryResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FetchDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a FetchDirectoryResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        FetchDirectoryResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.status != null && message.hasOwnProperty("status")) {
                                let error = $root.google.rpc.Status.verify(message.status);
                                if (error)
                                    return "status." + error;
                            }
                            if (message.uri != null && message.hasOwnProperty("uri"))
                                if (!$util.isString(message.uri))
                                    return "uri: string expected";
                            if (message.qualifiers != null && message.hasOwnProperty("qualifiers")) {
                                if (!Array.isArray(message.qualifiers))
                                    return "qualifiers: array expected";
                                for (let i = 0; i < message.qualifiers.length; ++i) {
                                    let error = $root.build.bazel.remote.asset.v1.Qualifier.verify(message.qualifiers[i]);
                                    if (error)
                                        return "qualifiers." + error;
                                }
                            }
                            if (message.expiresAt != null && message.hasOwnProperty("expiresAt")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.expiresAt);
                                if (error)
                                    return "expiresAt." + error;
                            }
                            if (message.rootDirectoryDigest != null && message.hasOwnProperty("rootDirectoryDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.rootDirectoryDigest);
                                if (error)
                                    return "rootDirectoryDigest." + error;
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a FetchDirectoryResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.FetchDirectoryResponse} FetchDirectoryResponse
                         */
                        FetchDirectoryResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.FetchDirectoryResponse)
                                return object;
                            let message = new $root.build.bazel.remote.asset.v1.FetchDirectoryResponse();
                            if (object.status != null) {
                                if (typeof object.status !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryResponse.status: object expected");
                                message.status = $root.google.rpc.Status.fromObject(object.status);
                            }
                            if (object.uri != null)
                                message.uri = String(object.uri);
                            if (object.qualifiers) {
                                if (!Array.isArray(object.qualifiers))
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryResponse.qualifiers: array expected");
                                message.qualifiers = [];
                                for (let i = 0; i < object.qualifiers.length; ++i) {
                                    if (typeof object.qualifiers[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryResponse.qualifiers: object expected");
                                    message.qualifiers[i] = $root.build.bazel.remote.asset.v1.Qualifier.fromObject(object.qualifiers[i]);
                                }
                            }
                            if (object.expiresAt != null) {
                                if (typeof object.expiresAt !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryResponse.expiresAt: object expected");
                                message.expiresAt = $root.google.protobuf.Timestamp.fromObject(object.expiresAt);
                            }
                            if (object.rootDirectoryDigest != null) {
                                if (typeof object.rootDirectoryDigest !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.FetchDirectoryResponse.rootDirectoryDigest: object expected");
                                message.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.rootDirectoryDigest);
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a FetchDirectoryResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.FetchDirectoryResponse} message FetchDirectoryResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        FetchDirectoryResponse.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.qualifiers = [];
                            if (options.defaults) {
                                object.status = null;
                                object.uri = "";
                                object.expiresAt = null;
                                object.rootDirectoryDigest = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.status != null && message.hasOwnProperty("status"))
                                object.status = $root.google.rpc.Status.toObject(message.status, options);
                            if (message.uri != null && message.hasOwnProperty("uri"))
                                object.uri = message.uri;
                            if (message.qualifiers && message.qualifiers.length) {
                                object.qualifiers = [];
                                for (let j = 0; j < message.qualifiers.length; ++j)
                                    object.qualifiers[j] = $root.build.bazel.remote.asset.v1.Qualifier.toObject(message.qualifiers[j], options);
                            }
                            if (message.expiresAt != null && message.hasOwnProperty("expiresAt"))
                                object.expiresAt = $root.google.protobuf.Timestamp.toObject(message.expiresAt, options);
                            if (message.rootDirectoryDigest != null && message.hasOwnProperty("rootDirectoryDigest"))
                                object.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.rootDirectoryDigest, options);
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this FetchDirectoryResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        FetchDirectoryResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for FetchDirectoryResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.FetchDirectoryResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        FetchDirectoryResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.FetchDirectoryResponse";
                        };

                        return FetchDirectoryResponse;
                    })();

                    v1.Push = (function() {

                        /**
                         * Constructs a new Push service.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a Push
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function Push(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (Push.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Push;

                        /**
                         * Creates new Push service using the specified rpc implementation.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.Push
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {Push} RPC service. Useful where requests and/or responses are streamed.
                         */
                        Push.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link build.bazel.remote.asset.v1.Push#pushBlob}.
                         * @memberof build.bazel.remote.asset.v1.Push
                         * @typedef PushBlobCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.asset.v1.PushBlobResponse} [response] PushBlobResponse
                         */

                        /**
                         * Calls PushBlob.
                         * @function pushBlob
                         * @memberof build.bazel.remote.asset.v1.Push
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IPushBlobRequest} request PushBlobRequest message or plain object
                         * @param {build.bazel.remote.asset.v1.Push.PushBlobCallback} callback Node-style callback called with the error, if any, and PushBlobResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(Push.prototype.pushBlob = function pushBlob(request, callback) {
                            return this.rpcCall(pushBlob, $root.build.bazel.remote.asset.v1.PushBlobRequest, $root.build.bazel.remote.asset.v1.PushBlobResponse, request, callback);
                        }, "name", { value: "PushBlob" });

                        /**
                         * Calls PushBlob.
                         * @function pushBlob
                         * @memberof build.bazel.remote.asset.v1.Push
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IPushBlobRequest} request PushBlobRequest message or plain object
                         * @returns {Promise<build.bazel.remote.asset.v1.PushBlobResponse>} Promise
                         * @variation 2
                         */

                        /**
                         * Callback as used by {@link build.bazel.remote.asset.v1.Push#pushDirectory}.
                         * @memberof build.bazel.remote.asset.v1.Push
                         * @typedef PushDirectoryCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.asset.v1.PushDirectoryResponse} [response] PushDirectoryResponse
                         */

                        /**
                         * Calls PushDirectory.
                         * @function pushDirectory
                         * @memberof build.bazel.remote.asset.v1.Push
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryRequest} request PushDirectoryRequest message or plain object
                         * @param {build.bazel.remote.asset.v1.Push.PushDirectoryCallback} callback Node-style callback called with the error, if any, and PushDirectoryResponse
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(Push.prototype.pushDirectory = function pushDirectory(request, callback) {
                            return this.rpcCall(pushDirectory, $root.build.bazel.remote.asset.v1.PushDirectoryRequest, $root.build.bazel.remote.asset.v1.PushDirectoryResponse, request, callback);
                        }, "name", { value: "PushDirectory" });

                        /**
                         * Calls PushDirectory.
                         * @function pushDirectory
                         * @memberof build.bazel.remote.asset.v1.Push
                         * @instance
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryRequest} request PushDirectoryRequest message or plain object
                         * @returns {Promise<build.bazel.remote.asset.v1.PushDirectoryResponse>} Promise
                         * @variation 2
                         */

                        return Push;
                    })();

                    v1.PushBlobRequest = (function() {

                        /**
                         * Properties of a PushBlobRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IPushBlobRequest
                         * @property {string|null} [instanceName] PushBlobRequest instanceName
                         * @property {Array.<string>|null} [uris] PushBlobRequest uris
                         * @property {Array.<build.bazel.remote.asset.v1.IQualifier>|null} [qualifiers] PushBlobRequest qualifiers
                         * @property {google.protobuf.ITimestamp|null} [expireAt] PushBlobRequest expireAt
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [blobDigest] PushBlobRequest blobDigest
                         * @property {Array.<build.bazel.remote.execution.v2.IDigest>|null} [referencesBlobs] PushBlobRequest referencesBlobs
                         * @property {Array.<build.bazel.remote.execution.v2.IDigest>|null} [referencesDirectories] PushBlobRequest referencesDirectories
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] PushBlobRequest digestFunction
                         */

                        /**
                         * Constructs a new PushBlobRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a PushBlobRequest.
                         * @implements IPushBlobRequest
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IPushBlobRequest=} [properties] Properties to set
                         */
                        function PushBlobRequest(properties) {
                            this.uris = [];
                            this.qualifiers = [];
                            this.referencesBlobs = [];
                            this.referencesDirectories = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PushBlobRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.instanceName = "";

                        /**
                         * PushBlobRequest uris.
                         * @member {Array.<string>} uris
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.uris = $util.emptyArray;

                        /**
                         * PushBlobRequest qualifiers.
                         * @member {Array.<build.bazel.remote.asset.v1.IQualifier>} qualifiers
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.qualifiers = $util.emptyArray;

                        /**
                         * PushBlobRequest expireAt.
                         * @member {google.protobuf.ITimestamp|null|undefined} expireAt
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.expireAt = null;

                        /**
                         * PushBlobRequest blobDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} blobDigest
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.blobDigest = null;

                        /**
                         * PushBlobRequest referencesBlobs.
                         * @member {Array.<build.bazel.remote.execution.v2.IDigest>} referencesBlobs
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.referencesBlobs = $util.emptyArray;

                        /**
                         * PushBlobRequest referencesDirectories.
                         * @member {Array.<build.bazel.remote.execution.v2.IDigest>} referencesDirectories
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.referencesDirectories = $util.emptyArray;

                        /**
                         * PushBlobRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         */
                        PushBlobRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new PushBlobRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushBlobRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.PushBlobRequest} PushBlobRequest instance
                         */
                        PushBlobRequest.create = function create(properties) {
                            return new PushBlobRequest(properties);
                        };

                        /**
                         * Encodes the specified PushBlobRequest message. Does not implicitly {@link build.bazel.remote.asset.v1.PushBlobRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushBlobRequest} message PushBlobRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushBlobRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.uris != null && message.uris.length)
                                for (let i = 0; i < message.uris.length; ++i)
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uris[i]);
                            if (message.qualifiers != null && message.qualifiers.length)
                                for (let i = 0; i < message.qualifiers.length; ++i)
                                    $root.build.bazel.remote.asset.v1.Qualifier.encode(message.qualifiers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.expireAt != null && Object.hasOwnProperty.call(message, "expireAt"))
                                $root.google.protobuf.Timestamp.encode(message.expireAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.blobDigest != null && Object.hasOwnProperty.call(message, "blobDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.blobDigest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.referencesBlobs != null && message.referencesBlobs.length)
                                for (let i = 0; i < message.referencesBlobs.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.referencesBlobs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.referencesDirectories != null && message.referencesDirectories.length)
                                for (let i = 0; i < message.referencesDirectories.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.referencesDirectories[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified PushBlobRequest message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.PushBlobRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushBlobRequest} message PushBlobRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushBlobRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PushBlobRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.PushBlobRequest} PushBlobRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushBlobRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.PushBlobRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        if (!(message.uris && message.uris.length))
                                            message.uris = [];
                                        message.uris.push(reader.string());
                                        break;
                                    }
                                case 3: {
                                        if (!(message.qualifiers && message.qualifiers.length))
                                            message.qualifiers = [];
                                        message.qualifiers.push($root.build.bazel.remote.asset.v1.Qualifier.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 4: {
                                        message.expireAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 5: {
                                        message.blobDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        if (!(message.referencesBlobs && message.referencesBlobs.length))
                                            message.referencesBlobs = [];
                                        message.referencesBlobs.push($root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 7: {
                                        if (!(message.referencesDirectories && message.referencesDirectories.length))
                                            message.referencesDirectories = [];
                                        message.referencesDirectories.push($root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 8: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PushBlobRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.PushBlobRequest} PushBlobRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushBlobRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PushBlobRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PushBlobRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.uris != null && message.hasOwnProperty("uris")) {
                                if (!Array.isArray(message.uris))
                                    return "uris: array expected";
                                for (let i = 0; i < message.uris.length; ++i)
                                    if (!$util.isString(message.uris[i]))
                                        return "uris: string[] expected";
                            }
                            if (message.qualifiers != null && message.hasOwnProperty("qualifiers")) {
                                if (!Array.isArray(message.qualifiers))
                                    return "qualifiers: array expected";
                                for (let i = 0; i < message.qualifiers.length; ++i) {
                                    let error = $root.build.bazel.remote.asset.v1.Qualifier.verify(message.qualifiers[i]);
                                    if (error)
                                        return "qualifiers." + error;
                                }
                            }
                            if (message.expireAt != null && message.hasOwnProperty("expireAt")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.expireAt);
                                if (error)
                                    return "expireAt." + error;
                            }
                            if (message.blobDigest != null && message.hasOwnProperty("blobDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.blobDigest);
                                if (error)
                                    return "blobDigest." + error;
                            }
                            if (message.referencesBlobs != null && message.hasOwnProperty("referencesBlobs")) {
                                if (!Array.isArray(message.referencesBlobs))
                                    return "referencesBlobs: array expected";
                                for (let i = 0; i < message.referencesBlobs.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.referencesBlobs[i]);
                                    if (error)
                                        return "referencesBlobs." + error;
                                }
                            }
                            if (message.referencesDirectories != null && message.hasOwnProperty("referencesDirectories")) {
                                if (!Array.isArray(message.referencesDirectories))
                                    return "referencesDirectories: array expected";
                                for (let i = 0; i < message.referencesDirectories.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.referencesDirectories[i]);
                                    if (error)
                                        return "referencesDirectories." + error;
                                }
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a PushBlobRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.PushBlobRequest} PushBlobRequest
                         */
                        PushBlobRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.PushBlobRequest)
                                return object;
                            let message = new $root.build.bazel.remote.asset.v1.PushBlobRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.uris) {
                                if (!Array.isArray(object.uris))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.uris: array expected");
                                message.uris = [];
                                for (let i = 0; i < object.uris.length; ++i)
                                    message.uris[i] = String(object.uris[i]);
                            }
                            if (object.qualifiers) {
                                if (!Array.isArray(object.qualifiers))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.qualifiers: array expected");
                                message.qualifiers = [];
                                for (let i = 0; i < object.qualifiers.length; ++i) {
                                    if (typeof object.qualifiers[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.qualifiers: object expected");
                                    message.qualifiers[i] = $root.build.bazel.remote.asset.v1.Qualifier.fromObject(object.qualifiers[i]);
                                }
                            }
                            if (object.expireAt != null) {
                                if (typeof object.expireAt !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.expireAt: object expected");
                                message.expireAt = $root.google.protobuf.Timestamp.fromObject(object.expireAt);
                            }
                            if (object.blobDigest != null) {
                                if (typeof object.blobDigest !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.blobDigest: object expected");
                                message.blobDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.blobDigest);
                            }
                            if (object.referencesBlobs) {
                                if (!Array.isArray(object.referencesBlobs))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.referencesBlobs: array expected");
                                message.referencesBlobs = [];
                                for (let i = 0; i < object.referencesBlobs.length; ++i) {
                                    if (typeof object.referencesBlobs[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.referencesBlobs: object expected");
                                    message.referencesBlobs[i] = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.referencesBlobs[i]);
                                }
                            }
                            if (object.referencesDirectories) {
                                if (!Array.isArray(object.referencesDirectories))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.referencesDirectories: array expected");
                                message.referencesDirectories = [];
                                for (let i = 0; i < object.referencesDirectories.length; ++i) {
                                    if (typeof object.referencesDirectories[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.PushBlobRequest.referencesDirectories: object expected");
                                    message.referencesDirectories[i] = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.referencesDirectories[i]);
                                }
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a PushBlobRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.PushBlobRequest} message PushBlobRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PushBlobRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.uris = [];
                                object.qualifiers = [];
                                object.referencesBlobs = [];
                                object.referencesDirectories = [];
                            }
                            if (options.defaults) {
                                object.instanceName = "";
                                object.expireAt = null;
                                object.blobDigest = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.uris && message.uris.length) {
                                object.uris = [];
                                for (let j = 0; j < message.uris.length; ++j)
                                    object.uris[j] = message.uris[j];
                            }
                            if (message.qualifiers && message.qualifiers.length) {
                                object.qualifiers = [];
                                for (let j = 0; j < message.qualifiers.length; ++j)
                                    object.qualifiers[j] = $root.build.bazel.remote.asset.v1.Qualifier.toObject(message.qualifiers[j], options);
                            }
                            if (message.expireAt != null && message.hasOwnProperty("expireAt"))
                                object.expireAt = $root.google.protobuf.Timestamp.toObject(message.expireAt, options);
                            if (message.blobDigest != null && message.hasOwnProperty("blobDigest"))
                                object.blobDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.blobDigest, options);
                            if (message.referencesBlobs && message.referencesBlobs.length) {
                                object.referencesBlobs = [];
                                for (let j = 0; j < message.referencesBlobs.length; ++j)
                                    object.referencesBlobs[j] = $root.build.bazel.remote.execution.v2.Digest.toObject(message.referencesBlobs[j], options);
                            }
                            if (message.referencesDirectories && message.referencesDirectories.length) {
                                object.referencesDirectories = [];
                                for (let j = 0; j < message.referencesDirectories.length; ++j)
                                    object.referencesDirectories[j] = $root.build.bazel.remote.execution.v2.Digest.toObject(message.referencesDirectories[j], options);
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this PushBlobRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PushBlobRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PushBlobRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.PushBlobRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PushBlobRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.PushBlobRequest";
                        };

                        return PushBlobRequest;
                    })();

                    v1.PushBlobResponse = (function() {

                        /**
                         * Properties of a PushBlobResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IPushBlobResponse
                         */

                        /**
                         * Constructs a new PushBlobResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a PushBlobResponse.
                         * @implements IPushBlobResponse
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IPushBlobResponse=} [properties] Properties to set
                         */
                        function PushBlobResponse(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new PushBlobResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushBlobResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.PushBlobResponse} PushBlobResponse instance
                         */
                        PushBlobResponse.create = function create(properties) {
                            return new PushBlobResponse(properties);
                        };

                        /**
                         * Encodes the specified PushBlobResponse message. Does not implicitly {@link build.bazel.remote.asset.v1.PushBlobResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushBlobResponse} message PushBlobResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushBlobResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified PushBlobResponse message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.PushBlobResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushBlobResponse} message PushBlobResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushBlobResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PushBlobResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.PushBlobResponse} PushBlobResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushBlobResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.PushBlobResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PushBlobResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.PushBlobResponse} PushBlobResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushBlobResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PushBlobResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PushBlobResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a PushBlobResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.PushBlobResponse} PushBlobResponse
                         */
                        PushBlobResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.PushBlobResponse)
                                return object;
                            return new $root.build.bazel.remote.asset.v1.PushBlobResponse();
                        };

                        /**
                         * Creates a plain object from a PushBlobResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.PushBlobResponse} message PushBlobResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PushBlobResponse.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this PushBlobResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PushBlobResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PushBlobResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.PushBlobResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PushBlobResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.PushBlobResponse";
                        };

                        return PushBlobResponse;
                    })();

                    v1.PushDirectoryRequest = (function() {

                        /**
                         * Properties of a PushDirectoryRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IPushDirectoryRequest
                         * @property {string|null} [instanceName] PushDirectoryRequest instanceName
                         * @property {Array.<string>|null} [uris] PushDirectoryRequest uris
                         * @property {Array.<build.bazel.remote.asset.v1.IQualifier>|null} [qualifiers] PushDirectoryRequest qualifiers
                         * @property {google.protobuf.ITimestamp|null} [expireAt] PushDirectoryRequest expireAt
                         * @property {build.bazel.remote.execution.v2.IDigest|null} [rootDirectoryDigest] PushDirectoryRequest rootDirectoryDigest
                         * @property {Array.<build.bazel.remote.execution.v2.IDigest>|null} [referencesBlobs] PushDirectoryRequest referencesBlobs
                         * @property {Array.<build.bazel.remote.execution.v2.IDigest>|null} [referencesDirectories] PushDirectoryRequest referencesDirectories
                         * @property {build.bazel.remote.execution.v2.DigestFunction.Value|null} [digestFunction] PushDirectoryRequest digestFunction
                         */

                        /**
                         * Constructs a new PushDirectoryRequest.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a PushDirectoryRequest.
                         * @implements IPushDirectoryRequest
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryRequest=} [properties] Properties to set
                         */
                        function PushDirectoryRequest(properties) {
                            this.uris = [];
                            this.qualifiers = [];
                            this.referencesBlobs = [];
                            this.referencesDirectories = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PushDirectoryRequest instanceName.
                         * @member {string} instanceName
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.instanceName = "";

                        /**
                         * PushDirectoryRequest uris.
                         * @member {Array.<string>} uris
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.uris = $util.emptyArray;

                        /**
                         * PushDirectoryRequest qualifiers.
                         * @member {Array.<build.bazel.remote.asset.v1.IQualifier>} qualifiers
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.qualifiers = $util.emptyArray;

                        /**
                         * PushDirectoryRequest expireAt.
                         * @member {google.protobuf.ITimestamp|null|undefined} expireAt
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.expireAt = null;

                        /**
                         * PushDirectoryRequest rootDirectoryDigest.
                         * @member {build.bazel.remote.execution.v2.IDigest|null|undefined} rootDirectoryDigest
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.rootDirectoryDigest = null;

                        /**
                         * PushDirectoryRequest referencesBlobs.
                         * @member {Array.<build.bazel.remote.execution.v2.IDigest>} referencesBlobs
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.referencesBlobs = $util.emptyArray;

                        /**
                         * PushDirectoryRequest referencesDirectories.
                         * @member {Array.<build.bazel.remote.execution.v2.IDigest>} referencesDirectories
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.referencesDirectories = $util.emptyArray;

                        /**
                         * PushDirectoryRequest digestFunction.
                         * @member {build.bazel.remote.execution.v2.DigestFunction.Value} digestFunction
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         */
                        PushDirectoryRequest.prototype.digestFunction = 0;

                        /**
                         * Creates a new PushDirectoryRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryRequest} PushDirectoryRequest instance
                         */
                        PushDirectoryRequest.create = function create(properties) {
                            return new PushDirectoryRequest(properties);
                        };

                        /**
                         * Encodes the specified PushDirectoryRequest message. Does not implicitly {@link build.bazel.remote.asset.v1.PushDirectoryRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryRequest} message PushDirectoryRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushDirectoryRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.instanceName != null && Object.hasOwnProperty.call(message, "instanceName"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.instanceName);
                            if (message.uris != null && message.uris.length)
                                for (let i = 0; i < message.uris.length; ++i)
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uris[i]);
                            if (message.qualifiers != null && message.qualifiers.length)
                                for (let i = 0; i < message.qualifiers.length; ++i)
                                    $root.build.bazel.remote.asset.v1.Qualifier.encode(message.qualifiers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            if (message.expireAt != null && Object.hasOwnProperty.call(message, "expireAt"))
                                $root.google.protobuf.Timestamp.encode(message.expireAt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                            if (message.rootDirectoryDigest != null && Object.hasOwnProperty.call(message, "rootDirectoryDigest"))
                                $root.build.bazel.remote.execution.v2.Digest.encode(message.rootDirectoryDigest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                            if (message.referencesBlobs != null && message.referencesBlobs.length)
                                for (let i = 0; i < message.referencesBlobs.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.referencesBlobs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                            if (message.referencesDirectories != null && message.referencesDirectories.length)
                                for (let i = 0; i < message.referencesDirectories.length; ++i)
                                    $root.build.bazel.remote.execution.v2.Digest.encode(message.referencesDirectories[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                            if (message.digestFunction != null && Object.hasOwnProperty.call(message, "digestFunction"))
                                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.digestFunction);
                            return writer;
                        };

                        /**
                         * Encodes the specified PushDirectoryRequest message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.PushDirectoryRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryRequest} message PushDirectoryRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PushDirectoryRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryRequest} PushDirectoryRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushDirectoryRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.PushDirectoryRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.instanceName = reader.string();
                                        break;
                                    }
                                case 2: {
                                        if (!(message.uris && message.uris.length))
                                            message.uris = [];
                                        message.uris.push(reader.string());
                                        break;
                                    }
                                case 3: {
                                        if (!(message.qualifiers && message.qualifiers.length))
                                            message.qualifiers = [];
                                        message.qualifiers.push($root.build.bazel.remote.asset.v1.Qualifier.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 4: {
                                        message.expireAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 5: {
                                        message.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32());
                                        break;
                                    }
                                case 6: {
                                        if (!(message.referencesBlobs && message.referencesBlobs.length))
                                            message.referencesBlobs = [];
                                        message.referencesBlobs.push($root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 7: {
                                        if (!(message.referencesDirectories && message.referencesDirectories.length))
                                            message.referencesDirectories = [];
                                        message.referencesDirectories.push($root.build.bazel.remote.execution.v2.Digest.decode(reader, reader.uint32()));
                                        break;
                                    }
                                case 8: {
                                        message.digestFunction = reader.int32();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PushDirectoryRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryRequest} PushDirectoryRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PushDirectoryRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PushDirectoryRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                if (!$util.isString(message.instanceName))
                                    return "instanceName: string expected";
                            if (message.uris != null && message.hasOwnProperty("uris")) {
                                if (!Array.isArray(message.uris))
                                    return "uris: array expected";
                                for (let i = 0; i < message.uris.length; ++i)
                                    if (!$util.isString(message.uris[i]))
                                        return "uris: string[] expected";
                            }
                            if (message.qualifiers != null && message.hasOwnProperty("qualifiers")) {
                                if (!Array.isArray(message.qualifiers))
                                    return "qualifiers: array expected";
                                for (let i = 0; i < message.qualifiers.length; ++i) {
                                    let error = $root.build.bazel.remote.asset.v1.Qualifier.verify(message.qualifiers[i]);
                                    if (error)
                                        return "qualifiers." + error;
                                }
                            }
                            if (message.expireAt != null && message.hasOwnProperty("expireAt")) {
                                let error = $root.google.protobuf.Timestamp.verify(message.expireAt);
                                if (error)
                                    return "expireAt." + error;
                            }
                            if (message.rootDirectoryDigest != null && message.hasOwnProperty("rootDirectoryDigest")) {
                                let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.rootDirectoryDigest);
                                if (error)
                                    return "rootDirectoryDigest." + error;
                            }
                            if (message.referencesBlobs != null && message.hasOwnProperty("referencesBlobs")) {
                                if (!Array.isArray(message.referencesBlobs))
                                    return "referencesBlobs: array expected";
                                for (let i = 0; i < message.referencesBlobs.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.referencesBlobs[i]);
                                    if (error)
                                        return "referencesBlobs." + error;
                                }
                            }
                            if (message.referencesDirectories != null && message.hasOwnProperty("referencesDirectories")) {
                                if (!Array.isArray(message.referencesDirectories))
                                    return "referencesDirectories: array expected";
                                for (let i = 0; i < message.referencesDirectories.length; ++i) {
                                    let error = $root.build.bazel.remote.execution.v2.Digest.verify(message.referencesDirectories[i]);
                                    if (error)
                                        return "referencesDirectories." + error;
                                }
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                switch (message.digestFunction) {
                                default:
                                    return "digestFunction: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a PushDirectoryRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryRequest} PushDirectoryRequest
                         */
                        PushDirectoryRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.PushDirectoryRequest)
                                return object;
                            let message = new $root.build.bazel.remote.asset.v1.PushDirectoryRequest();
                            if (object.instanceName != null)
                                message.instanceName = String(object.instanceName);
                            if (object.uris) {
                                if (!Array.isArray(object.uris))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.uris: array expected");
                                message.uris = [];
                                for (let i = 0; i < object.uris.length; ++i)
                                    message.uris[i] = String(object.uris[i]);
                            }
                            if (object.qualifiers) {
                                if (!Array.isArray(object.qualifiers))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.qualifiers: array expected");
                                message.qualifiers = [];
                                for (let i = 0; i < object.qualifiers.length; ++i) {
                                    if (typeof object.qualifiers[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.qualifiers: object expected");
                                    message.qualifiers[i] = $root.build.bazel.remote.asset.v1.Qualifier.fromObject(object.qualifiers[i]);
                                }
                            }
                            if (object.expireAt != null) {
                                if (typeof object.expireAt !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.expireAt: object expected");
                                message.expireAt = $root.google.protobuf.Timestamp.fromObject(object.expireAt);
                            }
                            if (object.rootDirectoryDigest != null) {
                                if (typeof object.rootDirectoryDigest !== "object")
                                    throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.rootDirectoryDigest: object expected");
                                message.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.rootDirectoryDigest);
                            }
                            if (object.referencesBlobs) {
                                if (!Array.isArray(object.referencesBlobs))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.referencesBlobs: array expected");
                                message.referencesBlobs = [];
                                for (let i = 0; i < object.referencesBlobs.length; ++i) {
                                    if (typeof object.referencesBlobs[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.referencesBlobs: object expected");
                                    message.referencesBlobs[i] = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.referencesBlobs[i]);
                                }
                            }
                            if (object.referencesDirectories) {
                                if (!Array.isArray(object.referencesDirectories))
                                    throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.referencesDirectories: array expected");
                                message.referencesDirectories = [];
                                for (let i = 0; i < object.referencesDirectories.length; ++i) {
                                    if (typeof object.referencesDirectories[i] !== "object")
                                        throw TypeError(".build.bazel.remote.asset.v1.PushDirectoryRequest.referencesDirectories: object expected");
                                    message.referencesDirectories[i] = $root.build.bazel.remote.execution.v2.Digest.fromObject(object.referencesDirectories[i]);
                                }
                            }
                            switch (object.digestFunction) {
                            default:
                                if (typeof object.digestFunction === "number") {
                                    message.digestFunction = object.digestFunction;
                                    break;
                                }
                                break;
                            case "UNKNOWN":
                            case 0:
                                message.digestFunction = 0;
                                break;
                            case "SHA256":
                            case 1:
                                message.digestFunction = 1;
                                break;
                            case "SHA1":
                            case 2:
                                message.digestFunction = 2;
                                break;
                            case "MD5":
                            case 3:
                                message.digestFunction = 3;
                                break;
                            case "VSO":
                            case 4:
                                message.digestFunction = 4;
                                break;
                            case "SHA384":
                            case 5:
                                message.digestFunction = 5;
                                break;
                            case "SHA512":
                            case 6:
                                message.digestFunction = 6;
                                break;
                            case "MURMUR3":
                            case 7:
                                message.digestFunction = 7;
                                break;
                            case "SHA256TREE":
                            case 8:
                                message.digestFunction = 8;
                                break;
                            case "BLAKE3":
                            case 9:
                                message.digestFunction = 9;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a PushDirectoryRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {build.bazel.remote.asset.v1.PushDirectoryRequest} message PushDirectoryRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PushDirectoryRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.uris = [];
                                object.qualifiers = [];
                                object.referencesBlobs = [];
                                object.referencesDirectories = [];
                            }
                            if (options.defaults) {
                                object.instanceName = "";
                                object.expireAt = null;
                                object.rootDirectoryDigest = null;
                                object.digestFunction = options.enums === String ? "UNKNOWN" : 0;
                            }
                            if (message.instanceName != null && message.hasOwnProperty("instanceName"))
                                object.instanceName = message.instanceName;
                            if (message.uris && message.uris.length) {
                                object.uris = [];
                                for (let j = 0; j < message.uris.length; ++j)
                                    object.uris[j] = message.uris[j];
                            }
                            if (message.qualifiers && message.qualifiers.length) {
                                object.qualifiers = [];
                                for (let j = 0; j < message.qualifiers.length; ++j)
                                    object.qualifiers[j] = $root.build.bazel.remote.asset.v1.Qualifier.toObject(message.qualifiers[j], options);
                            }
                            if (message.expireAt != null && message.hasOwnProperty("expireAt"))
                                object.expireAt = $root.google.protobuf.Timestamp.toObject(message.expireAt, options);
                            if (message.rootDirectoryDigest != null && message.hasOwnProperty("rootDirectoryDigest"))
                                object.rootDirectoryDigest = $root.build.bazel.remote.execution.v2.Digest.toObject(message.rootDirectoryDigest, options);
                            if (message.referencesBlobs && message.referencesBlobs.length) {
                                object.referencesBlobs = [];
                                for (let j = 0; j < message.referencesBlobs.length; ++j)
                                    object.referencesBlobs[j] = $root.build.bazel.remote.execution.v2.Digest.toObject(message.referencesBlobs[j], options);
                            }
                            if (message.referencesDirectories && message.referencesDirectories.length) {
                                object.referencesDirectories = [];
                                for (let j = 0; j < message.referencesDirectories.length; ++j)
                                    object.referencesDirectories[j] = $root.build.bazel.remote.execution.v2.Digest.toObject(message.referencesDirectories[j], options);
                            }
                            if (message.digestFunction != null && message.hasOwnProperty("digestFunction"))
                                object.digestFunction = options.enums === String ? $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] === undefined ? message.digestFunction : $root.build.bazel.remote.execution.v2.DigestFunction.Value[message.digestFunction] : message.digestFunction;
                            return object;
                        };

                        /**
                         * Converts this PushDirectoryRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PushDirectoryRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PushDirectoryRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PushDirectoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.PushDirectoryRequest";
                        };

                        return PushDirectoryRequest;
                    })();

                    v1.PushDirectoryResponse = (function() {

                        /**
                         * Properties of a PushDirectoryResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @interface IPushDirectoryResponse
                         */

                        /**
                         * Constructs a new PushDirectoryResponse.
                         * @memberof build.bazel.remote.asset.v1
                         * @classdesc Represents a PushDirectoryResponse.
                         * @implements IPushDirectoryResponse
                         * @constructor
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryResponse=} [properties] Properties to set
                         */
                        function PushDirectoryResponse(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new PushDirectoryResponse instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryResponse=} [properties] Properties to set
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryResponse} PushDirectoryResponse instance
                         */
                        PushDirectoryResponse.create = function create(properties) {
                            return new PushDirectoryResponse(properties);
                        };

                        /**
                         * Encodes the specified PushDirectoryResponse message. Does not implicitly {@link build.bazel.remote.asset.v1.PushDirectoryResponse.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryResponse} message PushDirectoryResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushDirectoryResponse.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified PushDirectoryResponse message, length delimited. Does not implicitly {@link build.bazel.remote.asset.v1.PushDirectoryResponse.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.IPushDirectoryResponse} message PushDirectoryResponse message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PushDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PushDirectoryResponse message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryResponse} PushDirectoryResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushDirectoryResponse.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.asset.v1.PushDirectoryResponse();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PushDirectoryResponse message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryResponse} PushDirectoryResponse
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PushDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PushDirectoryResponse message.
                         * @function verify
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PushDirectoryResponse.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a PushDirectoryResponse message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.asset.v1.PushDirectoryResponse} PushDirectoryResponse
                         */
                        PushDirectoryResponse.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.asset.v1.PushDirectoryResponse)
                                return object;
                            return new $root.build.bazel.remote.asset.v1.PushDirectoryResponse();
                        };

                        /**
                         * Creates a plain object from a PushDirectoryResponse message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {build.bazel.remote.asset.v1.PushDirectoryResponse} message PushDirectoryResponse
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PushDirectoryResponse.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this PushDirectoryResponse to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PushDirectoryResponse.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for PushDirectoryResponse
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.asset.v1.PushDirectoryResponse
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        PushDirectoryResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.asset.v1.PushDirectoryResponse";
                        };

                        return PushDirectoryResponse;
                    })();

                    return v1;
                })();

                return asset;
            })();

            remote.logstream = (function() {

                /**
                 * Namespace logstream.
                 * @memberof build.bazel.remote
                 * @namespace
                 */
                const logstream = {};

                logstream.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof build.bazel.remote.logstream
                     * @namespace
                     */
                    const v1 = {};

                    v1.LogStreamService = (function() {

                        /**
                         * Constructs a new LogStreamService service.
                         * @memberof build.bazel.remote.logstream.v1
                         * @classdesc Represents a LogStreamService
                         * @extends $protobuf.rpc.Service
                         * @constructor
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         */
                        function LogStreamService(rpcImpl, requestDelimited, responseDelimited) {
                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                        }

                        (LogStreamService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LogStreamService;

                        /**
                         * Creates new LogStreamService service using the specified rpc implementation.
                         * @function create
                         * @memberof build.bazel.remote.logstream.v1.LogStreamService
                         * @static
                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                         * @returns {LogStreamService} RPC service. Useful where requests and/or responses are streamed.
                         */
                        LogStreamService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                            return new this(rpcImpl, requestDelimited, responseDelimited);
                        };

                        /**
                         * Callback as used by {@link build.bazel.remote.logstream.v1.LogStreamService#createLogStream}.
                         * @memberof build.bazel.remote.logstream.v1.LogStreamService
                         * @typedef CreateLogStreamCallback
                         * @type {function}
                         * @param {Error|null} error Error, if any
                         * @param {build.bazel.remote.logstream.v1.LogStream} [response] LogStream
                         */

                        /**
                         * Calls CreateLogStream.
                         * @function createLogStream
                         * @memberof build.bazel.remote.logstream.v1.LogStreamService
                         * @instance
                         * @param {build.bazel.remote.logstream.v1.ICreateLogStreamRequest} request CreateLogStreamRequest message or plain object
                         * @param {build.bazel.remote.logstream.v1.LogStreamService.CreateLogStreamCallback} callback Node-style callback called with the error, if any, and LogStream
                         * @returns {undefined}
                         * @variation 1
                         */
                        Object.defineProperty(LogStreamService.prototype.createLogStream = function createLogStream(request, callback) {
                            return this.rpcCall(createLogStream, $root.build.bazel.remote.logstream.v1.CreateLogStreamRequest, $root.build.bazel.remote.logstream.v1.LogStream, request, callback);
                        }, "name", { value: "CreateLogStream" });

                        /**
                         * Calls CreateLogStream.
                         * @function createLogStream
                         * @memberof build.bazel.remote.logstream.v1.LogStreamService
                         * @instance
                         * @param {build.bazel.remote.logstream.v1.ICreateLogStreamRequest} request CreateLogStreamRequest message or plain object
                         * @returns {Promise<build.bazel.remote.logstream.v1.LogStream>} Promise
                         * @variation 2
                         */

                        return LogStreamService;
                    })();

                    v1.CreateLogStreamRequest = (function() {

                        /**
                         * Properties of a CreateLogStreamRequest.
                         * @memberof build.bazel.remote.logstream.v1
                         * @interface ICreateLogStreamRequest
                         * @property {string|null} [parent] CreateLogStreamRequest parent
                         */

                        /**
                         * Constructs a new CreateLogStreamRequest.
                         * @memberof build.bazel.remote.logstream.v1
                         * @classdesc Represents a CreateLogStreamRequest.
                         * @implements ICreateLogStreamRequest
                         * @constructor
                         * @param {build.bazel.remote.logstream.v1.ICreateLogStreamRequest=} [properties] Properties to set
                         */
                        function CreateLogStreamRequest(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * CreateLogStreamRequest parent.
                         * @member {string} parent
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @instance
                         */
                        CreateLogStreamRequest.prototype.parent = "";

                        /**
                         * Creates a new CreateLogStreamRequest instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {build.bazel.remote.logstream.v1.ICreateLogStreamRequest=} [properties] Properties to set
                         * @returns {build.bazel.remote.logstream.v1.CreateLogStreamRequest} CreateLogStreamRequest instance
                         */
                        CreateLogStreamRequest.create = function create(properties) {
                            return new CreateLogStreamRequest(properties);
                        };

                        /**
                         * Encodes the specified CreateLogStreamRequest message. Does not implicitly {@link build.bazel.remote.logstream.v1.CreateLogStreamRequest.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {build.bazel.remote.logstream.v1.ICreateLogStreamRequest} message CreateLogStreamRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CreateLogStreamRequest.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.parent);
                            return writer;
                        };

                        /**
                         * Encodes the specified CreateLogStreamRequest message, length delimited. Does not implicitly {@link build.bazel.remote.logstream.v1.CreateLogStreamRequest.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {build.bazel.remote.logstream.v1.ICreateLogStreamRequest} message CreateLogStreamRequest message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        CreateLogStreamRequest.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a CreateLogStreamRequest message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.logstream.v1.CreateLogStreamRequest} CreateLogStreamRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CreateLogStreamRequest.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.logstream.v1.CreateLogStreamRequest();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.parent = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a CreateLogStreamRequest message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.logstream.v1.CreateLogStreamRequest} CreateLogStreamRequest
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        CreateLogStreamRequest.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a CreateLogStreamRequest message.
                         * @function verify
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        CreateLogStreamRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.parent != null && message.hasOwnProperty("parent"))
                                if (!$util.isString(message.parent))
                                    return "parent: string expected";
                            return null;
                        };

                        /**
                         * Creates a CreateLogStreamRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.logstream.v1.CreateLogStreamRequest} CreateLogStreamRequest
                         */
                        CreateLogStreamRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.logstream.v1.CreateLogStreamRequest)
                                return object;
                            let message = new $root.build.bazel.remote.logstream.v1.CreateLogStreamRequest();
                            if (object.parent != null)
                                message.parent = String(object.parent);
                            return message;
                        };

                        /**
                         * Creates a plain object from a CreateLogStreamRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {build.bazel.remote.logstream.v1.CreateLogStreamRequest} message CreateLogStreamRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        CreateLogStreamRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.parent = "";
                            if (message.parent != null && message.hasOwnProperty("parent"))
                                object.parent = message.parent;
                            return object;
                        };

                        /**
                         * Converts this CreateLogStreamRequest to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        CreateLogStreamRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for CreateLogStreamRequest
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.logstream.v1.CreateLogStreamRequest
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        CreateLogStreamRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.logstream.v1.CreateLogStreamRequest";
                        };

                        return CreateLogStreamRequest;
                    })();

                    v1.LogStream = (function() {

                        /**
                         * Properties of a LogStream.
                         * @memberof build.bazel.remote.logstream.v1
                         * @interface ILogStream
                         * @property {string|null} [name] LogStream name
                         * @property {string|null} [writeResourceName] LogStream writeResourceName
                         */

                        /**
                         * Constructs a new LogStream.
                         * @memberof build.bazel.remote.logstream.v1
                         * @classdesc Represents a LogStream.
                         * @implements ILogStream
                         * @constructor
                         * @param {build.bazel.remote.logstream.v1.ILogStream=} [properties] Properties to set
                         */
                        function LogStream(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * LogStream name.
                         * @member {string} name
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @instance
                         */
                        LogStream.prototype.name = "";

                        /**
                         * LogStream writeResourceName.
                         * @member {string} writeResourceName
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @instance
                         */
                        LogStream.prototype.writeResourceName = "";

                        /**
                         * Creates a new LogStream instance using the specified properties.
                         * @function create
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {build.bazel.remote.logstream.v1.ILogStream=} [properties] Properties to set
                         * @returns {build.bazel.remote.logstream.v1.LogStream} LogStream instance
                         */
                        LogStream.create = function create(properties) {
                            return new LogStream(properties);
                        };

                        /**
                         * Encodes the specified LogStream message. Does not implicitly {@link build.bazel.remote.logstream.v1.LogStream.verify|verify} messages.
                         * @function encode
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {build.bazel.remote.logstream.v1.ILogStream} message LogStream message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        LogStream.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                            if (message.writeResourceName != null && Object.hasOwnProperty.call(message, "writeResourceName"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.writeResourceName);
                            return writer;
                        };

                        /**
                         * Encodes the specified LogStream message, length delimited. Does not implicitly {@link build.bazel.remote.logstream.v1.LogStream.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {build.bazel.remote.logstream.v1.ILogStream} message LogStream message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        LogStream.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a LogStream message from the specified reader or buffer.
                         * @function decode
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {build.bazel.remote.logstream.v1.LogStream} LogStream
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        LogStream.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.remote.logstream.v1.LogStream();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1: {
                                        message.name = reader.string();
                                        break;
                                    }
                                case 2: {
                                        message.writeResourceName = reader.string();
                                        break;
                                    }
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a LogStream message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {build.bazel.remote.logstream.v1.LogStream} LogStream
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        LogStream.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a LogStream message.
                         * @function verify
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        LogStream.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.writeResourceName != null && message.hasOwnProperty("writeResourceName"))
                                if (!$util.isString(message.writeResourceName))
                                    return "writeResourceName: string expected";
                            return null;
                        };

                        /**
                         * Creates a LogStream message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {build.bazel.remote.logstream.v1.LogStream} LogStream
                         */
                        LogStream.fromObject = function fromObject(object) {
                            if (object instanceof $root.build.bazel.remote.logstream.v1.LogStream)
                                return object;
                            let message = new $root.build.bazel.remote.logstream.v1.LogStream();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.writeResourceName != null)
                                message.writeResourceName = String(object.writeResourceName);
                            return message;
                        };

                        /**
                         * Creates a plain object from a LogStream message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {build.bazel.remote.logstream.v1.LogStream} message LogStream
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        LogStream.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.name = "";
                                object.writeResourceName = "";
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.writeResourceName != null && message.hasOwnProperty("writeResourceName"))
                                object.writeResourceName = message.writeResourceName;
                            return object;
                        };

                        /**
                         * Converts this LogStream to JSON.
                         * @function toJSON
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        LogStream.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Gets the default type url for LogStream
                         * @function getTypeUrl
                         * @memberof build.bazel.remote.logstream.v1.LogStream
                         * @static
                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                         * @returns {string} The default type url
                         */
                        LogStream.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                            if (typeUrlPrefix === undefined) {
                                typeUrlPrefix = "type.googleapis.com";
                            }
                            return typeUrlPrefix + "/build.bazel.remote.logstream.v1.LogStream";
                        };

                        return LogStream;
                    })();

                    return v1;
                })();

                return logstream;
            })();

            return remote;
        })();

        bazel.semver = (function() {

            /**
             * Namespace semver.
             * @memberof build.bazel
             * @namespace
             */
            const semver = {};

            semver.SemVer = (function() {

                /**
                 * Properties of a SemVer.
                 * @memberof build.bazel.semver
                 * @interface ISemVer
                 * @property {number|null} [major] SemVer major
                 * @property {number|null} [minor] SemVer minor
                 * @property {number|null} [patch] SemVer patch
                 * @property {string|null} [prerelease] SemVer prerelease
                 */

                /**
                 * Constructs a new SemVer.
                 * @memberof build.bazel.semver
                 * @classdesc Represents a SemVer.
                 * @implements ISemVer
                 * @constructor
                 * @param {build.bazel.semver.ISemVer=} [properties] Properties to set
                 */
                function SemVer(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SemVer major.
                 * @member {number} major
                 * @memberof build.bazel.semver.SemVer
                 * @instance
                 */
                SemVer.prototype.major = 0;

                /**
                 * SemVer minor.
                 * @member {number} minor
                 * @memberof build.bazel.semver.SemVer
                 * @instance
                 */
                SemVer.prototype.minor = 0;

                /**
                 * SemVer patch.
                 * @member {number} patch
                 * @memberof build.bazel.semver.SemVer
                 * @instance
                 */
                SemVer.prototype.patch = 0;

                /**
                 * SemVer prerelease.
                 * @member {string} prerelease
                 * @memberof build.bazel.semver.SemVer
                 * @instance
                 */
                SemVer.prototype.prerelease = "";

                /**
                 * Creates a new SemVer instance using the specified properties.
                 * @function create
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {build.bazel.semver.ISemVer=} [properties] Properties to set
                 * @returns {build.bazel.semver.SemVer} SemVer instance
                 */
                SemVer.create = function create(properties) {
                    return new SemVer(properties);
                };

                /**
                 * Encodes the specified SemVer message. Does not implicitly {@link build.bazel.semver.SemVer.verify|verify} messages.
                 * @function encode
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {build.bazel.semver.ISemVer} message SemVer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SemVer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.major != null && Object.hasOwnProperty.call(message, "major"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.major);
                    if (message.minor != null && Object.hasOwnProperty.call(message, "minor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minor);
                    if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.patch);
                    if (message.prerelease != null && Object.hasOwnProperty.call(message, "prerelease"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.prerelease);
                    return writer;
                };

                /**
                 * Encodes the specified SemVer message, length delimited. Does not implicitly {@link build.bazel.semver.SemVer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {build.bazel.semver.ISemVer} message SemVer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SemVer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SemVer message from the specified reader or buffer.
                 * @function decode
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {build.bazel.semver.SemVer} SemVer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SemVer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.build.bazel.semver.SemVer();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.major = reader.int32();
                                break;
                            }
                        case 2: {
                                message.minor = reader.int32();
                                break;
                            }
                        case 3: {
                                message.patch = reader.int32();
                                break;
                            }
                        case 4: {
                                message.prerelease = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SemVer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {build.bazel.semver.SemVer} SemVer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SemVer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SemVer message.
                 * @function verify
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SemVer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.major != null && message.hasOwnProperty("major"))
                        if (!$util.isInteger(message.major))
                            return "major: integer expected";
                    if (message.minor != null && message.hasOwnProperty("minor"))
                        if (!$util.isInteger(message.minor))
                            return "minor: integer expected";
                    if (message.patch != null && message.hasOwnProperty("patch"))
                        if (!$util.isInteger(message.patch))
                            return "patch: integer expected";
                    if (message.prerelease != null && message.hasOwnProperty("prerelease"))
                        if (!$util.isString(message.prerelease))
                            return "prerelease: string expected";
                    return null;
                };

                /**
                 * Creates a SemVer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {build.bazel.semver.SemVer} SemVer
                 */
                SemVer.fromObject = function fromObject(object) {
                    if (object instanceof $root.build.bazel.semver.SemVer)
                        return object;
                    let message = new $root.build.bazel.semver.SemVer();
                    if (object.major != null)
                        message.major = object.major | 0;
                    if (object.minor != null)
                        message.minor = object.minor | 0;
                    if (object.patch != null)
                        message.patch = object.patch | 0;
                    if (object.prerelease != null)
                        message.prerelease = String(object.prerelease);
                    return message;
                };

                /**
                 * Creates a plain object from a SemVer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {build.bazel.semver.SemVer} message SemVer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SemVer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.major = 0;
                        object.minor = 0;
                        object.patch = 0;
                        object.prerelease = "";
                    }
                    if (message.major != null && message.hasOwnProperty("major"))
                        object.major = message.major;
                    if (message.minor != null && message.hasOwnProperty("minor"))
                        object.minor = message.minor;
                    if (message.patch != null && message.hasOwnProperty("patch"))
                        object.patch = message.patch;
                    if (message.prerelease != null && message.hasOwnProperty("prerelease"))
                        object.prerelease = message.prerelease;
                    return object;
                };

                /**
                 * Converts this SemVer to JSON.
                 * @function toJSON
                 * @memberof build.bazel.semver.SemVer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SemVer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SemVer
                 * @function getTypeUrl
                 * @memberof build.bazel.semver.SemVer
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SemVer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/build.bazel.semver.SemVer";
                };

                return SemVer;
            })();

            return semver;
        })();

        return bazel;
    })();

    return build;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        const api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             * @property {boolean|null} [fullyDecodeReservedExpansion] Http fullyDecodeReservedExpansion
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Http fullyDecodeReservedExpansion.
             * @member {boolean} fullyDecodeReservedExpansion
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.fullyDecodeReservedExpansion = false;

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp=} [properties] Properties to set
             * @returns {google.api.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encode
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rules != null && message.rules.length)
                    for (let i = 0; i < message.rules.length; ++i)
                        $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.fullyDecodeReservedExpansion != null && Object.hasOwnProperty.call(message, "fullyDecodeReservedExpansion"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fullyDecodeReservedExpansion);
                return writer;
            };

            /**
             * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.rules && message.rules.length))
                                message.rules = [];
                            message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.fullyDecodeReservedExpansion = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Http message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (let i = 0; i < message.rules.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                if (message.fullyDecodeReservedExpansion != null && message.hasOwnProperty("fullyDecodeReservedExpansion"))
                    if (typeof message.fullyDecodeReservedExpansion !== "boolean")
                        return "fullyDecodeReservedExpansion: boolean expected";
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Http)
                    return object;
                let message = new $root.google.api.Http();
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".google.api.Http.rules: array expected");
                    message.rules = [];
                    for (let i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".google.api.Http.rules: object expected");
                        message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                    }
                }
                if (object.fullyDecodeReservedExpansion != null)
                    message.fullyDecodeReservedExpansion = Boolean(object.fullyDecodeReservedExpansion);
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Http
             * @static
             * @param {google.api.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (options.defaults)
                    object.fullyDecodeReservedExpansion = false;
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (let j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                }
                if (message.fullyDecodeReservedExpansion != null && message.hasOwnProperty("fullyDecodeReservedExpansion"))
                    object.fullyDecodeReservedExpansion = message.fullyDecodeReservedExpansion;
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof google.api.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Http
             * @function getTypeUrl
             * @memberof google.api.Http
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Http.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.Http";
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [body] HttpRule body
             * @property {string|null} [responseBody] HttpRule responseBody
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule get.
             * @member {string|null|undefined} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = null;

            /**
             * HttpRule put.
             * @member {string|null|undefined} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = null;

            /**
             * HttpRule post.
             * @member {string|null|undefined} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = null;

            /**
             * HttpRule delete.
             * @member {string|null|undefined} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = null;

            /**
             * HttpRule patch.
             * @member {string|null|undefined} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = null;

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule responseBody.
             * @member {string} responseBody
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.responseBody = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new HttpRule instance using the specified properties.
             * @function create
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule=} [properties] Properties to set
             * @returns {google.api.HttpRule} HttpRule instance
             */
            HttpRule.create = function create(properties) {
                return new HttpRule(properties);
            };

            /**
             * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encode
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selector != null && Object.hasOwnProperty.call(message, "selector"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                if (message.get != null && Object.hasOwnProperty.call(message, "get"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                if (message.put != null && Object.hasOwnProperty.call(message, "put"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                if (message["delete"] != null && Object.hasOwnProperty.call(message, "delete"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                if (message.patch != null && Object.hasOwnProperty.call(message, "patch"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
                    $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.additionalBindings != null && message.additionalBindings.length)
                    for (let i = 0; i < message.additionalBindings.length; ++i)
                        $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.responseBody != null && Object.hasOwnProperty.call(message, "responseBody"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.responseBody);
                return writer;
            };

            /**
             * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.selector = reader.string();
                            break;
                        }
                    case 2: {
                            message.get = reader.string();
                            break;
                        }
                    case 3: {
                            message.put = reader.string();
                            break;
                        }
                    case 4: {
                            message.post = reader.string();
                            break;
                        }
                    case 5: {
                            message["delete"] = reader.string();
                            break;
                        }
                    case 6: {
                            message.patch = reader.string();
                            break;
                        }
                    case 8: {
                            message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.body = reader.string();
                            break;
                        }
                    case 12: {
                            message.responseBody = reader.string();
                            break;
                        }
                    case 11: {
                            if (!(message.additionalBindings && message.additionalBindings.length))
                                message.additionalBindings = [];
                            message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        let error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.responseBody != null && message.hasOwnProperty("responseBody"))
                    if (!$util.isString(message.responseBody))
                        return "responseBody: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (let i = 0; i < message.additionalBindings.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                let message = new $root.google.api.HttpRule();
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.body != null)
                    message.body = String(object.body);
                if (object.responseBody != null)
                    message.responseBody = String(object.responseBody);
                if (object.additionalBindings) {
                    if (!Array.isArray(object.additionalBindings))
                        throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
                    message.additionalBindings = [];
                    for (let i = 0; i < object.additionalBindings.length; ++i) {
                        if (typeof object.additionalBindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
                        message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.additionalBindings = [];
                if (options.defaults) {
                    object.selector = "";
                    object.body = "";
                    object.responseBody = "";
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additionalBindings && message.additionalBindings.length) {
                    object.additionalBindings = [];
                    for (let j = 0; j < message.additionalBindings.length; ++j)
                        object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
                }
                if (message.responseBody != null && message.hasOwnProperty("responseBody"))
                    object.responseBody = message.responseBody;
                return object;
            };

            /**
             * Converts this HttpRule to JSON.
             * @function toJSON
             * @memberof google.api.HttpRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HttpRule
             * @function getTypeUrl
             * @memberof google.api.HttpRule
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HttpRule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.HttpRule";
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Creates a new CustomHttpPattern instance using the specified properties.
             * @function create
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
             */
            CustomHttpPattern.create = function create(properties) {
                return new CustomHttpPattern(properties);
            };

            /**
             * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.string();
                            break;
                        }
                    case 2: {
                            message.path = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                let message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @function toJSON
             * @memberof google.api.CustomHttpPattern
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CustomHttpPattern
             * @function getTypeUrl
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CustomHttpPattern.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.CustomHttpPattern";
            };

            return CustomHttpPattern;
        })();

        api.CommonLanguageSettings = (function() {

            /**
             * Properties of a CommonLanguageSettings.
             * @memberof google.api
             * @interface ICommonLanguageSettings
             * @property {string|null} [referenceDocsUri] CommonLanguageSettings referenceDocsUri
             * @property {Array.<google.api.ClientLibraryDestination>|null} [destinations] CommonLanguageSettings destinations
             * @property {google.api.ISelectiveGapicGeneration|null} [selectiveGapicGeneration] CommonLanguageSettings selectiveGapicGeneration
             */

            /**
             * Constructs a new CommonLanguageSettings.
             * @memberof google.api
             * @classdesc Represents a CommonLanguageSettings.
             * @implements ICommonLanguageSettings
             * @constructor
             * @param {google.api.ICommonLanguageSettings=} [properties] Properties to set
             */
            function CommonLanguageSettings(properties) {
                this.destinations = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommonLanguageSettings referenceDocsUri.
             * @member {string} referenceDocsUri
             * @memberof google.api.CommonLanguageSettings
             * @instance
             */
            CommonLanguageSettings.prototype.referenceDocsUri = "";

            /**
             * CommonLanguageSettings destinations.
             * @member {Array.<google.api.ClientLibraryDestination>} destinations
             * @memberof google.api.CommonLanguageSettings
             * @instance
             */
            CommonLanguageSettings.prototype.destinations = $util.emptyArray;

            /**
             * CommonLanguageSettings selectiveGapicGeneration.
             * @member {google.api.ISelectiveGapicGeneration|null|undefined} selectiveGapicGeneration
             * @memberof google.api.CommonLanguageSettings
             * @instance
             */
            CommonLanguageSettings.prototype.selectiveGapicGeneration = null;

            /**
             * Creates a new CommonLanguageSettings instance using the specified properties.
             * @function create
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {google.api.ICommonLanguageSettings=} [properties] Properties to set
             * @returns {google.api.CommonLanguageSettings} CommonLanguageSettings instance
             */
            CommonLanguageSettings.create = function create(properties) {
                return new CommonLanguageSettings(properties);
            };

            /**
             * Encodes the specified CommonLanguageSettings message. Does not implicitly {@link google.api.CommonLanguageSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {google.api.ICommonLanguageSettings} message CommonLanguageSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommonLanguageSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.referenceDocsUri != null && Object.hasOwnProperty.call(message, "referenceDocsUri"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.referenceDocsUri);
                if (message.destinations != null && message.destinations.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.destinations.length; ++i)
                        writer.int32(message.destinations[i]);
                    writer.ldelim();
                }
                if (message.selectiveGapicGeneration != null && Object.hasOwnProperty.call(message, "selectiveGapicGeneration"))
                    $root.google.api.SelectiveGapicGeneration.encode(message.selectiveGapicGeneration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CommonLanguageSettings message, length delimited. Does not implicitly {@link google.api.CommonLanguageSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {google.api.ICommonLanguageSettings} message CommonLanguageSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommonLanguageSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommonLanguageSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CommonLanguageSettings} CommonLanguageSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommonLanguageSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CommonLanguageSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.referenceDocsUri = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.destinations && message.destinations.length))
                                message.destinations = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.destinations.push(reader.int32());
                            } else
                                message.destinations.push(reader.int32());
                            break;
                        }
                    case 3: {
                            message.selectiveGapicGeneration = $root.google.api.SelectiveGapicGeneration.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommonLanguageSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CommonLanguageSettings} CommonLanguageSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommonLanguageSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommonLanguageSettings message.
             * @function verify
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommonLanguageSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.referenceDocsUri != null && message.hasOwnProperty("referenceDocsUri"))
                    if (!$util.isString(message.referenceDocsUri))
                        return "referenceDocsUri: string expected";
                if (message.destinations != null && message.hasOwnProperty("destinations")) {
                    if (!Array.isArray(message.destinations))
                        return "destinations: array expected";
                    for (let i = 0; i < message.destinations.length; ++i)
                        switch (message.destinations[i]) {
                        default:
                            return "destinations: enum value[] expected";
                        case 0:
                        case 10:
                        case 20:
                            break;
                        }
                }
                if (message.selectiveGapicGeneration != null && message.hasOwnProperty("selectiveGapicGeneration")) {
                    let error = $root.google.api.SelectiveGapicGeneration.verify(message.selectiveGapicGeneration);
                    if (error)
                        return "selectiveGapicGeneration." + error;
                }
                return null;
            };

            /**
             * Creates a CommonLanguageSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CommonLanguageSettings} CommonLanguageSettings
             */
            CommonLanguageSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CommonLanguageSettings)
                    return object;
                let message = new $root.google.api.CommonLanguageSettings();
                if (object.referenceDocsUri != null)
                    message.referenceDocsUri = String(object.referenceDocsUri);
                if (object.destinations) {
                    if (!Array.isArray(object.destinations))
                        throw TypeError(".google.api.CommonLanguageSettings.destinations: array expected");
                    message.destinations = [];
                    for (let i = 0; i < object.destinations.length; ++i)
                        switch (object.destinations[i]) {
                        default:
                            if (typeof object.destinations[i] === "number") {
                                message.destinations[i] = object.destinations[i];
                                break;
                            }
                        case "CLIENT_LIBRARY_DESTINATION_UNSPECIFIED":
                        case 0:
                            message.destinations[i] = 0;
                            break;
                        case "GITHUB":
                        case 10:
                            message.destinations[i] = 10;
                            break;
                        case "PACKAGE_MANAGER":
                        case 20:
                            message.destinations[i] = 20;
                            break;
                        }
                }
                if (object.selectiveGapicGeneration != null) {
                    if (typeof object.selectiveGapicGeneration !== "object")
                        throw TypeError(".google.api.CommonLanguageSettings.selectiveGapicGeneration: object expected");
                    message.selectiveGapicGeneration = $root.google.api.SelectiveGapicGeneration.fromObject(object.selectiveGapicGeneration);
                }
                return message;
            };

            /**
             * Creates a plain object from a CommonLanguageSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {google.api.CommonLanguageSettings} message CommonLanguageSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommonLanguageSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.destinations = [];
                if (options.defaults) {
                    object.referenceDocsUri = "";
                    object.selectiveGapicGeneration = null;
                }
                if (message.referenceDocsUri != null && message.hasOwnProperty("referenceDocsUri"))
                    object.referenceDocsUri = message.referenceDocsUri;
                if (message.destinations && message.destinations.length) {
                    object.destinations = [];
                    for (let j = 0; j < message.destinations.length; ++j)
                        object.destinations[j] = options.enums === String ? $root.google.api.ClientLibraryDestination[message.destinations[j]] === undefined ? message.destinations[j] : $root.google.api.ClientLibraryDestination[message.destinations[j]] : message.destinations[j];
                }
                if (message.selectiveGapicGeneration != null && message.hasOwnProperty("selectiveGapicGeneration"))
                    object.selectiveGapicGeneration = $root.google.api.SelectiveGapicGeneration.toObject(message.selectiveGapicGeneration, options);
                return object;
            };

            /**
             * Converts this CommonLanguageSettings to JSON.
             * @function toJSON
             * @memberof google.api.CommonLanguageSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommonLanguageSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CommonLanguageSettings
             * @function getTypeUrl
             * @memberof google.api.CommonLanguageSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CommonLanguageSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.CommonLanguageSettings";
            };

            return CommonLanguageSettings;
        })();

        api.ClientLibrarySettings = (function() {

            /**
             * Properties of a ClientLibrarySettings.
             * @memberof google.api
             * @interface IClientLibrarySettings
             * @property {string|null} [version] ClientLibrarySettings version
             * @property {google.api.LaunchStage|null} [launchStage] ClientLibrarySettings launchStage
             * @property {boolean|null} [restNumericEnums] ClientLibrarySettings restNumericEnums
             * @property {google.api.IJavaSettings|null} [javaSettings] ClientLibrarySettings javaSettings
             * @property {google.api.ICppSettings|null} [cppSettings] ClientLibrarySettings cppSettings
             * @property {google.api.IPhpSettings|null} [phpSettings] ClientLibrarySettings phpSettings
             * @property {google.api.IPythonSettings|null} [pythonSettings] ClientLibrarySettings pythonSettings
             * @property {google.api.INodeSettings|null} [nodeSettings] ClientLibrarySettings nodeSettings
             * @property {google.api.IDotnetSettings|null} [dotnetSettings] ClientLibrarySettings dotnetSettings
             * @property {google.api.IRubySettings|null} [rubySettings] ClientLibrarySettings rubySettings
             * @property {google.api.IGoSettings|null} [goSettings] ClientLibrarySettings goSettings
             */

            /**
             * Constructs a new ClientLibrarySettings.
             * @memberof google.api
             * @classdesc Represents a ClientLibrarySettings.
             * @implements IClientLibrarySettings
             * @constructor
             * @param {google.api.IClientLibrarySettings=} [properties] Properties to set
             */
            function ClientLibrarySettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClientLibrarySettings version.
             * @member {string} version
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.version = "";

            /**
             * ClientLibrarySettings launchStage.
             * @member {google.api.LaunchStage} launchStage
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.launchStage = 0;

            /**
             * ClientLibrarySettings restNumericEnums.
             * @member {boolean} restNumericEnums
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.restNumericEnums = false;

            /**
             * ClientLibrarySettings javaSettings.
             * @member {google.api.IJavaSettings|null|undefined} javaSettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.javaSettings = null;

            /**
             * ClientLibrarySettings cppSettings.
             * @member {google.api.ICppSettings|null|undefined} cppSettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.cppSettings = null;

            /**
             * ClientLibrarySettings phpSettings.
             * @member {google.api.IPhpSettings|null|undefined} phpSettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.phpSettings = null;

            /**
             * ClientLibrarySettings pythonSettings.
             * @member {google.api.IPythonSettings|null|undefined} pythonSettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.pythonSettings = null;

            /**
             * ClientLibrarySettings nodeSettings.
             * @member {google.api.INodeSettings|null|undefined} nodeSettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.nodeSettings = null;

            /**
             * ClientLibrarySettings dotnetSettings.
             * @member {google.api.IDotnetSettings|null|undefined} dotnetSettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.dotnetSettings = null;

            /**
             * ClientLibrarySettings rubySettings.
             * @member {google.api.IRubySettings|null|undefined} rubySettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.rubySettings = null;

            /**
             * ClientLibrarySettings goSettings.
             * @member {google.api.IGoSettings|null|undefined} goSettings
             * @memberof google.api.ClientLibrarySettings
             * @instance
             */
            ClientLibrarySettings.prototype.goSettings = null;

            /**
             * Creates a new ClientLibrarySettings instance using the specified properties.
             * @function create
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {google.api.IClientLibrarySettings=} [properties] Properties to set
             * @returns {google.api.ClientLibrarySettings} ClientLibrarySettings instance
             */
            ClientLibrarySettings.create = function create(properties) {
                return new ClientLibrarySettings(properties);
            };

            /**
             * Encodes the specified ClientLibrarySettings message. Does not implicitly {@link google.api.ClientLibrarySettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {google.api.IClientLibrarySettings} message ClientLibrarySettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClientLibrarySettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.launchStage != null && Object.hasOwnProperty.call(message, "launchStage"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.launchStage);
                if (message.restNumericEnums != null && Object.hasOwnProperty.call(message, "restNumericEnums"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.restNumericEnums);
                if (message.javaSettings != null && Object.hasOwnProperty.call(message, "javaSettings"))
                    $root.google.api.JavaSettings.encode(message.javaSettings, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.cppSettings != null && Object.hasOwnProperty.call(message, "cppSettings"))
                    $root.google.api.CppSettings.encode(message.cppSettings, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.phpSettings != null && Object.hasOwnProperty.call(message, "phpSettings"))
                    $root.google.api.PhpSettings.encode(message.phpSettings, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.pythonSettings != null && Object.hasOwnProperty.call(message, "pythonSettings"))
                    $root.google.api.PythonSettings.encode(message.pythonSettings, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.nodeSettings != null && Object.hasOwnProperty.call(message, "nodeSettings"))
                    $root.google.api.NodeSettings.encode(message.nodeSettings, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.dotnetSettings != null && Object.hasOwnProperty.call(message, "dotnetSettings"))
                    $root.google.api.DotnetSettings.encode(message.dotnetSettings, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.rubySettings != null && Object.hasOwnProperty.call(message, "rubySettings"))
                    $root.google.api.RubySettings.encode(message.rubySettings, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                if (message.goSettings != null && Object.hasOwnProperty.call(message, "goSettings"))
                    $root.google.api.GoSettings.encode(message.goSettings, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ClientLibrarySettings message, length delimited. Does not implicitly {@link google.api.ClientLibrarySettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {google.api.IClientLibrarySettings} message ClientLibrarySettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClientLibrarySettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClientLibrarySettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.ClientLibrarySettings} ClientLibrarySettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClientLibrarySettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.ClientLibrarySettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.version = reader.string();
                            break;
                        }
                    case 2: {
                            message.launchStage = reader.int32();
                            break;
                        }
                    case 3: {
                            message.restNumericEnums = reader.bool();
                            break;
                        }
                    case 21: {
                            message.javaSettings = $root.google.api.JavaSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.cppSettings = $root.google.api.CppSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.phpSettings = $root.google.api.PhpSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.pythonSettings = $root.google.api.PythonSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.nodeSettings = $root.google.api.NodeSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.dotnetSettings = $root.google.api.DotnetSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 27: {
                            message.rubySettings = $root.google.api.RubySettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 28: {
                            message.goSettings = $root.google.api.GoSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClientLibrarySettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.ClientLibrarySettings} ClientLibrarySettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClientLibrarySettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClientLibrarySettings message.
             * @function verify
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClientLibrarySettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.launchStage != null && message.hasOwnProperty("launchStage"))
                    switch (message.launchStage) {
                    default:
                        return "launchStage: enum value expected";
                    case 0:
                    case 6:
                    case 7:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.restNumericEnums != null && message.hasOwnProperty("restNumericEnums"))
                    if (typeof message.restNumericEnums !== "boolean")
                        return "restNumericEnums: boolean expected";
                if (message.javaSettings != null && message.hasOwnProperty("javaSettings")) {
                    let error = $root.google.api.JavaSettings.verify(message.javaSettings);
                    if (error)
                        return "javaSettings." + error;
                }
                if (message.cppSettings != null && message.hasOwnProperty("cppSettings")) {
                    let error = $root.google.api.CppSettings.verify(message.cppSettings);
                    if (error)
                        return "cppSettings." + error;
                }
                if (message.phpSettings != null && message.hasOwnProperty("phpSettings")) {
                    let error = $root.google.api.PhpSettings.verify(message.phpSettings);
                    if (error)
                        return "phpSettings." + error;
                }
                if (message.pythonSettings != null && message.hasOwnProperty("pythonSettings")) {
                    let error = $root.google.api.PythonSettings.verify(message.pythonSettings);
                    if (error)
                        return "pythonSettings." + error;
                }
                if (message.nodeSettings != null && message.hasOwnProperty("nodeSettings")) {
                    let error = $root.google.api.NodeSettings.verify(message.nodeSettings);
                    if (error)
                        return "nodeSettings." + error;
                }
                if (message.dotnetSettings != null && message.hasOwnProperty("dotnetSettings")) {
                    let error = $root.google.api.DotnetSettings.verify(message.dotnetSettings);
                    if (error)
                        return "dotnetSettings." + error;
                }
                if (message.rubySettings != null && message.hasOwnProperty("rubySettings")) {
                    let error = $root.google.api.RubySettings.verify(message.rubySettings);
                    if (error)
                        return "rubySettings." + error;
                }
                if (message.goSettings != null && message.hasOwnProperty("goSettings")) {
                    let error = $root.google.api.GoSettings.verify(message.goSettings);
                    if (error)
                        return "goSettings." + error;
                }
                return null;
            };

            /**
             * Creates a ClientLibrarySettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.ClientLibrarySettings} ClientLibrarySettings
             */
            ClientLibrarySettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.ClientLibrarySettings)
                    return object;
                let message = new $root.google.api.ClientLibrarySettings();
                if (object.version != null)
                    message.version = String(object.version);
                switch (object.launchStage) {
                default:
                    if (typeof object.launchStage === "number") {
                        message.launchStage = object.launchStage;
                        break;
                    }
                    break;
                case "LAUNCH_STAGE_UNSPECIFIED":
                case 0:
                    message.launchStage = 0;
                    break;
                case "UNIMPLEMENTED":
                case 6:
                    message.launchStage = 6;
                    break;
                case "PRELAUNCH":
                case 7:
                    message.launchStage = 7;
                    break;
                case "EARLY_ACCESS":
                case 1:
                    message.launchStage = 1;
                    break;
                case "ALPHA":
                case 2:
                    message.launchStage = 2;
                    break;
                case "BETA":
                case 3:
                    message.launchStage = 3;
                    break;
                case "GA":
                case 4:
                    message.launchStage = 4;
                    break;
                case "DEPRECATED":
                case 5:
                    message.launchStage = 5;
                    break;
                }
                if (object.restNumericEnums != null)
                    message.restNumericEnums = Boolean(object.restNumericEnums);
                if (object.javaSettings != null) {
                    if (typeof object.javaSettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.javaSettings: object expected");
                    message.javaSettings = $root.google.api.JavaSettings.fromObject(object.javaSettings);
                }
                if (object.cppSettings != null) {
                    if (typeof object.cppSettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.cppSettings: object expected");
                    message.cppSettings = $root.google.api.CppSettings.fromObject(object.cppSettings);
                }
                if (object.phpSettings != null) {
                    if (typeof object.phpSettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.phpSettings: object expected");
                    message.phpSettings = $root.google.api.PhpSettings.fromObject(object.phpSettings);
                }
                if (object.pythonSettings != null) {
                    if (typeof object.pythonSettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.pythonSettings: object expected");
                    message.pythonSettings = $root.google.api.PythonSettings.fromObject(object.pythonSettings);
                }
                if (object.nodeSettings != null) {
                    if (typeof object.nodeSettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.nodeSettings: object expected");
                    message.nodeSettings = $root.google.api.NodeSettings.fromObject(object.nodeSettings);
                }
                if (object.dotnetSettings != null) {
                    if (typeof object.dotnetSettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.dotnetSettings: object expected");
                    message.dotnetSettings = $root.google.api.DotnetSettings.fromObject(object.dotnetSettings);
                }
                if (object.rubySettings != null) {
                    if (typeof object.rubySettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.rubySettings: object expected");
                    message.rubySettings = $root.google.api.RubySettings.fromObject(object.rubySettings);
                }
                if (object.goSettings != null) {
                    if (typeof object.goSettings !== "object")
                        throw TypeError(".google.api.ClientLibrarySettings.goSettings: object expected");
                    message.goSettings = $root.google.api.GoSettings.fromObject(object.goSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a ClientLibrarySettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {google.api.ClientLibrarySettings} message ClientLibrarySettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClientLibrarySettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.version = "";
                    object.launchStage = options.enums === String ? "LAUNCH_STAGE_UNSPECIFIED" : 0;
                    object.restNumericEnums = false;
                    object.javaSettings = null;
                    object.cppSettings = null;
                    object.phpSettings = null;
                    object.pythonSettings = null;
                    object.nodeSettings = null;
                    object.dotnetSettings = null;
                    object.rubySettings = null;
                    object.goSettings = null;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.launchStage != null && message.hasOwnProperty("launchStage"))
                    object.launchStage = options.enums === String ? $root.google.api.LaunchStage[message.launchStage] === undefined ? message.launchStage : $root.google.api.LaunchStage[message.launchStage] : message.launchStage;
                if (message.restNumericEnums != null && message.hasOwnProperty("restNumericEnums"))
                    object.restNumericEnums = message.restNumericEnums;
                if (message.javaSettings != null && message.hasOwnProperty("javaSettings"))
                    object.javaSettings = $root.google.api.JavaSettings.toObject(message.javaSettings, options);
                if (message.cppSettings != null && message.hasOwnProperty("cppSettings"))
                    object.cppSettings = $root.google.api.CppSettings.toObject(message.cppSettings, options);
                if (message.phpSettings != null && message.hasOwnProperty("phpSettings"))
                    object.phpSettings = $root.google.api.PhpSettings.toObject(message.phpSettings, options);
                if (message.pythonSettings != null && message.hasOwnProperty("pythonSettings"))
                    object.pythonSettings = $root.google.api.PythonSettings.toObject(message.pythonSettings, options);
                if (message.nodeSettings != null && message.hasOwnProperty("nodeSettings"))
                    object.nodeSettings = $root.google.api.NodeSettings.toObject(message.nodeSettings, options);
                if (message.dotnetSettings != null && message.hasOwnProperty("dotnetSettings"))
                    object.dotnetSettings = $root.google.api.DotnetSettings.toObject(message.dotnetSettings, options);
                if (message.rubySettings != null && message.hasOwnProperty("rubySettings"))
                    object.rubySettings = $root.google.api.RubySettings.toObject(message.rubySettings, options);
                if (message.goSettings != null && message.hasOwnProperty("goSettings"))
                    object.goSettings = $root.google.api.GoSettings.toObject(message.goSettings, options);
                return object;
            };

            /**
             * Converts this ClientLibrarySettings to JSON.
             * @function toJSON
             * @memberof google.api.ClientLibrarySettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClientLibrarySettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClientLibrarySettings
             * @function getTypeUrl
             * @memberof google.api.ClientLibrarySettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClientLibrarySettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.ClientLibrarySettings";
            };

            return ClientLibrarySettings;
        })();

        api.Publishing = (function() {

            /**
             * Properties of a Publishing.
             * @memberof google.api
             * @interface IPublishing
             * @property {Array.<google.api.IMethodSettings>|null} [methodSettings] Publishing methodSettings
             * @property {string|null} [newIssueUri] Publishing newIssueUri
             * @property {string|null} [documentationUri] Publishing documentationUri
             * @property {string|null} [apiShortName] Publishing apiShortName
             * @property {string|null} [githubLabel] Publishing githubLabel
             * @property {Array.<string>|null} [codeownerGithubTeams] Publishing codeownerGithubTeams
             * @property {string|null} [docTagPrefix] Publishing docTagPrefix
             * @property {google.api.ClientLibraryOrganization|null} [organization] Publishing organization
             * @property {Array.<google.api.IClientLibrarySettings>|null} [librarySettings] Publishing librarySettings
             * @property {string|null} [protoReferenceDocumentationUri] Publishing protoReferenceDocumentationUri
             * @property {string|null} [restReferenceDocumentationUri] Publishing restReferenceDocumentationUri
             */

            /**
             * Constructs a new Publishing.
             * @memberof google.api
             * @classdesc Represents a Publishing.
             * @implements IPublishing
             * @constructor
             * @param {google.api.IPublishing=} [properties] Properties to set
             */
            function Publishing(properties) {
                this.methodSettings = [];
                this.codeownerGithubTeams = [];
                this.librarySettings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Publishing methodSettings.
             * @member {Array.<google.api.IMethodSettings>} methodSettings
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.methodSettings = $util.emptyArray;

            /**
             * Publishing newIssueUri.
             * @member {string} newIssueUri
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.newIssueUri = "";

            /**
             * Publishing documentationUri.
             * @member {string} documentationUri
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.documentationUri = "";

            /**
             * Publishing apiShortName.
             * @member {string} apiShortName
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.apiShortName = "";

            /**
             * Publishing githubLabel.
             * @member {string} githubLabel
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.githubLabel = "";

            /**
             * Publishing codeownerGithubTeams.
             * @member {Array.<string>} codeownerGithubTeams
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.codeownerGithubTeams = $util.emptyArray;

            /**
             * Publishing docTagPrefix.
             * @member {string} docTagPrefix
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.docTagPrefix = "";

            /**
             * Publishing organization.
             * @member {google.api.ClientLibraryOrganization} organization
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.organization = 0;

            /**
             * Publishing librarySettings.
             * @member {Array.<google.api.IClientLibrarySettings>} librarySettings
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.librarySettings = $util.emptyArray;

            /**
             * Publishing protoReferenceDocumentationUri.
             * @member {string} protoReferenceDocumentationUri
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.protoReferenceDocumentationUri = "";

            /**
             * Publishing restReferenceDocumentationUri.
             * @member {string} restReferenceDocumentationUri
             * @memberof google.api.Publishing
             * @instance
             */
            Publishing.prototype.restReferenceDocumentationUri = "";

            /**
             * Creates a new Publishing instance using the specified properties.
             * @function create
             * @memberof google.api.Publishing
             * @static
             * @param {google.api.IPublishing=} [properties] Properties to set
             * @returns {google.api.Publishing} Publishing instance
             */
            Publishing.create = function create(properties) {
                return new Publishing(properties);
            };

            /**
             * Encodes the specified Publishing message. Does not implicitly {@link google.api.Publishing.verify|verify} messages.
             * @function encode
             * @memberof google.api.Publishing
             * @static
             * @param {google.api.IPublishing} message Publishing message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Publishing.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.methodSettings != null && message.methodSettings.length)
                    for (let i = 0; i < message.methodSettings.length; ++i)
                        $root.google.api.MethodSettings.encode(message.methodSettings[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.newIssueUri != null && Object.hasOwnProperty.call(message, "newIssueUri"))
                    writer.uint32(/* id 101, wireType 2 =*/810).string(message.newIssueUri);
                if (message.documentationUri != null && Object.hasOwnProperty.call(message, "documentationUri"))
                    writer.uint32(/* id 102, wireType 2 =*/818).string(message.documentationUri);
                if (message.apiShortName != null && Object.hasOwnProperty.call(message, "apiShortName"))
                    writer.uint32(/* id 103, wireType 2 =*/826).string(message.apiShortName);
                if (message.githubLabel != null && Object.hasOwnProperty.call(message, "githubLabel"))
                    writer.uint32(/* id 104, wireType 2 =*/834).string(message.githubLabel);
                if (message.codeownerGithubTeams != null && message.codeownerGithubTeams.length)
                    for (let i = 0; i < message.codeownerGithubTeams.length; ++i)
                        writer.uint32(/* id 105, wireType 2 =*/842).string(message.codeownerGithubTeams[i]);
                if (message.docTagPrefix != null && Object.hasOwnProperty.call(message, "docTagPrefix"))
                    writer.uint32(/* id 106, wireType 2 =*/850).string(message.docTagPrefix);
                if (message.organization != null && Object.hasOwnProperty.call(message, "organization"))
                    writer.uint32(/* id 107, wireType 0 =*/856).int32(message.organization);
                if (message.librarySettings != null && message.librarySettings.length)
                    for (let i = 0; i < message.librarySettings.length; ++i)
                        $root.google.api.ClientLibrarySettings.encode(message.librarySettings[i], writer.uint32(/* id 109, wireType 2 =*/874).fork()).ldelim();
                if (message.protoReferenceDocumentationUri != null && Object.hasOwnProperty.call(message, "protoReferenceDocumentationUri"))
                    writer.uint32(/* id 110, wireType 2 =*/882).string(message.protoReferenceDocumentationUri);
                if (message.restReferenceDocumentationUri != null && Object.hasOwnProperty.call(message, "restReferenceDocumentationUri"))
                    writer.uint32(/* id 111, wireType 2 =*/890).string(message.restReferenceDocumentationUri);
                return writer;
            };

            /**
             * Encodes the specified Publishing message, length delimited. Does not implicitly {@link google.api.Publishing.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.Publishing
             * @static
             * @param {google.api.IPublishing} message Publishing message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Publishing.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Publishing message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.Publishing
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.Publishing} Publishing
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Publishing.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Publishing();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            if (!(message.methodSettings && message.methodSettings.length))
                                message.methodSettings = [];
                            message.methodSettings.push($root.google.api.MethodSettings.decode(reader, reader.uint32()));
                            break;
                        }
                    case 101: {
                            message.newIssueUri = reader.string();
                            break;
                        }
                    case 102: {
                            message.documentationUri = reader.string();
                            break;
                        }
                    case 103: {
                            message.apiShortName = reader.string();
                            break;
                        }
                    case 104: {
                            message.githubLabel = reader.string();
                            break;
                        }
                    case 105: {
                            if (!(message.codeownerGithubTeams && message.codeownerGithubTeams.length))
                                message.codeownerGithubTeams = [];
                            message.codeownerGithubTeams.push(reader.string());
                            break;
                        }
                    case 106: {
                            message.docTagPrefix = reader.string();
                            break;
                        }
                    case 107: {
                            message.organization = reader.int32();
                            break;
                        }
                    case 109: {
                            if (!(message.librarySettings && message.librarySettings.length))
                                message.librarySettings = [];
                            message.librarySettings.push($root.google.api.ClientLibrarySettings.decode(reader, reader.uint32()));
                            break;
                        }
                    case 110: {
                            message.protoReferenceDocumentationUri = reader.string();
                            break;
                        }
                    case 111: {
                            message.restReferenceDocumentationUri = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Publishing message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.Publishing
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.Publishing} Publishing
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Publishing.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Publishing message.
             * @function verify
             * @memberof google.api.Publishing
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Publishing.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.methodSettings != null && message.hasOwnProperty("methodSettings")) {
                    if (!Array.isArray(message.methodSettings))
                        return "methodSettings: array expected";
                    for (let i = 0; i < message.methodSettings.length; ++i) {
                        let error = $root.google.api.MethodSettings.verify(message.methodSettings[i]);
                        if (error)
                            return "methodSettings." + error;
                    }
                }
                if (message.newIssueUri != null && message.hasOwnProperty("newIssueUri"))
                    if (!$util.isString(message.newIssueUri))
                        return "newIssueUri: string expected";
                if (message.documentationUri != null && message.hasOwnProperty("documentationUri"))
                    if (!$util.isString(message.documentationUri))
                        return "documentationUri: string expected";
                if (message.apiShortName != null && message.hasOwnProperty("apiShortName"))
                    if (!$util.isString(message.apiShortName))
                        return "apiShortName: string expected";
                if (message.githubLabel != null && message.hasOwnProperty("githubLabel"))
                    if (!$util.isString(message.githubLabel))
                        return "githubLabel: string expected";
                if (message.codeownerGithubTeams != null && message.hasOwnProperty("codeownerGithubTeams")) {
                    if (!Array.isArray(message.codeownerGithubTeams))
                        return "codeownerGithubTeams: array expected";
                    for (let i = 0; i < message.codeownerGithubTeams.length; ++i)
                        if (!$util.isString(message.codeownerGithubTeams[i]))
                            return "codeownerGithubTeams: string[] expected";
                }
                if (message.docTagPrefix != null && message.hasOwnProperty("docTagPrefix"))
                    if (!$util.isString(message.docTagPrefix))
                        return "docTagPrefix: string expected";
                if (message.organization != null && message.hasOwnProperty("organization"))
                    switch (message.organization) {
                    default:
                        return "organization: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.librarySettings != null && message.hasOwnProperty("librarySettings")) {
                    if (!Array.isArray(message.librarySettings))
                        return "librarySettings: array expected";
                    for (let i = 0; i < message.librarySettings.length; ++i) {
                        let error = $root.google.api.ClientLibrarySettings.verify(message.librarySettings[i]);
                        if (error)
                            return "librarySettings." + error;
                    }
                }
                if (message.protoReferenceDocumentationUri != null && message.hasOwnProperty("protoReferenceDocumentationUri"))
                    if (!$util.isString(message.protoReferenceDocumentationUri))
                        return "protoReferenceDocumentationUri: string expected";
                if (message.restReferenceDocumentationUri != null && message.hasOwnProperty("restReferenceDocumentationUri"))
                    if (!$util.isString(message.restReferenceDocumentationUri))
                        return "restReferenceDocumentationUri: string expected";
                return null;
            };

            /**
             * Creates a Publishing message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Publishing
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Publishing} Publishing
             */
            Publishing.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Publishing)
                    return object;
                let message = new $root.google.api.Publishing();
                if (object.methodSettings) {
                    if (!Array.isArray(object.methodSettings))
                        throw TypeError(".google.api.Publishing.methodSettings: array expected");
                    message.methodSettings = [];
                    for (let i = 0; i < object.methodSettings.length; ++i) {
                        if (typeof object.methodSettings[i] !== "object")
                            throw TypeError(".google.api.Publishing.methodSettings: object expected");
                        message.methodSettings[i] = $root.google.api.MethodSettings.fromObject(object.methodSettings[i]);
                    }
                }
                if (object.newIssueUri != null)
                    message.newIssueUri = String(object.newIssueUri);
                if (object.documentationUri != null)
                    message.documentationUri = String(object.documentationUri);
                if (object.apiShortName != null)
                    message.apiShortName = String(object.apiShortName);
                if (object.githubLabel != null)
                    message.githubLabel = String(object.githubLabel);
                if (object.codeownerGithubTeams) {
                    if (!Array.isArray(object.codeownerGithubTeams))
                        throw TypeError(".google.api.Publishing.codeownerGithubTeams: array expected");
                    message.codeownerGithubTeams = [];
                    for (let i = 0; i < object.codeownerGithubTeams.length; ++i)
                        message.codeownerGithubTeams[i] = String(object.codeownerGithubTeams[i]);
                }
                if (object.docTagPrefix != null)
                    message.docTagPrefix = String(object.docTagPrefix);
                switch (object.organization) {
                default:
                    if (typeof object.organization === "number") {
                        message.organization = object.organization;
                        break;
                    }
                    break;
                case "CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED":
                case 0:
                    message.organization = 0;
                    break;
                case "CLOUD":
                case 1:
                    message.organization = 1;
                    break;
                case "ADS":
                case 2:
                    message.organization = 2;
                    break;
                case "PHOTOS":
                case 3:
                    message.organization = 3;
                    break;
                case "STREET_VIEW":
                case 4:
                    message.organization = 4;
                    break;
                case "SHOPPING":
                case 5:
                    message.organization = 5;
                    break;
                case "GEO":
                case 6:
                    message.organization = 6;
                    break;
                case "GENERATIVE_AI":
                case 7:
                    message.organization = 7;
                    break;
                }
                if (object.librarySettings) {
                    if (!Array.isArray(object.librarySettings))
                        throw TypeError(".google.api.Publishing.librarySettings: array expected");
                    message.librarySettings = [];
                    for (let i = 0; i < object.librarySettings.length; ++i) {
                        if (typeof object.librarySettings[i] !== "object")
                            throw TypeError(".google.api.Publishing.librarySettings: object expected");
                        message.librarySettings[i] = $root.google.api.ClientLibrarySettings.fromObject(object.librarySettings[i]);
                    }
                }
                if (object.protoReferenceDocumentationUri != null)
                    message.protoReferenceDocumentationUri = String(object.protoReferenceDocumentationUri);
                if (object.restReferenceDocumentationUri != null)
                    message.restReferenceDocumentationUri = String(object.restReferenceDocumentationUri);
                return message;
            };

            /**
             * Creates a plain object from a Publishing message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Publishing
             * @static
             * @param {google.api.Publishing} message Publishing
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Publishing.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.methodSettings = [];
                    object.codeownerGithubTeams = [];
                    object.librarySettings = [];
                }
                if (options.defaults) {
                    object.newIssueUri = "";
                    object.documentationUri = "";
                    object.apiShortName = "";
                    object.githubLabel = "";
                    object.docTagPrefix = "";
                    object.organization = options.enums === String ? "CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED" : 0;
                    object.protoReferenceDocumentationUri = "";
                    object.restReferenceDocumentationUri = "";
                }
                if (message.methodSettings && message.methodSettings.length) {
                    object.methodSettings = [];
                    for (let j = 0; j < message.methodSettings.length; ++j)
                        object.methodSettings[j] = $root.google.api.MethodSettings.toObject(message.methodSettings[j], options);
                }
                if (message.newIssueUri != null && message.hasOwnProperty("newIssueUri"))
                    object.newIssueUri = message.newIssueUri;
                if (message.documentationUri != null && message.hasOwnProperty("documentationUri"))
                    object.documentationUri = message.documentationUri;
                if (message.apiShortName != null && message.hasOwnProperty("apiShortName"))
                    object.apiShortName = message.apiShortName;
                if (message.githubLabel != null && message.hasOwnProperty("githubLabel"))
                    object.githubLabel = message.githubLabel;
                if (message.codeownerGithubTeams && message.codeownerGithubTeams.length) {
                    object.codeownerGithubTeams = [];
                    for (let j = 0; j < message.codeownerGithubTeams.length; ++j)
                        object.codeownerGithubTeams[j] = message.codeownerGithubTeams[j];
                }
                if (message.docTagPrefix != null && message.hasOwnProperty("docTagPrefix"))
                    object.docTagPrefix = message.docTagPrefix;
                if (message.organization != null && message.hasOwnProperty("organization"))
                    object.organization = options.enums === String ? $root.google.api.ClientLibraryOrganization[message.organization] === undefined ? message.organization : $root.google.api.ClientLibraryOrganization[message.organization] : message.organization;
                if (message.librarySettings && message.librarySettings.length) {
                    object.librarySettings = [];
                    for (let j = 0; j < message.librarySettings.length; ++j)
                        object.librarySettings[j] = $root.google.api.ClientLibrarySettings.toObject(message.librarySettings[j], options);
                }
                if (message.protoReferenceDocumentationUri != null && message.hasOwnProperty("protoReferenceDocumentationUri"))
                    object.protoReferenceDocumentationUri = message.protoReferenceDocumentationUri;
                if (message.restReferenceDocumentationUri != null && message.hasOwnProperty("restReferenceDocumentationUri"))
                    object.restReferenceDocumentationUri = message.restReferenceDocumentationUri;
                return object;
            };

            /**
             * Converts this Publishing to JSON.
             * @function toJSON
             * @memberof google.api.Publishing
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Publishing.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Publishing
             * @function getTypeUrl
             * @memberof google.api.Publishing
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Publishing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.Publishing";
            };

            return Publishing;
        })();

        api.JavaSettings = (function() {

            /**
             * Properties of a JavaSettings.
             * @memberof google.api
             * @interface IJavaSettings
             * @property {string|null} [libraryPackage] JavaSettings libraryPackage
             * @property {Object.<string,string>|null} [serviceClassNames] JavaSettings serviceClassNames
             * @property {google.api.ICommonLanguageSettings|null} [common] JavaSettings common
             */

            /**
             * Constructs a new JavaSettings.
             * @memberof google.api
             * @classdesc Represents a JavaSettings.
             * @implements IJavaSettings
             * @constructor
             * @param {google.api.IJavaSettings=} [properties] Properties to set
             */
            function JavaSettings(properties) {
                this.serviceClassNames = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JavaSettings libraryPackage.
             * @member {string} libraryPackage
             * @memberof google.api.JavaSettings
             * @instance
             */
            JavaSettings.prototype.libraryPackage = "";

            /**
             * JavaSettings serviceClassNames.
             * @member {Object.<string,string>} serviceClassNames
             * @memberof google.api.JavaSettings
             * @instance
             */
            JavaSettings.prototype.serviceClassNames = $util.emptyObject;

            /**
             * JavaSettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.JavaSettings
             * @instance
             */
            JavaSettings.prototype.common = null;

            /**
             * Creates a new JavaSettings instance using the specified properties.
             * @function create
             * @memberof google.api.JavaSettings
             * @static
             * @param {google.api.IJavaSettings=} [properties] Properties to set
             * @returns {google.api.JavaSettings} JavaSettings instance
             */
            JavaSettings.create = function create(properties) {
                return new JavaSettings(properties);
            };

            /**
             * Encodes the specified JavaSettings message. Does not implicitly {@link google.api.JavaSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.JavaSettings
             * @static
             * @param {google.api.IJavaSettings} message JavaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JavaSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.libraryPackage != null && Object.hasOwnProperty.call(message, "libraryPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.libraryPackage);
                if (message.serviceClassNames != null && Object.hasOwnProperty.call(message, "serviceClassNames"))
                    for (let keys = Object.keys(message.serviceClassNames), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.serviceClassNames[keys[i]]).ldelim();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified JavaSettings message, length delimited. Does not implicitly {@link google.api.JavaSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.JavaSettings
             * @static
             * @param {google.api.IJavaSettings} message JavaSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JavaSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JavaSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.JavaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.JavaSettings} JavaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JavaSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.JavaSettings(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.libraryPackage = reader.string();
                            break;
                        }
                    case 2: {
                            if (message.serviceClassNames === $util.emptyObject)
                                message.serviceClassNames = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.serviceClassNames[key] = value;
                            break;
                        }
                    case 3: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JavaSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.JavaSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.JavaSettings} JavaSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JavaSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JavaSettings message.
             * @function verify
             * @memberof google.api.JavaSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JavaSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.libraryPackage != null && message.hasOwnProperty("libraryPackage"))
                    if (!$util.isString(message.libraryPackage))
                        return "libraryPackage: string expected";
                if (message.serviceClassNames != null && message.hasOwnProperty("serviceClassNames")) {
                    if (!$util.isObject(message.serviceClassNames))
                        return "serviceClassNames: object expected";
                    let key = Object.keys(message.serviceClassNames);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.serviceClassNames[key[i]]))
                            return "serviceClassNames: string{k:string} expected";
                }
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                return null;
            };

            /**
             * Creates a JavaSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.JavaSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.JavaSettings} JavaSettings
             */
            JavaSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.JavaSettings)
                    return object;
                let message = new $root.google.api.JavaSettings();
                if (object.libraryPackage != null)
                    message.libraryPackage = String(object.libraryPackage);
                if (object.serviceClassNames) {
                    if (typeof object.serviceClassNames !== "object")
                        throw TypeError(".google.api.JavaSettings.serviceClassNames: object expected");
                    message.serviceClassNames = {};
                    for (let keys = Object.keys(object.serviceClassNames), i = 0; i < keys.length; ++i)
                        message.serviceClassNames[keys[i]] = String(object.serviceClassNames[keys[i]]);
                }
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.JavaSettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                return message;
            };

            /**
             * Creates a plain object from a JavaSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.JavaSettings
             * @static
             * @param {google.api.JavaSettings} message JavaSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JavaSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.serviceClassNames = {};
                if (options.defaults) {
                    object.libraryPackage = "";
                    object.common = null;
                }
                if (message.libraryPackage != null && message.hasOwnProperty("libraryPackage"))
                    object.libraryPackage = message.libraryPackage;
                let keys2;
                if (message.serviceClassNames && (keys2 = Object.keys(message.serviceClassNames)).length) {
                    object.serviceClassNames = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.serviceClassNames[keys2[j]] = message.serviceClassNames[keys2[j]];
                }
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                return object;
            };

            /**
             * Converts this JavaSettings to JSON.
             * @function toJSON
             * @memberof google.api.JavaSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JavaSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JavaSettings
             * @function getTypeUrl
             * @memberof google.api.JavaSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JavaSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.JavaSettings";
            };

            return JavaSettings;
        })();

        api.CppSettings = (function() {

            /**
             * Properties of a CppSettings.
             * @memberof google.api
             * @interface ICppSettings
             * @property {google.api.ICommonLanguageSettings|null} [common] CppSettings common
             */

            /**
             * Constructs a new CppSettings.
             * @memberof google.api
             * @classdesc Represents a CppSettings.
             * @implements ICppSettings
             * @constructor
             * @param {google.api.ICppSettings=} [properties] Properties to set
             */
            function CppSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CppSettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.CppSettings
             * @instance
             */
            CppSettings.prototype.common = null;

            /**
             * Creates a new CppSettings instance using the specified properties.
             * @function create
             * @memberof google.api.CppSettings
             * @static
             * @param {google.api.ICppSettings=} [properties] Properties to set
             * @returns {google.api.CppSettings} CppSettings instance
             */
            CppSettings.create = function create(properties) {
                return new CppSettings(properties);
            };

            /**
             * Encodes the specified CppSettings message. Does not implicitly {@link google.api.CppSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.CppSettings
             * @static
             * @param {google.api.ICppSettings} message CppSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CppSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CppSettings message, length delimited. Does not implicitly {@link google.api.CppSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.CppSettings
             * @static
             * @param {google.api.ICppSettings} message CppSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CppSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CppSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CppSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CppSettings} CppSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CppSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CppSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CppSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.CppSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CppSettings} CppSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CppSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CppSettings message.
             * @function verify
             * @memberof google.api.CppSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CppSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                return null;
            };

            /**
             * Creates a CppSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CppSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CppSettings} CppSettings
             */
            CppSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CppSettings)
                    return object;
                let message = new $root.google.api.CppSettings();
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.CppSettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                return message;
            };

            /**
             * Creates a plain object from a CppSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CppSettings
             * @static
             * @param {google.api.CppSettings} message CppSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CppSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.common = null;
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                return object;
            };

            /**
             * Converts this CppSettings to JSON.
             * @function toJSON
             * @memberof google.api.CppSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CppSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CppSettings
             * @function getTypeUrl
             * @memberof google.api.CppSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CppSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.CppSettings";
            };

            return CppSettings;
        })();

        api.PhpSettings = (function() {

            /**
             * Properties of a PhpSettings.
             * @memberof google.api
             * @interface IPhpSettings
             * @property {google.api.ICommonLanguageSettings|null} [common] PhpSettings common
             */

            /**
             * Constructs a new PhpSettings.
             * @memberof google.api
             * @classdesc Represents a PhpSettings.
             * @implements IPhpSettings
             * @constructor
             * @param {google.api.IPhpSettings=} [properties] Properties to set
             */
            function PhpSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PhpSettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.PhpSettings
             * @instance
             */
            PhpSettings.prototype.common = null;

            /**
             * Creates a new PhpSettings instance using the specified properties.
             * @function create
             * @memberof google.api.PhpSettings
             * @static
             * @param {google.api.IPhpSettings=} [properties] Properties to set
             * @returns {google.api.PhpSettings} PhpSettings instance
             */
            PhpSettings.create = function create(properties) {
                return new PhpSettings(properties);
            };

            /**
             * Encodes the specified PhpSettings message. Does not implicitly {@link google.api.PhpSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.PhpSettings
             * @static
             * @param {google.api.IPhpSettings} message PhpSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhpSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PhpSettings message, length delimited. Does not implicitly {@link google.api.PhpSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.PhpSettings
             * @static
             * @param {google.api.IPhpSettings} message PhpSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhpSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PhpSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.PhpSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.PhpSettings} PhpSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhpSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.PhpSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PhpSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.PhpSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.PhpSettings} PhpSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhpSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PhpSettings message.
             * @function verify
             * @memberof google.api.PhpSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PhpSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                return null;
            };

            /**
             * Creates a PhpSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.PhpSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.PhpSettings} PhpSettings
             */
            PhpSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.PhpSettings)
                    return object;
                let message = new $root.google.api.PhpSettings();
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.PhpSettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                return message;
            };

            /**
             * Creates a plain object from a PhpSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.PhpSettings
             * @static
             * @param {google.api.PhpSettings} message PhpSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PhpSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.common = null;
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                return object;
            };

            /**
             * Converts this PhpSettings to JSON.
             * @function toJSON
             * @memberof google.api.PhpSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PhpSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PhpSettings
             * @function getTypeUrl
             * @memberof google.api.PhpSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PhpSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.PhpSettings";
            };

            return PhpSettings;
        })();

        api.PythonSettings = (function() {

            /**
             * Properties of a PythonSettings.
             * @memberof google.api
             * @interface IPythonSettings
             * @property {google.api.ICommonLanguageSettings|null} [common] PythonSettings common
             * @property {google.api.PythonSettings.IExperimentalFeatures|null} [experimentalFeatures] PythonSettings experimentalFeatures
             */

            /**
             * Constructs a new PythonSettings.
             * @memberof google.api
             * @classdesc Represents a PythonSettings.
             * @implements IPythonSettings
             * @constructor
             * @param {google.api.IPythonSettings=} [properties] Properties to set
             */
            function PythonSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PythonSettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.PythonSettings
             * @instance
             */
            PythonSettings.prototype.common = null;

            /**
             * PythonSettings experimentalFeatures.
             * @member {google.api.PythonSettings.IExperimentalFeatures|null|undefined} experimentalFeatures
             * @memberof google.api.PythonSettings
             * @instance
             */
            PythonSettings.prototype.experimentalFeatures = null;

            /**
             * Creates a new PythonSettings instance using the specified properties.
             * @function create
             * @memberof google.api.PythonSettings
             * @static
             * @param {google.api.IPythonSettings=} [properties] Properties to set
             * @returns {google.api.PythonSettings} PythonSettings instance
             */
            PythonSettings.create = function create(properties) {
                return new PythonSettings(properties);
            };

            /**
             * Encodes the specified PythonSettings message. Does not implicitly {@link google.api.PythonSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.PythonSettings
             * @static
             * @param {google.api.IPythonSettings} message PythonSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PythonSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.experimentalFeatures != null && Object.hasOwnProperty.call(message, "experimentalFeatures"))
                    $root.google.api.PythonSettings.ExperimentalFeatures.encode(message.experimentalFeatures, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PythonSettings message, length delimited. Does not implicitly {@link google.api.PythonSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.PythonSettings
             * @static
             * @param {google.api.IPythonSettings} message PythonSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PythonSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PythonSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.PythonSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.PythonSettings} PythonSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PythonSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.PythonSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.experimentalFeatures = $root.google.api.PythonSettings.ExperimentalFeatures.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PythonSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.PythonSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.PythonSettings} PythonSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PythonSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PythonSettings message.
             * @function verify
             * @memberof google.api.PythonSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PythonSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                if (message.experimentalFeatures != null && message.hasOwnProperty("experimentalFeatures")) {
                    let error = $root.google.api.PythonSettings.ExperimentalFeatures.verify(message.experimentalFeatures);
                    if (error)
                        return "experimentalFeatures." + error;
                }
                return null;
            };

            /**
             * Creates a PythonSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.PythonSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.PythonSettings} PythonSettings
             */
            PythonSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.PythonSettings)
                    return object;
                let message = new $root.google.api.PythonSettings();
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.PythonSettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                if (object.experimentalFeatures != null) {
                    if (typeof object.experimentalFeatures !== "object")
                        throw TypeError(".google.api.PythonSettings.experimentalFeatures: object expected");
                    message.experimentalFeatures = $root.google.api.PythonSettings.ExperimentalFeatures.fromObject(object.experimentalFeatures);
                }
                return message;
            };

            /**
             * Creates a plain object from a PythonSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.PythonSettings
             * @static
             * @param {google.api.PythonSettings} message PythonSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PythonSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.common = null;
                    object.experimentalFeatures = null;
                }
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                if (message.experimentalFeatures != null && message.hasOwnProperty("experimentalFeatures"))
                    object.experimentalFeatures = $root.google.api.PythonSettings.ExperimentalFeatures.toObject(message.experimentalFeatures, options);
                return object;
            };

            /**
             * Converts this PythonSettings to JSON.
             * @function toJSON
             * @memberof google.api.PythonSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PythonSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PythonSettings
             * @function getTypeUrl
             * @memberof google.api.PythonSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PythonSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.PythonSettings";
            };

            PythonSettings.ExperimentalFeatures = (function() {

                /**
                 * Properties of an ExperimentalFeatures.
                 * @memberof google.api.PythonSettings
                 * @interface IExperimentalFeatures
                 * @property {boolean|null} [restAsyncIoEnabled] ExperimentalFeatures restAsyncIoEnabled
                 * @property {boolean|null} [protobufPythonicTypesEnabled] ExperimentalFeatures protobufPythonicTypesEnabled
                 * @property {boolean|null} [unversionedPackageDisabled] ExperimentalFeatures unversionedPackageDisabled
                 */

                /**
                 * Constructs a new ExperimentalFeatures.
                 * @memberof google.api.PythonSettings
                 * @classdesc Represents an ExperimentalFeatures.
                 * @implements IExperimentalFeatures
                 * @constructor
                 * @param {google.api.PythonSettings.IExperimentalFeatures=} [properties] Properties to set
                 */
                function ExperimentalFeatures(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExperimentalFeatures restAsyncIoEnabled.
                 * @member {boolean} restAsyncIoEnabled
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @instance
                 */
                ExperimentalFeatures.prototype.restAsyncIoEnabled = false;

                /**
                 * ExperimentalFeatures protobufPythonicTypesEnabled.
                 * @member {boolean} protobufPythonicTypesEnabled
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @instance
                 */
                ExperimentalFeatures.prototype.protobufPythonicTypesEnabled = false;

                /**
                 * ExperimentalFeatures unversionedPackageDisabled.
                 * @member {boolean} unversionedPackageDisabled
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @instance
                 */
                ExperimentalFeatures.prototype.unversionedPackageDisabled = false;

                /**
                 * Creates a new ExperimentalFeatures instance using the specified properties.
                 * @function create
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {google.api.PythonSettings.IExperimentalFeatures=} [properties] Properties to set
                 * @returns {google.api.PythonSettings.ExperimentalFeatures} ExperimentalFeatures instance
                 */
                ExperimentalFeatures.create = function create(properties) {
                    return new ExperimentalFeatures(properties);
                };

                /**
                 * Encodes the specified ExperimentalFeatures message. Does not implicitly {@link google.api.PythonSettings.ExperimentalFeatures.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {google.api.PythonSettings.IExperimentalFeatures} message ExperimentalFeatures message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExperimentalFeatures.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.restAsyncIoEnabled != null && Object.hasOwnProperty.call(message, "restAsyncIoEnabled"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.restAsyncIoEnabled);
                    if (message.protobufPythonicTypesEnabled != null && Object.hasOwnProperty.call(message, "protobufPythonicTypesEnabled"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.protobufPythonicTypesEnabled);
                    if (message.unversionedPackageDisabled != null && Object.hasOwnProperty.call(message, "unversionedPackageDisabled"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.unversionedPackageDisabled);
                    return writer;
                };

                /**
                 * Encodes the specified ExperimentalFeatures message, length delimited. Does not implicitly {@link google.api.PythonSettings.ExperimentalFeatures.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {google.api.PythonSettings.IExperimentalFeatures} message ExperimentalFeatures message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExperimentalFeatures.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExperimentalFeatures message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.PythonSettings.ExperimentalFeatures} ExperimentalFeatures
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExperimentalFeatures.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.PythonSettings.ExperimentalFeatures();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.restAsyncIoEnabled = reader.bool();
                                break;
                            }
                        case 2: {
                                message.protobufPythonicTypesEnabled = reader.bool();
                                break;
                            }
                        case 3: {
                                message.unversionedPackageDisabled = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExperimentalFeatures message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.api.PythonSettings.ExperimentalFeatures} ExperimentalFeatures
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExperimentalFeatures.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExperimentalFeatures message.
                 * @function verify
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExperimentalFeatures.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.restAsyncIoEnabled != null && message.hasOwnProperty("restAsyncIoEnabled"))
                        if (typeof message.restAsyncIoEnabled !== "boolean")
                            return "restAsyncIoEnabled: boolean expected";
                    if (message.protobufPythonicTypesEnabled != null && message.hasOwnProperty("protobufPythonicTypesEnabled"))
                        if (typeof message.protobufPythonicTypesEnabled !== "boolean")
                            return "protobufPythonicTypesEnabled: boolean expected";
                    if (message.unversionedPackageDisabled != null && message.hasOwnProperty("unversionedPackageDisabled"))
                        if (typeof message.unversionedPackageDisabled !== "boolean")
                            return "unversionedPackageDisabled: boolean expected";
                    return null;
                };

                /**
                 * Creates an ExperimentalFeatures message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.api.PythonSettings.ExperimentalFeatures} ExperimentalFeatures
                 */
                ExperimentalFeatures.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.api.PythonSettings.ExperimentalFeatures)
                        return object;
                    let message = new $root.google.api.PythonSettings.ExperimentalFeatures();
                    if (object.restAsyncIoEnabled != null)
                        message.restAsyncIoEnabled = Boolean(object.restAsyncIoEnabled);
                    if (object.protobufPythonicTypesEnabled != null)
                        message.protobufPythonicTypesEnabled = Boolean(object.protobufPythonicTypesEnabled);
                    if (object.unversionedPackageDisabled != null)
                        message.unversionedPackageDisabled = Boolean(object.unversionedPackageDisabled);
                    return message;
                };

                /**
                 * Creates a plain object from an ExperimentalFeatures message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {google.api.PythonSettings.ExperimentalFeatures} message ExperimentalFeatures
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExperimentalFeatures.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.restAsyncIoEnabled = false;
                        object.protobufPythonicTypesEnabled = false;
                        object.unversionedPackageDisabled = false;
                    }
                    if (message.restAsyncIoEnabled != null && message.hasOwnProperty("restAsyncIoEnabled"))
                        object.restAsyncIoEnabled = message.restAsyncIoEnabled;
                    if (message.protobufPythonicTypesEnabled != null && message.hasOwnProperty("protobufPythonicTypesEnabled"))
                        object.protobufPythonicTypesEnabled = message.protobufPythonicTypesEnabled;
                    if (message.unversionedPackageDisabled != null && message.hasOwnProperty("unversionedPackageDisabled"))
                        object.unversionedPackageDisabled = message.unversionedPackageDisabled;
                    return object;
                };

                /**
                 * Converts this ExperimentalFeatures to JSON.
                 * @function toJSON
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExperimentalFeatures.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExperimentalFeatures
                 * @function getTypeUrl
                 * @memberof google.api.PythonSettings.ExperimentalFeatures
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExperimentalFeatures.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.api.PythonSettings.ExperimentalFeatures";
                };

                return ExperimentalFeatures;
            })();

            return PythonSettings;
        })();

        api.NodeSettings = (function() {

            /**
             * Properties of a NodeSettings.
             * @memberof google.api
             * @interface INodeSettings
             * @property {google.api.ICommonLanguageSettings|null} [common] NodeSettings common
             */

            /**
             * Constructs a new NodeSettings.
             * @memberof google.api
             * @classdesc Represents a NodeSettings.
             * @implements INodeSettings
             * @constructor
             * @param {google.api.INodeSettings=} [properties] Properties to set
             */
            function NodeSettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeSettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.NodeSettings
             * @instance
             */
            NodeSettings.prototype.common = null;

            /**
             * Creates a new NodeSettings instance using the specified properties.
             * @function create
             * @memberof google.api.NodeSettings
             * @static
             * @param {google.api.INodeSettings=} [properties] Properties to set
             * @returns {google.api.NodeSettings} NodeSettings instance
             */
            NodeSettings.create = function create(properties) {
                return new NodeSettings(properties);
            };

            /**
             * Encodes the specified NodeSettings message. Does not implicitly {@link google.api.NodeSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.NodeSettings
             * @static
             * @param {google.api.INodeSettings} message NodeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NodeSettings message, length delimited. Does not implicitly {@link google.api.NodeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.NodeSettings
             * @static
             * @param {google.api.INodeSettings} message NodeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NodeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.NodeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.NodeSettings} NodeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.NodeSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NodeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.NodeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.NodeSettings} NodeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NodeSettings message.
             * @function verify
             * @memberof google.api.NodeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NodeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                return null;
            };

            /**
             * Creates a NodeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.NodeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.NodeSettings} NodeSettings
             */
            NodeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.NodeSettings)
                    return object;
                let message = new $root.google.api.NodeSettings();
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.NodeSettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                return message;
            };

            /**
             * Creates a plain object from a NodeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.NodeSettings
             * @static
             * @param {google.api.NodeSettings} message NodeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.common = null;
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                return object;
            };

            /**
             * Converts this NodeSettings to JSON.
             * @function toJSON
             * @memberof google.api.NodeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NodeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NodeSettings
             * @function getTypeUrl
             * @memberof google.api.NodeSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NodeSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.NodeSettings";
            };

            return NodeSettings;
        })();

        api.DotnetSettings = (function() {

            /**
             * Properties of a DotnetSettings.
             * @memberof google.api
             * @interface IDotnetSettings
             * @property {google.api.ICommonLanguageSettings|null} [common] DotnetSettings common
             * @property {Object.<string,string>|null} [renamedServices] DotnetSettings renamedServices
             * @property {Object.<string,string>|null} [renamedResources] DotnetSettings renamedResources
             * @property {Array.<string>|null} [ignoredResources] DotnetSettings ignoredResources
             * @property {Array.<string>|null} [forcedNamespaceAliases] DotnetSettings forcedNamespaceAliases
             * @property {Array.<string>|null} [handwrittenSignatures] DotnetSettings handwrittenSignatures
             */

            /**
             * Constructs a new DotnetSettings.
             * @memberof google.api
             * @classdesc Represents a DotnetSettings.
             * @implements IDotnetSettings
             * @constructor
             * @param {google.api.IDotnetSettings=} [properties] Properties to set
             */
            function DotnetSettings(properties) {
                this.renamedServices = {};
                this.renamedResources = {};
                this.ignoredResources = [];
                this.forcedNamespaceAliases = [];
                this.handwrittenSignatures = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DotnetSettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.DotnetSettings
             * @instance
             */
            DotnetSettings.prototype.common = null;

            /**
             * DotnetSettings renamedServices.
             * @member {Object.<string,string>} renamedServices
             * @memberof google.api.DotnetSettings
             * @instance
             */
            DotnetSettings.prototype.renamedServices = $util.emptyObject;

            /**
             * DotnetSettings renamedResources.
             * @member {Object.<string,string>} renamedResources
             * @memberof google.api.DotnetSettings
             * @instance
             */
            DotnetSettings.prototype.renamedResources = $util.emptyObject;

            /**
             * DotnetSettings ignoredResources.
             * @member {Array.<string>} ignoredResources
             * @memberof google.api.DotnetSettings
             * @instance
             */
            DotnetSettings.prototype.ignoredResources = $util.emptyArray;

            /**
             * DotnetSettings forcedNamespaceAliases.
             * @member {Array.<string>} forcedNamespaceAliases
             * @memberof google.api.DotnetSettings
             * @instance
             */
            DotnetSettings.prototype.forcedNamespaceAliases = $util.emptyArray;

            /**
             * DotnetSettings handwrittenSignatures.
             * @member {Array.<string>} handwrittenSignatures
             * @memberof google.api.DotnetSettings
             * @instance
             */
            DotnetSettings.prototype.handwrittenSignatures = $util.emptyArray;

            /**
             * Creates a new DotnetSettings instance using the specified properties.
             * @function create
             * @memberof google.api.DotnetSettings
             * @static
             * @param {google.api.IDotnetSettings=} [properties] Properties to set
             * @returns {google.api.DotnetSettings} DotnetSettings instance
             */
            DotnetSettings.create = function create(properties) {
                return new DotnetSettings(properties);
            };

            /**
             * Encodes the specified DotnetSettings message. Does not implicitly {@link google.api.DotnetSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.DotnetSettings
             * @static
             * @param {google.api.IDotnetSettings} message DotnetSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotnetSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.renamedServices != null && Object.hasOwnProperty.call(message, "renamedServices"))
                    for (let keys = Object.keys(message.renamedServices), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.renamedServices[keys[i]]).ldelim();
                if (message.renamedResources != null && Object.hasOwnProperty.call(message, "renamedResources"))
                    for (let keys = Object.keys(message.renamedResources), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.renamedResources[keys[i]]).ldelim();
                if (message.ignoredResources != null && message.ignoredResources.length)
                    for (let i = 0; i < message.ignoredResources.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.ignoredResources[i]);
                if (message.forcedNamespaceAliases != null && message.forcedNamespaceAliases.length)
                    for (let i = 0; i < message.forcedNamespaceAliases.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.forcedNamespaceAliases[i]);
                if (message.handwrittenSignatures != null && message.handwrittenSignatures.length)
                    for (let i = 0; i < message.handwrittenSignatures.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.handwrittenSignatures[i]);
                return writer;
            };

            /**
             * Encodes the specified DotnetSettings message, length delimited. Does not implicitly {@link google.api.DotnetSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.DotnetSettings
             * @static
             * @param {google.api.IDotnetSettings} message DotnetSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DotnetSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DotnetSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.DotnetSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.DotnetSettings} DotnetSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotnetSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.DotnetSettings(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (message.renamedServices === $util.emptyObject)
                                message.renamedServices = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.renamedServices[key] = value;
                            break;
                        }
                    case 3: {
                            if (message.renamedResources === $util.emptyObject)
                                message.renamedResources = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.renamedResources[key] = value;
                            break;
                        }
                    case 4: {
                            if (!(message.ignoredResources && message.ignoredResources.length))
                                message.ignoredResources = [];
                            message.ignoredResources.push(reader.string());
                            break;
                        }
                    case 5: {
                            if (!(message.forcedNamespaceAliases && message.forcedNamespaceAliases.length))
                                message.forcedNamespaceAliases = [];
                            message.forcedNamespaceAliases.push(reader.string());
                            break;
                        }
                    case 6: {
                            if (!(message.handwrittenSignatures && message.handwrittenSignatures.length))
                                message.handwrittenSignatures = [];
                            message.handwrittenSignatures.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DotnetSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.DotnetSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.DotnetSettings} DotnetSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DotnetSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DotnetSettings message.
             * @function verify
             * @memberof google.api.DotnetSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DotnetSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                if (message.renamedServices != null && message.hasOwnProperty("renamedServices")) {
                    if (!$util.isObject(message.renamedServices))
                        return "renamedServices: object expected";
                    let key = Object.keys(message.renamedServices);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.renamedServices[key[i]]))
                            return "renamedServices: string{k:string} expected";
                }
                if (message.renamedResources != null && message.hasOwnProperty("renamedResources")) {
                    if (!$util.isObject(message.renamedResources))
                        return "renamedResources: object expected";
                    let key = Object.keys(message.renamedResources);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.renamedResources[key[i]]))
                            return "renamedResources: string{k:string} expected";
                }
                if (message.ignoredResources != null && message.hasOwnProperty("ignoredResources")) {
                    if (!Array.isArray(message.ignoredResources))
                        return "ignoredResources: array expected";
                    for (let i = 0; i < message.ignoredResources.length; ++i)
                        if (!$util.isString(message.ignoredResources[i]))
                            return "ignoredResources: string[] expected";
                }
                if (message.forcedNamespaceAliases != null && message.hasOwnProperty("forcedNamespaceAliases")) {
                    if (!Array.isArray(message.forcedNamespaceAliases))
                        return "forcedNamespaceAliases: array expected";
                    for (let i = 0; i < message.forcedNamespaceAliases.length; ++i)
                        if (!$util.isString(message.forcedNamespaceAliases[i]))
                            return "forcedNamespaceAliases: string[] expected";
                }
                if (message.handwrittenSignatures != null && message.hasOwnProperty("handwrittenSignatures")) {
                    if (!Array.isArray(message.handwrittenSignatures))
                        return "handwrittenSignatures: array expected";
                    for (let i = 0; i < message.handwrittenSignatures.length; ++i)
                        if (!$util.isString(message.handwrittenSignatures[i]))
                            return "handwrittenSignatures: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DotnetSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.DotnetSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.DotnetSettings} DotnetSettings
             */
            DotnetSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.DotnetSettings)
                    return object;
                let message = new $root.google.api.DotnetSettings();
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.DotnetSettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                if (object.renamedServices) {
                    if (typeof object.renamedServices !== "object")
                        throw TypeError(".google.api.DotnetSettings.renamedServices: object expected");
                    message.renamedServices = {};
                    for (let keys = Object.keys(object.renamedServices), i = 0; i < keys.length; ++i)
                        message.renamedServices[keys[i]] = String(object.renamedServices[keys[i]]);
                }
                if (object.renamedResources) {
                    if (typeof object.renamedResources !== "object")
                        throw TypeError(".google.api.DotnetSettings.renamedResources: object expected");
                    message.renamedResources = {};
                    for (let keys = Object.keys(object.renamedResources), i = 0; i < keys.length; ++i)
                        message.renamedResources[keys[i]] = String(object.renamedResources[keys[i]]);
                }
                if (object.ignoredResources) {
                    if (!Array.isArray(object.ignoredResources))
                        throw TypeError(".google.api.DotnetSettings.ignoredResources: array expected");
                    message.ignoredResources = [];
                    for (let i = 0; i < object.ignoredResources.length; ++i)
                        message.ignoredResources[i] = String(object.ignoredResources[i]);
                }
                if (object.forcedNamespaceAliases) {
                    if (!Array.isArray(object.forcedNamespaceAliases))
                        throw TypeError(".google.api.DotnetSettings.forcedNamespaceAliases: array expected");
                    message.forcedNamespaceAliases = [];
                    for (let i = 0; i < object.forcedNamespaceAliases.length; ++i)
                        message.forcedNamespaceAliases[i] = String(object.forcedNamespaceAliases[i]);
                }
                if (object.handwrittenSignatures) {
                    if (!Array.isArray(object.handwrittenSignatures))
                        throw TypeError(".google.api.DotnetSettings.handwrittenSignatures: array expected");
                    message.handwrittenSignatures = [];
                    for (let i = 0; i < object.handwrittenSignatures.length; ++i)
                        message.handwrittenSignatures[i] = String(object.handwrittenSignatures[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DotnetSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.DotnetSettings
             * @static
             * @param {google.api.DotnetSettings} message DotnetSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DotnetSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.ignoredResources = [];
                    object.forcedNamespaceAliases = [];
                    object.handwrittenSignatures = [];
                }
                if (options.objects || options.defaults) {
                    object.renamedServices = {};
                    object.renamedResources = {};
                }
                if (options.defaults)
                    object.common = null;
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                let keys2;
                if (message.renamedServices && (keys2 = Object.keys(message.renamedServices)).length) {
                    object.renamedServices = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.renamedServices[keys2[j]] = message.renamedServices[keys2[j]];
                }
                if (message.renamedResources && (keys2 = Object.keys(message.renamedResources)).length) {
                    object.renamedResources = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.renamedResources[keys2[j]] = message.renamedResources[keys2[j]];
                }
                if (message.ignoredResources && message.ignoredResources.length) {
                    object.ignoredResources = [];
                    for (let j = 0; j < message.ignoredResources.length; ++j)
                        object.ignoredResources[j] = message.ignoredResources[j];
                }
                if (message.forcedNamespaceAliases && message.forcedNamespaceAliases.length) {
                    object.forcedNamespaceAliases = [];
                    for (let j = 0; j < message.forcedNamespaceAliases.length; ++j)
                        object.forcedNamespaceAliases[j] = message.forcedNamespaceAliases[j];
                }
                if (message.handwrittenSignatures && message.handwrittenSignatures.length) {
                    object.handwrittenSignatures = [];
                    for (let j = 0; j < message.handwrittenSignatures.length; ++j)
                        object.handwrittenSignatures[j] = message.handwrittenSignatures[j];
                }
                return object;
            };

            /**
             * Converts this DotnetSettings to JSON.
             * @function toJSON
             * @memberof google.api.DotnetSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DotnetSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DotnetSettings
             * @function getTypeUrl
             * @memberof google.api.DotnetSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DotnetSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.DotnetSettings";
            };

            return DotnetSettings;
        })();

        api.RubySettings = (function() {

            /**
             * Properties of a RubySettings.
             * @memberof google.api
             * @interface IRubySettings
             * @property {google.api.ICommonLanguageSettings|null} [common] RubySettings common
             */

            /**
             * Constructs a new RubySettings.
             * @memberof google.api
             * @classdesc Represents a RubySettings.
             * @implements IRubySettings
             * @constructor
             * @param {google.api.IRubySettings=} [properties] Properties to set
             */
            function RubySettings(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RubySettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.RubySettings
             * @instance
             */
            RubySettings.prototype.common = null;

            /**
             * Creates a new RubySettings instance using the specified properties.
             * @function create
             * @memberof google.api.RubySettings
             * @static
             * @param {google.api.IRubySettings=} [properties] Properties to set
             * @returns {google.api.RubySettings} RubySettings instance
             */
            RubySettings.create = function create(properties) {
                return new RubySettings(properties);
            };

            /**
             * Encodes the specified RubySettings message. Does not implicitly {@link google.api.RubySettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.RubySettings
             * @static
             * @param {google.api.IRubySettings} message RubySettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RubySettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RubySettings message, length delimited. Does not implicitly {@link google.api.RubySettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.RubySettings
             * @static
             * @param {google.api.IRubySettings} message RubySettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RubySettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RubySettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.RubySettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.RubySettings} RubySettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RubySettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.RubySettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RubySettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.RubySettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.RubySettings} RubySettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RubySettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RubySettings message.
             * @function verify
             * @memberof google.api.RubySettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RubySettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                return null;
            };

            /**
             * Creates a RubySettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.RubySettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.RubySettings} RubySettings
             */
            RubySettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.RubySettings)
                    return object;
                let message = new $root.google.api.RubySettings();
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.RubySettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                return message;
            };

            /**
             * Creates a plain object from a RubySettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.RubySettings
             * @static
             * @param {google.api.RubySettings} message RubySettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RubySettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.common = null;
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                return object;
            };

            /**
             * Converts this RubySettings to JSON.
             * @function toJSON
             * @memberof google.api.RubySettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RubySettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RubySettings
             * @function getTypeUrl
             * @memberof google.api.RubySettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RubySettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.RubySettings";
            };

            return RubySettings;
        })();

        api.GoSettings = (function() {

            /**
             * Properties of a GoSettings.
             * @memberof google.api
             * @interface IGoSettings
             * @property {google.api.ICommonLanguageSettings|null} [common] GoSettings common
             * @property {Object.<string,string>|null} [renamedServices] GoSettings renamedServices
             */

            /**
             * Constructs a new GoSettings.
             * @memberof google.api
             * @classdesc Represents a GoSettings.
             * @implements IGoSettings
             * @constructor
             * @param {google.api.IGoSettings=} [properties] Properties to set
             */
            function GoSettings(properties) {
                this.renamedServices = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GoSettings common.
             * @member {google.api.ICommonLanguageSettings|null|undefined} common
             * @memberof google.api.GoSettings
             * @instance
             */
            GoSettings.prototype.common = null;

            /**
             * GoSettings renamedServices.
             * @member {Object.<string,string>} renamedServices
             * @memberof google.api.GoSettings
             * @instance
             */
            GoSettings.prototype.renamedServices = $util.emptyObject;

            /**
             * Creates a new GoSettings instance using the specified properties.
             * @function create
             * @memberof google.api.GoSettings
             * @static
             * @param {google.api.IGoSettings=} [properties] Properties to set
             * @returns {google.api.GoSettings} GoSettings instance
             */
            GoSettings.create = function create(properties) {
                return new GoSettings(properties);
            };

            /**
             * Encodes the specified GoSettings message. Does not implicitly {@link google.api.GoSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.GoSettings
             * @static
             * @param {google.api.IGoSettings} message GoSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GoSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.common != null && Object.hasOwnProperty.call(message, "common"))
                    $root.google.api.CommonLanguageSettings.encode(message.common, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.renamedServices != null && Object.hasOwnProperty.call(message, "renamedServices"))
                    for (let keys = Object.keys(message.renamedServices), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.renamedServices[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GoSettings message, length delimited. Does not implicitly {@link google.api.GoSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.GoSettings
             * @static
             * @param {google.api.IGoSettings} message GoSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GoSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GoSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.GoSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.GoSettings} GoSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GoSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.GoSettings(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.common = $root.google.api.CommonLanguageSettings.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (message.renamedServices === $util.emptyObject)
                                message.renamedServices = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.renamedServices[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GoSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.GoSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.GoSettings} GoSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GoSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GoSettings message.
             * @function verify
             * @memberof google.api.GoSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GoSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.common != null && message.hasOwnProperty("common")) {
                    let error = $root.google.api.CommonLanguageSettings.verify(message.common);
                    if (error)
                        return "common." + error;
                }
                if (message.renamedServices != null && message.hasOwnProperty("renamedServices")) {
                    if (!$util.isObject(message.renamedServices))
                        return "renamedServices: object expected";
                    let key = Object.keys(message.renamedServices);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.renamedServices[key[i]]))
                            return "renamedServices: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a GoSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.GoSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.GoSettings} GoSettings
             */
            GoSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.GoSettings)
                    return object;
                let message = new $root.google.api.GoSettings();
                if (object.common != null) {
                    if (typeof object.common !== "object")
                        throw TypeError(".google.api.GoSettings.common: object expected");
                    message.common = $root.google.api.CommonLanguageSettings.fromObject(object.common);
                }
                if (object.renamedServices) {
                    if (typeof object.renamedServices !== "object")
                        throw TypeError(".google.api.GoSettings.renamedServices: object expected");
                    message.renamedServices = {};
                    for (let keys = Object.keys(object.renamedServices), i = 0; i < keys.length; ++i)
                        message.renamedServices[keys[i]] = String(object.renamedServices[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GoSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.GoSettings
             * @static
             * @param {google.api.GoSettings} message GoSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GoSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.renamedServices = {};
                if (options.defaults)
                    object.common = null;
                if (message.common != null && message.hasOwnProperty("common"))
                    object.common = $root.google.api.CommonLanguageSettings.toObject(message.common, options);
                let keys2;
                if (message.renamedServices && (keys2 = Object.keys(message.renamedServices)).length) {
                    object.renamedServices = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.renamedServices[keys2[j]] = message.renamedServices[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this GoSettings to JSON.
             * @function toJSON
             * @memberof google.api.GoSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GoSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GoSettings
             * @function getTypeUrl
             * @memberof google.api.GoSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GoSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.GoSettings";
            };

            return GoSettings;
        })();

        api.MethodSettings = (function() {

            /**
             * Properties of a MethodSettings.
             * @memberof google.api
             * @interface IMethodSettings
             * @property {string|null} [selector] MethodSettings selector
             * @property {google.api.MethodSettings.ILongRunning|null} [longRunning] MethodSettings longRunning
             * @property {Array.<string>|null} [autoPopulatedFields] MethodSettings autoPopulatedFields
             */

            /**
             * Constructs a new MethodSettings.
             * @memberof google.api
             * @classdesc Represents a MethodSettings.
             * @implements IMethodSettings
             * @constructor
             * @param {google.api.IMethodSettings=} [properties] Properties to set
             */
            function MethodSettings(properties) {
                this.autoPopulatedFields = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodSettings selector.
             * @member {string} selector
             * @memberof google.api.MethodSettings
             * @instance
             */
            MethodSettings.prototype.selector = "";

            /**
             * MethodSettings longRunning.
             * @member {google.api.MethodSettings.ILongRunning|null|undefined} longRunning
             * @memberof google.api.MethodSettings
             * @instance
             */
            MethodSettings.prototype.longRunning = null;

            /**
             * MethodSettings autoPopulatedFields.
             * @member {Array.<string>} autoPopulatedFields
             * @memberof google.api.MethodSettings
             * @instance
             */
            MethodSettings.prototype.autoPopulatedFields = $util.emptyArray;

            /**
             * Creates a new MethodSettings instance using the specified properties.
             * @function create
             * @memberof google.api.MethodSettings
             * @static
             * @param {google.api.IMethodSettings=} [properties] Properties to set
             * @returns {google.api.MethodSettings} MethodSettings instance
             */
            MethodSettings.create = function create(properties) {
                return new MethodSettings(properties);
            };

            /**
             * Encodes the specified MethodSettings message. Does not implicitly {@link google.api.MethodSettings.verify|verify} messages.
             * @function encode
             * @memberof google.api.MethodSettings
             * @static
             * @param {google.api.IMethodSettings} message MethodSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selector != null && Object.hasOwnProperty.call(message, "selector"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                if (message.longRunning != null && Object.hasOwnProperty.call(message, "longRunning"))
                    $root.google.api.MethodSettings.LongRunning.encode(message.longRunning, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.autoPopulatedFields != null && message.autoPopulatedFields.length)
                    for (let i = 0; i < message.autoPopulatedFields.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.autoPopulatedFields[i]);
                return writer;
            };

            /**
             * Encodes the specified MethodSettings message, length delimited. Does not implicitly {@link google.api.MethodSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.MethodSettings
             * @static
             * @param {google.api.IMethodSettings} message MethodSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodSettings message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.MethodSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.MethodSettings} MethodSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.MethodSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.selector = reader.string();
                            break;
                        }
                    case 2: {
                            message.longRunning = $root.google.api.MethodSettings.LongRunning.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            if (!(message.autoPopulatedFields && message.autoPopulatedFields.length))
                                message.autoPopulatedFields = [];
                            message.autoPopulatedFields.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.MethodSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.MethodSettings} MethodSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodSettings message.
             * @function verify
             * @memberof google.api.MethodSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.longRunning != null && message.hasOwnProperty("longRunning")) {
                    let error = $root.google.api.MethodSettings.LongRunning.verify(message.longRunning);
                    if (error)
                        return "longRunning." + error;
                }
                if (message.autoPopulatedFields != null && message.hasOwnProperty("autoPopulatedFields")) {
                    if (!Array.isArray(message.autoPopulatedFields))
                        return "autoPopulatedFields: array expected";
                    for (let i = 0; i < message.autoPopulatedFields.length; ++i)
                        if (!$util.isString(message.autoPopulatedFields[i]))
                            return "autoPopulatedFields: string[] expected";
                }
                return null;
            };

            /**
             * Creates a MethodSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.MethodSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.MethodSettings} MethodSettings
             */
            MethodSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.MethodSettings)
                    return object;
                let message = new $root.google.api.MethodSettings();
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.longRunning != null) {
                    if (typeof object.longRunning !== "object")
                        throw TypeError(".google.api.MethodSettings.longRunning: object expected");
                    message.longRunning = $root.google.api.MethodSettings.LongRunning.fromObject(object.longRunning);
                }
                if (object.autoPopulatedFields) {
                    if (!Array.isArray(object.autoPopulatedFields))
                        throw TypeError(".google.api.MethodSettings.autoPopulatedFields: array expected");
                    message.autoPopulatedFields = [];
                    for (let i = 0; i < object.autoPopulatedFields.length; ++i)
                        message.autoPopulatedFields[i] = String(object.autoPopulatedFields[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.MethodSettings
             * @static
             * @param {google.api.MethodSettings} message MethodSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.autoPopulatedFields = [];
                if (options.defaults) {
                    object.selector = "";
                    object.longRunning = null;
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.longRunning != null && message.hasOwnProperty("longRunning"))
                    object.longRunning = $root.google.api.MethodSettings.LongRunning.toObject(message.longRunning, options);
                if (message.autoPopulatedFields && message.autoPopulatedFields.length) {
                    object.autoPopulatedFields = [];
                    for (let j = 0; j < message.autoPopulatedFields.length; ++j)
                        object.autoPopulatedFields[j] = message.autoPopulatedFields[j];
                }
                return object;
            };

            /**
             * Converts this MethodSettings to JSON.
             * @function toJSON
             * @memberof google.api.MethodSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MethodSettings
             * @function getTypeUrl
             * @memberof google.api.MethodSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MethodSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.MethodSettings";
            };

            MethodSettings.LongRunning = (function() {

                /**
                 * Properties of a LongRunning.
                 * @memberof google.api.MethodSettings
                 * @interface ILongRunning
                 * @property {google.protobuf.IDuration|null} [initialPollDelay] LongRunning initialPollDelay
                 * @property {number|null} [pollDelayMultiplier] LongRunning pollDelayMultiplier
                 * @property {google.protobuf.IDuration|null} [maxPollDelay] LongRunning maxPollDelay
                 * @property {google.protobuf.IDuration|null} [totalPollTimeout] LongRunning totalPollTimeout
                 */

                /**
                 * Constructs a new LongRunning.
                 * @memberof google.api.MethodSettings
                 * @classdesc Represents a LongRunning.
                 * @implements ILongRunning
                 * @constructor
                 * @param {google.api.MethodSettings.ILongRunning=} [properties] Properties to set
                 */
                function LongRunning(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LongRunning initialPollDelay.
                 * @member {google.protobuf.IDuration|null|undefined} initialPollDelay
                 * @memberof google.api.MethodSettings.LongRunning
                 * @instance
                 */
                LongRunning.prototype.initialPollDelay = null;

                /**
                 * LongRunning pollDelayMultiplier.
                 * @member {number} pollDelayMultiplier
                 * @memberof google.api.MethodSettings.LongRunning
                 * @instance
                 */
                LongRunning.prototype.pollDelayMultiplier = 0;

                /**
                 * LongRunning maxPollDelay.
                 * @member {google.protobuf.IDuration|null|undefined} maxPollDelay
                 * @memberof google.api.MethodSettings.LongRunning
                 * @instance
                 */
                LongRunning.prototype.maxPollDelay = null;

                /**
                 * LongRunning totalPollTimeout.
                 * @member {google.protobuf.IDuration|null|undefined} totalPollTimeout
                 * @memberof google.api.MethodSettings.LongRunning
                 * @instance
                 */
                LongRunning.prototype.totalPollTimeout = null;

                /**
                 * Creates a new LongRunning instance using the specified properties.
                 * @function create
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {google.api.MethodSettings.ILongRunning=} [properties] Properties to set
                 * @returns {google.api.MethodSettings.LongRunning} LongRunning instance
                 */
                LongRunning.create = function create(properties) {
                    return new LongRunning(properties);
                };

                /**
                 * Encodes the specified LongRunning message. Does not implicitly {@link google.api.MethodSettings.LongRunning.verify|verify} messages.
                 * @function encode
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {google.api.MethodSettings.ILongRunning} message LongRunning message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LongRunning.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.initialPollDelay != null && Object.hasOwnProperty.call(message, "initialPollDelay"))
                        $root.google.protobuf.Duration.encode(message.initialPollDelay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.pollDelayMultiplier != null && Object.hasOwnProperty.call(message, "pollDelayMultiplier"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.pollDelayMultiplier);
                    if (message.maxPollDelay != null && Object.hasOwnProperty.call(message, "maxPollDelay"))
                        $root.google.protobuf.Duration.encode(message.maxPollDelay, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.totalPollTimeout != null && Object.hasOwnProperty.call(message, "totalPollTimeout"))
                        $root.google.protobuf.Duration.encode(message.totalPollTimeout, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LongRunning message, length delimited. Does not implicitly {@link google.api.MethodSettings.LongRunning.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {google.api.MethodSettings.ILongRunning} message LongRunning message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LongRunning.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LongRunning message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.api.MethodSettings.LongRunning} LongRunning
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LongRunning.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.MethodSettings.LongRunning();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.initialPollDelay = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.pollDelayMultiplier = reader.float();
                                break;
                            }
                        case 3: {
                                message.maxPollDelay = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.totalPollTimeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LongRunning message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.api.MethodSettings.LongRunning} LongRunning
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LongRunning.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LongRunning message.
                 * @function verify
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LongRunning.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.initialPollDelay != null && message.hasOwnProperty("initialPollDelay")) {
                        let error = $root.google.protobuf.Duration.verify(message.initialPollDelay);
                        if (error)
                            return "initialPollDelay." + error;
                    }
                    if (message.pollDelayMultiplier != null && message.hasOwnProperty("pollDelayMultiplier"))
                        if (typeof message.pollDelayMultiplier !== "number")
                            return "pollDelayMultiplier: number expected";
                    if (message.maxPollDelay != null && message.hasOwnProperty("maxPollDelay")) {
                        let error = $root.google.protobuf.Duration.verify(message.maxPollDelay);
                        if (error)
                            return "maxPollDelay." + error;
                    }
                    if (message.totalPollTimeout != null && message.hasOwnProperty("totalPollTimeout")) {
                        let error = $root.google.protobuf.Duration.verify(message.totalPollTimeout);
                        if (error)
                            return "totalPollTimeout." + error;
                    }
                    return null;
                };

                /**
                 * Creates a LongRunning message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.api.MethodSettings.LongRunning} LongRunning
                 */
                LongRunning.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.api.MethodSettings.LongRunning)
                        return object;
                    let message = new $root.google.api.MethodSettings.LongRunning();
                    if (object.initialPollDelay != null) {
                        if (typeof object.initialPollDelay !== "object")
                            throw TypeError(".google.api.MethodSettings.LongRunning.initialPollDelay: object expected");
                        message.initialPollDelay = $root.google.protobuf.Duration.fromObject(object.initialPollDelay);
                    }
                    if (object.pollDelayMultiplier != null)
                        message.pollDelayMultiplier = Number(object.pollDelayMultiplier);
                    if (object.maxPollDelay != null) {
                        if (typeof object.maxPollDelay !== "object")
                            throw TypeError(".google.api.MethodSettings.LongRunning.maxPollDelay: object expected");
                        message.maxPollDelay = $root.google.protobuf.Duration.fromObject(object.maxPollDelay);
                    }
                    if (object.totalPollTimeout != null) {
                        if (typeof object.totalPollTimeout !== "object")
                            throw TypeError(".google.api.MethodSettings.LongRunning.totalPollTimeout: object expected");
                        message.totalPollTimeout = $root.google.protobuf.Duration.fromObject(object.totalPollTimeout);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LongRunning message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {google.api.MethodSettings.LongRunning} message LongRunning
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LongRunning.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.initialPollDelay = null;
                        object.pollDelayMultiplier = 0;
                        object.maxPollDelay = null;
                        object.totalPollTimeout = null;
                    }
                    if (message.initialPollDelay != null && message.hasOwnProperty("initialPollDelay"))
                        object.initialPollDelay = $root.google.protobuf.Duration.toObject(message.initialPollDelay, options);
                    if (message.pollDelayMultiplier != null && message.hasOwnProperty("pollDelayMultiplier"))
                        object.pollDelayMultiplier = options.json && !isFinite(message.pollDelayMultiplier) ? String(message.pollDelayMultiplier) : message.pollDelayMultiplier;
                    if (message.maxPollDelay != null && message.hasOwnProperty("maxPollDelay"))
                        object.maxPollDelay = $root.google.protobuf.Duration.toObject(message.maxPollDelay, options);
                    if (message.totalPollTimeout != null && message.hasOwnProperty("totalPollTimeout"))
                        object.totalPollTimeout = $root.google.protobuf.Duration.toObject(message.totalPollTimeout, options);
                    return object;
                };

                /**
                 * Converts this LongRunning to JSON.
                 * @function toJSON
                 * @memberof google.api.MethodSettings.LongRunning
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LongRunning.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LongRunning
                 * @function getTypeUrl
                 * @memberof google.api.MethodSettings.LongRunning
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LongRunning.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.api.MethodSettings.LongRunning";
                };

                return LongRunning;
            })();

            return MethodSettings;
        })();

        /**
         * ClientLibraryOrganization enum.
         * @name google.api.ClientLibraryOrganization
         * @enum {number}
         * @property {number} CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED=0 CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED value
         * @property {number} CLOUD=1 CLOUD value
         * @property {number} ADS=2 ADS value
         * @property {number} PHOTOS=3 PHOTOS value
         * @property {number} STREET_VIEW=4 STREET_VIEW value
         * @property {number} SHOPPING=5 SHOPPING value
         * @property {number} GEO=6 GEO value
         * @property {number} GENERATIVE_AI=7 GENERATIVE_AI value
         */
        api.ClientLibraryOrganization = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED"] = 0;
            values[valuesById[1] = "CLOUD"] = 1;
            values[valuesById[2] = "ADS"] = 2;
            values[valuesById[3] = "PHOTOS"] = 3;
            values[valuesById[4] = "STREET_VIEW"] = 4;
            values[valuesById[5] = "SHOPPING"] = 5;
            values[valuesById[6] = "GEO"] = 6;
            values[valuesById[7] = "GENERATIVE_AI"] = 7;
            return values;
        })();

        /**
         * ClientLibraryDestination enum.
         * @name google.api.ClientLibraryDestination
         * @enum {number}
         * @property {number} CLIENT_LIBRARY_DESTINATION_UNSPECIFIED=0 CLIENT_LIBRARY_DESTINATION_UNSPECIFIED value
         * @property {number} GITHUB=10 GITHUB value
         * @property {number} PACKAGE_MANAGER=20 PACKAGE_MANAGER value
         */
        api.ClientLibraryDestination = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CLIENT_LIBRARY_DESTINATION_UNSPECIFIED"] = 0;
            values[valuesById[10] = "GITHUB"] = 10;
            values[valuesById[20] = "PACKAGE_MANAGER"] = 20;
            return values;
        })();

        api.SelectiveGapicGeneration = (function() {

            /**
             * Properties of a SelectiveGapicGeneration.
             * @memberof google.api
             * @interface ISelectiveGapicGeneration
             * @property {Array.<string>|null} [methods] SelectiveGapicGeneration methods
             * @property {boolean|null} [generateOmittedAsInternal] SelectiveGapicGeneration generateOmittedAsInternal
             */

            /**
             * Constructs a new SelectiveGapicGeneration.
             * @memberof google.api
             * @classdesc Represents a SelectiveGapicGeneration.
             * @implements ISelectiveGapicGeneration
             * @constructor
             * @param {google.api.ISelectiveGapicGeneration=} [properties] Properties to set
             */
            function SelectiveGapicGeneration(properties) {
                this.methods = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SelectiveGapicGeneration methods.
             * @member {Array.<string>} methods
             * @memberof google.api.SelectiveGapicGeneration
             * @instance
             */
            SelectiveGapicGeneration.prototype.methods = $util.emptyArray;

            /**
             * SelectiveGapicGeneration generateOmittedAsInternal.
             * @member {boolean} generateOmittedAsInternal
             * @memberof google.api.SelectiveGapicGeneration
             * @instance
             */
            SelectiveGapicGeneration.prototype.generateOmittedAsInternal = false;

            /**
             * Creates a new SelectiveGapicGeneration instance using the specified properties.
             * @function create
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {google.api.ISelectiveGapicGeneration=} [properties] Properties to set
             * @returns {google.api.SelectiveGapicGeneration} SelectiveGapicGeneration instance
             */
            SelectiveGapicGeneration.create = function create(properties) {
                return new SelectiveGapicGeneration(properties);
            };

            /**
             * Encodes the specified SelectiveGapicGeneration message. Does not implicitly {@link google.api.SelectiveGapicGeneration.verify|verify} messages.
             * @function encode
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {google.api.ISelectiveGapicGeneration} message SelectiveGapicGeneration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelectiveGapicGeneration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.methods != null && message.methods.length)
                    for (let i = 0; i < message.methods.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.methods[i]);
                if (message.generateOmittedAsInternal != null && Object.hasOwnProperty.call(message, "generateOmittedAsInternal"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.generateOmittedAsInternal);
                return writer;
            };

            /**
             * Encodes the specified SelectiveGapicGeneration message, length delimited. Does not implicitly {@link google.api.SelectiveGapicGeneration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {google.api.ISelectiveGapicGeneration} message SelectiveGapicGeneration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelectiveGapicGeneration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SelectiveGapicGeneration message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.SelectiveGapicGeneration} SelectiveGapicGeneration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelectiveGapicGeneration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.SelectiveGapicGeneration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.methods && message.methods.length))
                                message.methods = [];
                            message.methods.push(reader.string());
                            break;
                        }
                    case 2: {
                            message.generateOmittedAsInternal = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SelectiveGapicGeneration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.SelectiveGapicGeneration} SelectiveGapicGeneration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelectiveGapicGeneration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SelectiveGapicGeneration message.
             * @function verify
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SelectiveGapicGeneration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.methods != null && message.hasOwnProperty("methods")) {
                    if (!Array.isArray(message.methods))
                        return "methods: array expected";
                    for (let i = 0; i < message.methods.length; ++i)
                        if (!$util.isString(message.methods[i]))
                            return "methods: string[] expected";
                }
                if (message.generateOmittedAsInternal != null && message.hasOwnProperty("generateOmittedAsInternal"))
                    if (typeof message.generateOmittedAsInternal !== "boolean")
                        return "generateOmittedAsInternal: boolean expected";
                return null;
            };

            /**
             * Creates a SelectiveGapicGeneration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.SelectiveGapicGeneration} SelectiveGapicGeneration
             */
            SelectiveGapicGeneration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.SelectiveGapicGeneration)
                    return object;
                let message = new $root.google.api.SelectiveGapicGeneration();
                if (object.methods) {
                    if (!Array.isArray(object.methods))
                        throw TypeError(".google.api.SelectiveGapicGeneration.methods: array expected");
                    message.methods = [];
                    for (let i = 0; i < object.methods.length; ++i)
                        message.methods[i] = String(object.methods[i]);
                }
                if (object.generateOmittedAsInternal != null)
                    message.generateOmittedAsInternal = Boolean(object.generateOmittedAsInternal);
                return message;
            };

            /**
             * Creates a plain object from a SelectiveGapicGeneration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {google.api.SelectiveGapicGeneration} message SelectiveGapicGeneration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SelectiveGapicGeneration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.methods = [];
                if (options.defaults)
                    object.generateOmittedAsInternal = false;
                if (message.methods && message.methods.length) {
                    object.methods = [];
                    for (let j = 0; j < message.methods.length; ++j)
                        object.methods[j] = message.methods[j];
                }
                if (message.generateOmittedAsInternal != null && message.hasOwnProperty("generateOmittedAsInternal"))
                    object.generateOmittedAsInternal = message.generateOmittedAsInternal;
                return object;
            };

            /**
             * Converts this SelectiveGapicGeneration to JSON.
             * @function toJSON
             * @memberof google.api.SelectiveGapicGeneration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SelectiveGapicGeneration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SelectiveGapicGeneration
             * @function getTypeUrl
             * @memberof google.api.SelectiveGapicGeneration
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SelectiveGapicGeneration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.api.SelectiveGapicGeneration";
            };

            return SelectiveGapicGeneration;
        })();

        /**
         * LaunchStage enum.
         * @name google.api.LaunchStage
         * @enum {number}
         * @property {number} LAUNCH_STAGE_UNSPECIFIED=0 LAUNCH_STAGE_UNSPECIFIED value
         * @property {number} UNIMPLEMENTED=6 UNIMPLEMENTED value
         * @property {number} PRELAUNCH=7 PRELAUNCH value
         * @property {number} EARLY_ACCESS=1 EARLY_ACCESS value
         * @property {number} ALPHA=2 ALPHA value
         * @property {number} BETA=3 BETA value
         * @property {number} GA=4 GA value
         * @property {number} DEPRECATED=5 DEPRECATED value
         */
        api.LaunchStage = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LAUNCH_STAGE_UNSPECIFIED"] = 0;
            values[valuesById[6] = "UNIMPLEMENTED"] = 6;
            values[valuesById[7] = "PRELAUNCH"] = 7;
            values[valuesById[1] = "EARLY_ACCESS"] = 1;
            values[valuesById[2] = "ALPHA"] = 2;
            values[valuesById[3] = "BETA"] = 3;
            values[valuesById[4] = "GA"] = 4;
            values[valuesById[5] = "DEPRECATED"] = 5;
            return values;
        })();

        return api;
    })();

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileDescriptorSet
             * @function getTypeUrl
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileDescriptorSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FileDescriptorSet";
            };

            return FileDescriptorSet;
        })();

        /**
         * Edition enum.
         * @name google.protobuf.Edition
         * @enum {number}
         * @property {number} EDITION_UNKNOWN=0 EDITION_UNKNOWN value
         * @property {number} EDITION_LEGACY=900 EDITION_LEGACY value
         * @property {number} EDITION_PROTO2=998 EDITION_PROTO2 value
         * @property {number} EDITION_PROTO3=999 EDITION_PROTO3 value
         * @property {number} EDITION_2023=1000 EDITION_2023 value
         * @property {number} EDITION_2024=1001 EDITION_2024 value
         * @property {number} EDITION_1_TEST_ONLY=1 EDITION_1_TEST_ONLY value
         * @property {number} EDITION_2_TEST_ONLY=2 EDITION_2_TEST_ONLY value
         * @property {number} EDITION_99997_TEST_ONLY=99997 EDITION_99997_TEST_ONLY value
         * @property {number} EDITION_99998_TEST_ONLY=99998 EDITION_99998_TEST_ONLY value
         * @property {number} EDITION_99999_TEST_ONLY=99999 EDITION_99999_TEST_ONLY value
         * @property {number} EDITION_MAX=2147483647 EDITION_MAX value
         */
        protobuf.Edition = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EDITION_UNKNOWN"] = 0;
            values[valuesById[900] = "EDITION_LEGACY"] = 900;
            values[valuesById[998] = "EDITION_PROTO2"] = 998;
            values[valuesById[999] = "EDITION_PROTO3"] = 999;
            values[valuesById[1000] = "EDITION_2023"] = 1000;
            values[valuesById[1001] = "EDITION_2024"] = 1001;
            values[valuesById[1] = "EDITION_1_TEST_ONLY"] = 1;
            values[valuesById[2] = "EDITION_2_TEST_ONLY"] = 2;
            values[valuesById[99997] = "EDITION_99997_TEST_ONLY"] = 99997;
            values[valuesById[99998] = "EDITION_99998_TEST_ONLY"] = 99998;
            values[valuesById[99999] = "EDITION_99999_TEST_ONLY"] = 99999;
            values[valuesById[2147483647] = "EDITION_MAX"] = 2147483647;
            return values;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             * @property {google.protobuf.Edition|null} [edition] FileDescriptorProto edition
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * FileDescriptorProto edition.
             * @member {google.protobuf.Edition} edition
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.edition = 0;

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (let i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                if (message.edition != null && Object.hasOwnProperty.call(message, "edition"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.edition);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message["package"] = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        }
                    case 10: {
                            if (!(message.publicDependency && message.publicDependency.length))
                                message.publicDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.publicDependency.push(reader.int32());
                            } else
                                message.publicDependency.push(reader.int32());
                            break;
                        }
                    case 11: {
                            if (!(message.weakDependency && message.weakDependency.length))
                                message.weakDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weakDependency.push(reader.int32());
                            } else
                                message.weakDependency.push(reader.int32());
                            break;
                        }
                    case 4: {
                            if (!(message.messageType && message.messageType.length))
                                message.messageType = [];
                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 8: {
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.syntax = reader.string();
                            break;
                        }
                    case 14: {
                            message.edition = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                if (message.edition != null && message.hasOwnProperty("edition"))
                    switch (message.edition) {
                    default:
                        return "edition: enum value expected";
                    case 0:
                    case 900:
                    case 998:
                    case 999:
                    case 1000:
                    case 1001:
                    case 1:
                    case 2:
                    case 99997:
                    case 99998:
                    case 99999:
                    case 2147483647:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (let i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (let i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (let i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                switch (object.edition) {
                default:
                    if (typeof object.edition === "number") {
                        message.edition = object.edition;
                        break;
                    }
                    break;
                case "EDITION_UNKNOWN":
                case 0:
                    message.edition = 0;
                    break;
                case "EDITION_LEGACY":
                case 900:
                    message.edition = 900;
                    break;
                case "EDITION_PROTO2":
                case 998:
                    message.edition = 998;
                    break;
                case "EDITION_PROTO3":
                case 999:
                    message.edition = 999;
                    break;
                case "EDITION_2023":
                case 1000:
                    message.edition = 1000;
                    break;
                case "EDITION_2024":
                case 1001:
                    message.edition = 1001;
                    break;
                case "EDITION_1_TEST_ONLY":
                case 1:
                    message.edition = 1;
                    break;
                case "EDITION_2_TEST_ONLY":
                case 2:
                    message.edition = 2;
                    break;
                case "EDITION_99997_TEST_ONLY":
                case 99997:
                    message.edition = 99997;
                    break;
                case "EDITION_99998_TEST_ONLY":
                case 99998:
                    message.edition = 99998;
                    break;
                case "EDITION_99999_TEST_ONLY":
                case 99999:
                    message.edition = 99999;
                    break;
                case "EDITION_MAX":
                case 2147483647:
                    message.edition = 2147483647;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                    object.edition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (let j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (let j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (let j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                if (message.edition != null && message.hasOwnProperty("edition"))
                    object.edition = options.enums === String ? $root.google.protobuf.Edition[message.edition] === undefined ? message.edition : $root.google.protobuf.Edition[message.edition] : message.edition;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FileDescriptorProto";
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (let i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (let i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (let i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            if (!(message.nestedType && message.nestedType.length))
                                message.nestedType = [];
                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            if (!(message.extensionRange && message.extensionRange.length))
                                message.extensionRange = [];
                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        }
                    case 8: {
                            if (!(message.oneofDecl && message.oneofDecl.length))
                                message.oneofDecl = [];
                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        }
                    case 10: {
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (let i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (let i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (let i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (let j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (let j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (let j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.DescriptorProto";
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 * @property {google.protobuf.IExtensionRangeOptions|null} [options] ExtensionRange options
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * ExtensionRange options.
                 * @member {google.protobuf.IExtensionRangeOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.options = null;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ExtensionRangeOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = reader.int32();
                                break;
                            }
                        case 2: {
                                message.end = reader.int32();
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.ExtensionRangeOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.google.protobuf.ExtensionRangeOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.ExtensionRange.options: object expected");
                        message.options = $root.google.protobuf.ExtensionRangeOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                        object.options = null;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ExtensionRangeOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExtensionRange
                 * @function getTypeUrl
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExtensionRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.DescriptorProto.ExtensionRange";
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = reader.int32();
                                break;
                            }
                        case 2: {
                                message.end = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ReservedRange
                 * @function getTypeUrl
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ReservedRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.DescriptorProto.ReservedRange";
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.ExtensionRangeOptions = (function() {

            /**
             * Properties of an ExtensionRangeOptions.
             * @memberof google.protobuf
             * @interface IExtensionRangeOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ExtensionRangeOptions uninterpretedOption
             * @property {Array.<google.protobuf.ExtensionRangeOptions.IDeclaration>|null} [declaration] ExtensionRangeOptions declaration
             * @property {google.protobuf.IFeatureSet|null} [features] ExtensionRangeOptions features
             * @property {google.protobuf.ExtensionRangeOptions.VerificationState|null} [verification] ExtensionRangeOptions verification
             */

            /**
             * Constructs a new ExtensionRangeOptions.
             * @memberof google.protobuf
             * @classdesc Represents an ExtensionRangeOptions.
             * @implements IExtensionRangeOptions
             * @constructor
             * @param {google.protobuf.IExtensionRangeOptions=} [properties] Properties to set
             */
            function ExtensionRangeOptions(properties) {
                this.uninterpretedOption = [];
                this.declaration = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtensionRangeOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * ExtensionRangeOptions declaration.
             * @member {Array.<google.protobuf.ExtensionRangeOptions.IDeclaration>} declaration
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.declaration = $util.emptyArray;

            /**
             * ExtensionRangeOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.features = null;

            /**
             * ExtensionRangeOptions verification.
             * @member {google.protobuf.ExtensionRangeOptions.VerificationState} verification
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.verification = 1;

            /**
             * Creates a new ExtensionRangeOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.IExtensionRangeOptions=} [properties] Properties to set
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions instance
             */
            ExtensionRangeOptions.create = function create(properties) {
                return new ExtensionRangeOptions(properties);
            };

            /**
             * Encodes the specified ExtensionRangeOptions message. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.IExtensionRangeOptions} message ExtensionRangeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtensionRangeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.declaration != null && message.declaration.length)
                    for (let i = 0; i < message.declaration.length; ++i)
                        $root.google.protobuf.ExtensionRangeOptions.Declaration.encode(message.declaration[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.verification != null && Object.hasOwnProperty.call(message, "verification"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.verification);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExtensionRangeOptions message, length delimited. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.IExtensionRangeOptions} message ExtensionRangeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtensionRangeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtensionRangeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtensionRangeOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ExtensionRangeOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.declaration && message.declaration.length))
                                message.declaration = [];
                            message.declaration.push($root.google.protobuf.ExtensionRangeOptions.Declaration.decode(reader, reader.uint32()));
                            break;
                        }
                    case 50: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.verification = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtensionRangeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtensionRangeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtensionRangeOptions message.
             * @function verify
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtensionRangeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message.declaration != null && message.hasOwnProperty("declaration")) {
                    if (!Array.isArray(message.declaration))
                        return "declaration: array expected";
                    for (let i = 0; i < message.declaration.length; ++i) {
                        let error = $root.google.protobuf.ExtensionRangeOptions.Declaration.verify(message.declaration[i]);
                        if (error)
                            return "declaration." + error;
                    }
                }
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.verification != null && message.hasOwnProperty("verification"))
                    switch (message.verification) {
                    default:
                        return "verification: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExtensionRangeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             */
            ExtensionRangeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ExtensionRangeOptions)
                    return object;
                let message = new $root.google.protobuf.ExtensionRangeOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object.declaration) {
                    if (!Array.isArray(object.declaration))
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.declaration: array expected");
                    message.declaration = [];
                    for (let i = 0; i < object.declaration.length; ++i) {
                        if (typeof object.declaration[i] !== "object")
                            throw TypeError(".google.protobuf.ExtensionRangeOptions.declaration: object expected");
                        message.declaration[i] = $root.google.protobuf.ExtensionRangeOptions.Declaration.fromObject(object.declaration[i]);
                    }
                }
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                switch (object.verification) {
                case "DECLARATION":
                case 0:
                    message.verification = 0;
                    break;
                default:
                    if (typeof object.verification === "number") {
                        message.verification = object.verification;
                        break;
                    }
                    break;
                case "UNVERIFIED":
                case 1:
                    message.verification = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExtensionRangeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.ExtensionRangeOptions} message ExtensionRangeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtensionRangeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.declaration = [];
                    object.uninterpretedOption = [];
                }
                if (options.defaults) {
                    object.verification = options.enums === String ? "UNVERIFIED" : 1;
                    object.features = null;
                }
                if (message.declaration && message.declaration.length) {
                    object.declaration = [];
                    for (let j = 0; j < message.declaration.length; ++j)
                        object.declaration[j] = $root.google.protobuf.ExtensionRangeOptions.Declaration.toObject(message.declaration[j], options);
                }
                if (message.verification != null && message.hasOwnProperty("verification"))
                    object.verification = options.enums === String ? $root.google.protobuf.ExtensionRangeOptions.VerificationState[message.verification] === undefined ? message.verification : $root.google.protobuf.ExtensionRangeOptions.VerificationState[message.verification] : message.verification;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ExtensionRangeOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtensionRangeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExtensionRangeOptions
             * @function getTypeUrl
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExtensionRangeOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ExtensionRangeOptions";
            };

            ExtensionRangeOptions.Declaration = (function() {

                /**
                 * Properties of a Declaration.
                 * @memberof google.protobuf.ExtensionRangeOptions
                 * @interface IDeclaration
                 * @property {number|null} [number] Declaration number
                 * @property {string|null} [fullName] Declaration fullName
                 * @property {string|null} [type] Declaration type
                 * @property {boolean|null} [reserved] Declaration reserved
                 * @property {boolean|null} [repeated] Declaration repeated
                 */

                /**
                 * Constructs a new Declaration.
                 * @memberof google.protobuf.ExtensionRangeOptions
                 * @classdesc Represents a Declaration.
                 * @implements IDeclaration
                 * @constructor
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration=} [properties] Properties to set
                 */
                function Declaration(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Declaration number.
                 * @member {number} number
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.number = 0;

                /**
                 * Declaration fullName.
                 * @member {string} fullName
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.fullName = "";

                /**
                 * Declaration type.
                 * @member {string} type
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.type = "";

                /**
                 * Declaration reserved.
                 * @member {boolean} reserved
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.reserved = false;

                /**
                 * Declaration repeated.
                 * @member {boolean} repeated
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.repeated = false;

                /**
                 * Creates a new Declaration instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration=} [properties] Properties to set
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration instance
                 */
                Declaration.create = function create(properties) {
                    return new Declaration(properties);
                };

                /**
                 * Encodes the specified Declaration message. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.Declaration.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration} message Declaration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Declaration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.number);
                    if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fullName);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                    if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.reserved);
                    if (message.repeated != null && Object.hasOwnProperty.call(message, "repeated"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.repeated);
                    return writer;
                };

                /**
                 * Encodes the specified Declaration message, length delimited. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.Declaration.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration} message Declaration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Declaration.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Declaration message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Declaration.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ExtensionRangeOptions.Declaration();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.number = reader.int32();
                                break;
                            }
                        case 2: {
                                message.fullName = reader.string();
                                break;
                            }
                        case 3: {
                                message.type = reader.string();
                                break;
                            }
                        case 5: {
                                message.reserved = reader.bool();
                                break;
                            }
                        case 6: {
                                message.repeated = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Declaration message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Declaration.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Declaration message.
                 * @function verify
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Declaration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.fullName != null && message.hasOwnProperty("fullName"))
                        if (!$util.isString(message.fullName))
                            return "fullName: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        if (!$util.isString(message.type))
                            return "type: string expected";
                    if (message.reserved != null && message.hasOwnProperty("reserved"))
                        if (typeof message.reserved !== "boolean")
                            return "reserved: boolean expected";
                    if (message.repeated != null && message.hasOwnProperty("repeated"))
                        if (typeof message.repeated !== "boolean")
                            return "repeated: boolean expected";
                    return null;
                };

                /**
                 * Creates a Declaration message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration
                 */
                Declaration.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ExtensionRangeOptions.Declaration)
                        return object;
                    let message = new $root.google.protobuf.ExtensionRangeOptions.Declaration();
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.fullName != null)
                        message.fullName = String(object.fullName);
                    if (object.type != null)
                        message.type = String(object.type);
                    if (object.reserved != null)
                        message.reserved = Boolean(object.reserved);
                    if (object.repeated != null)
                        message.repeated = Boolean(object.repeated);
                    return message;
                };

                /**
                 * Creates a plain object from a Declaration message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.Declaration} message Declaration
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Declaration.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.number = 0;
                        object.fullName = "";
                        object.type = "";
                        object.reserved = false;
                        object.repeated = false;
                    }
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.fullName != null && message.hasOwnProperty("fullName"))
                        object.fullName = message.fullName;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = message.type;
                    if (message.reserved != null && message.hasOwnProperty("reserved"))
                        object.reserved = message.reserved;
                    if (message.repeated != null && message.hasOwnProperty("repeated"))
                        object.repeated = message.repeated;
                    return object;
                };

                /**
                 * Converts this Declaration to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Declaration.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Declaration
                 * @function getTypeUrl
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Declaration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.ExtensionRangeOptions.Declaration";
                };

                return Declaration;
            })();

            /**
             * VerificationState enum.
             * @name google.protobuf.ExtensionRangeOptions.VerificationState
             * @enum {number}
             * @property {number} DECLARATION=0 DECLARATION value
             * @property {number} UNVERIFIED=1 UNVERIFIED value
             */
            ExtensionRangeOptions.VerificationState = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DECLARATION"] = 0;
                values[valuesById[1] = "UNVERIFIED"] = 1;
                return values;
            })();

            return ExtensionRangeOptions;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             * @property {boolean|null} [proto3Optional] FieldDescriptorProto proto3Optional
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * FieldDescriptorProto proto3Optional.
             * @member {boolean} proto3Optional
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.proto3Optional = false;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                if (message.proto3Optional != null && Object.hasOwnProperty.call(message, "proto3Optional"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.proto3Optional);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.number = reader.int32();
                            break;
                        }
                    case 4: {
                            message.label = reader.int32();
                            break;
                        }
                    case 5: {
                            message.type = reader.int32();
                            break;
                        }
                    case 6: {
                            message.typeName = reader.string();
                            break;
                        }
                    case 2: {
                            message.extendee = reader.string();
                            break;
                        }
                    case 7: {
                            message.defaultValue = reader.string();
                            break;
                        }
                    case 9: {
                            message.oneofIndex = reader.int32();
                            break;
                        }
                    case 10: {
                            message.jsonName = reader.string();
                            break;
                        }
                    case 8: {
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.proto3Optional = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 3:
                    case 2:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    if (typeof message.proto3Optional !== "boolean")
                        return "proto3Optional: boolean expected";
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                default:
                    if (typeof object.label === "number") {
                        message.label = object.label;
                        break;
                    }
                    break;
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                }
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                if (object.proto3Optional != null)
                    message.proto3Optional = Boolean(object.proto3Optional);
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                    object.proto3Optional = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] === undefined ? message.label : $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] === undefined ? message.type : $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    object.proto3Optional = message.proto3Optional;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FieldDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FieldDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FieldDescriptorProto";
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OneofDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OneofDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.OneofDescriptorProto";
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             * @property {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>|null} [reservedRange] EnumDescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] EnumDescriptorProto reservedName
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * EnumDescriptorProto reservedRange.
             * @member {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>} reservedRange
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * EnumDescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.EnumDescriptorProto.EnumReservedRange.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.value = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumDescriptorProto";
            };

            EnumDescriptorProto.EnumReservedRange = (function() {

                /**
                 * Properties of an EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @interface IEnumReservedRange
                 * @property {number|null} [start] EnumReservedRange start
                 * @property {number|null} [end] EnumReservedRange end
                 */

                /**
                 * Constructs a new EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @classdesc Represents an EnumReservedRange.
                 * @implements IEnumReservedRange
                 * @constructor
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange=} [properties] Properties to set
                 */
                function EnumReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EnumReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.start = 0;

                /**
                 * EnumReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.end = 0;

                /**
                 * Creates a new EnumReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange instance
                 */
                EnumReservedRange.create = function create(properties) {
                    return new EnumReservedRange(properties);
                };

                /**
                 * Encodes the specified EnumReservedRange message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.EnumReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange} message EnumReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified EnumReservedRange message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.EnumReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange} message EnumReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EnumReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto.EnumReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = reader.int32();
                                break;
                            }
                        case 2: {
                                message.end = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EnumReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EnumReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an EnumReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 */
                EnumReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto.EnumReservedRange)
                        return object;
                    let message = new $root.google.protobuf.EnumDescriptorProto.EnumReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an EnumReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.EnumReservedRange} message EnumReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this EnumReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EnumReservedRange
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumReservedRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumDescriptorProto.EnumReservedRange";
                };

                return EnumReservedRange;
            })();

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.number = reader.int32();
                            break;
                        }
                    case 3: {
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumValueDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumValueDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumValueDescriptorProto";
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServiceDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServiceDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ServiceDescriptorProto";
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.inputType = reader.string();
                            break;
                        }
                    case 3: {
                            message.outputType = reader.string();
                            break;
                        }
                    case 4: {
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.clientStreaming = reader.bool();
                            break;
                        }
                    case 6: {
                            message.serverStreaming = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MethodDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MethodDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.MethodDescriptorProto";
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {string|null} [swiftPrefix] FileOptions swiftPrefix
             * @property {string|null} [phpClassPrefix] FileOptions phpClassPrefix
             * @property {string|null} [phpNamespace] FileOptions phpNamespace
             * @property {string|null} [phpMetadataNamespace] FileOptions phpMetadataNamespace
             * @property {string|null} [rubyPackage] FileOptions rubyPackage
             * @property {google.protobuf.IFeatureSet|null} [features] FileOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = true;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions swiftPrefix.
             * @member {string} swiftPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.swiftPrefix = "";

            /**
             * FileOptions phpClassPrefix.
             * @member {string} phpClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpClassPrefix = "";

            /**
             * FileOptions phpNamespace.
             * @member {string} phpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpNamespace = "";

            /**
             * FileOptions phpMetadataNamespace.
             * @member {string} phpMetadataNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpMetadataNamespace = "";

            /**
             * FileOptions rubyPackage.
             * @member {string} rubyPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.rubyPackage = "";

            /**
             * FileOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.features = null;

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.swiftPrefix != null && Object.hasOwnProperty.call(message, "swiftPrefix"))
                    writer.uint32(/* id 39, wireType 2 =*/314).string(message.swiftPrefix);
                if (message.phpClassPrefix != null && Object.hasOwnProperty.call(message, "phpClassPrefix"))
                    writer.uint32(/* id 40, wireType 2 =*/322).string(message.phpClassPrefix);
                if (message.phpNamespace != null && Object.hasOwnProperty.call(message, "phpNamespace"))
                    writer.uint32(/* id 41, wireType 2 =*/330).string(message.phpNamespace);
                if (message.phpMetadataNamespace != null && Object.hasOwnProperty.call(message, "phpMetadataNamespace"))
                    writer.uint32(/* id 44, wireType 2 =*/354).string(message.phpMetadataNamespace);
                if (message.rubyPackage != null && Object.hasOwnProperty.call(message, "rubyPackage"))
                    writer.uint32(/* id 45, wireType 2 =*/362).string(message.rubyPackage);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.javaPackage = reader.string();
                            break;
                        }
                    case 8: {
                            message.javaOuterClassname = reader.string();
                            break;
                        }
                    case 10: {
                            message.javaMultipleFiles = reader.bool();
                            break;
                        }
                    case 20: {
                            message.javaGenerateEqualsAndHash = reader.bool();
                            break;
                        }
                    case 27: {
                            message.javaStringCheckUtf8 = reader.bool();
                            break;
                        }
                    case 9: {
                            message.optimizeFor = reader.int32();
                            break;
                        }
                    case 11: {
                            message.goPackage = reader.string();
                            break;
                        }
                    case 16: {
                            message.ccGenericServices = reader.bool();
                            break;
                        }
                    case 17: {
                            message.javaGenericServices = reader.bool();
                            break;
                        }
                    case 18: {
                            message.pyGenericServices = reader.bool();
                            break;
                        }
                    case 23: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 31: {
                            message.ccEnableArenas = reader.bool();
                            break;
                        }
                    case 36: {
                            message.objcClassPrefix = reader.string();
                            break;
                        }
                    case 37: {
                            message.csharpNamespace = reader.string();
                            break;
                        }
                    case 39: {
                            message.swiftPrefix = reader.string();
                            break;
                        }
                    case 40: {
                            message.phpClassPrefix = reader.string();
                            break;
                        }
                    case 41: {
                            message.phpNamespace = reader.string();
                            break;
                        }
                    case 44: {
                            message.phpMetadataNamespace = reader.string();
                            break;
                        }
                    case 45: {
                            message.rubyPackage = reader.string();
                            break;
                        }
                    case 50: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    if (!$util.isString(message.swiftPrefix))
                        return "swiftPrefix: string expected";
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    if (!$util.isString(message.phpClassPrefix))
                        return "phpClassPrefix: string expected";
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    if (!$util.isString(message.phpNamespace))
                        return "phpNamespace: string expected";
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    if (!$util.isString(message.phpMetadataNamespace))
                        return "phpMetadataNamespace: string expected";
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    if (!$util.isString(message.rubyPackage))
                        return "rubyPackage: string expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                default:
                    if (typeof object.optimizeFor === "number") {
                        message.optimizeFor = object.optimizeFor;
                        break;
                    }
                    break;
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.swiftPrefix != null)
                    message.swiftPrefix = String(object.swiftPrefix);
                if (object.phpClassPrefix != null)
                    message.phpClassPrefix = String(object.phpClassPrefix);
                if (object.phpNamespace != null)
                    message.phpNamespace = String(object.phpNamespace);
                if (object.phpMetadataNamespace != null)
                    message.phpMetadataNamespace = String(object.phpMetadataNamespace);
                if (object.rubyPackage != null)
                    message.rubyPackage = String(object.rubyPackage);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.FileOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = true;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                    object.swiftPrefix = "";
                    object.phpClassPrefix = "";
                    object.phpNamespace = "";
                    object.phpMetadataNamespace = "";
                    object.rubyPackage = "";
                    object.features = null;
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] === undefined ? message.optimizeFor : $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    object.swiftPrefix = message.swiftPrefix;
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    object.phpClassPrefix = message.phpClassPrefix;
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    object.phpNamespace = message.phpNamespace;
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    object.phpMetadataNamespace = message.phpMetadataNamespace;
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    object.rubyPackage = message.rubyPackage;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileOptions
             * @function getTypeUrl
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FileOptions";
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {boolean|null} [deprecatedLegacyJsonFieldConflicts] MessageOptions deprecatedLegacyJsonFieldConflicts
             * @property {google.protobuf.IFeatureSet|null} [features] MessageOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions deprecatedLegacyJsonFieldConflicts.
             * @member {boolean} deprecatedLegacyJsonFieldConflicts
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecatedLegacyJsonFieldConflicts = false;

            /**
             * MessageOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.features = null;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.deprecatedLegacyJsonFieldConflicts != null && Object.hasOwnProperty.call(message, "deprecatedLegacyJsonFieldConflicts"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.deprecatedLegacyJsonFieldConflicts);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageSetWireFormat = reader.bool();
                            break;
                        }
                    case 2: {
                            message.noStandardDescriptorAccessor = reader.bool();
                            break;
                        }
                    case 3: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 7: {
                            message.mapEntry = reader.bool();
                            break;
                        }
                    case 11: {
                            message.deprecatedLegacyJsonFieldConflicts = reader.bool();
                            break;
                        }
                    case 12: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    if (typeof message.deprecatedLegacyJsonFieldConflicts !== "boolean")
                        return "deprecatedLegacyJsonFieldConflicts: boolean expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.deprecatedLegacyJsonFieldConflicts != null)
                    message.deprecatedLegacyJsonFieldConflicts = Boolean(object.deprecatedLegacyJsonFieldConflicts);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.MessageOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                    object.deprecatedLegacyJsonFieldConflicts = false;
                    object.features = null;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    object.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageOptions
             * @function getTypeUrl
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.MessageOptions";
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [unverifiedLazy] FieldOptions unverifiedLazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {boolean|null} [debugRedact] FieldOptions debugRedact
             * @property {google.protobuf.FieldOptions.OptionRetention|null} [retention] FieldOptions retention
             * @property {Array.<google.protobuf.FieldOptions.OptionTargetType>|null} [targets] FieldOptions targets
             * @property {Array.<google.protobuf.FieldOptions.IEditionDefault>|null} [editionDefaults] FieldOptions editionDefaults
             * @property {google.protobuf.IFeatureSet|null} [features] FieldOptions features
             * @property {google.protobuf.FieldOptions.IFeatureSupport|null} [featureSupport] FieldOptions featureSupport
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.targets = [];
                this.editionDefaults = [];
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions unverifiedLazy.
             * @member {boolean} unverifiedLazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.unverifiedLazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions debugRedact.
             * @member {boolean} debugRedact
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.debugRedact = false;

            /**
             * FieldOptions retention.
             * @member {google.protobuf.FieldOptions.OptionRetention} retention
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.retention = 0;

            /**
             * FieldOptions targets.
             * @member {Array.<google.protobuf.FieldOptions.OptionTargetType>} targets
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.targets = $util.emptyArray;

            /**
             * FieldOptions editionDefaults.
             * @member {Array.<google.protobuf.FieldOptions.IEditionDefault>} editionDefaults
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.editionDefaults = $util.emptyArray;

            /**
             * FieldOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.features = null;

            /**
             * FieldOptions featureSupport.
             * @member {google.protobuf.FieldOptions.IFeatureSupport|null|undefined} featureSupport
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.featureSupport = null;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.unverifiedLazy != null && Object.hasOwnProperty.call(message, "unverifiedLazy"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.unverifiedLazy);
                if (message.debugRedact != null && Object.hasOwnProperty.call(message, "debugRedact"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.debugRedact);
                if (message.retention != null && Object.hasOwnProperty.call(message, "retention"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.retention);
                if (message.targets != null && message.targets.length)
                    for (let i = 0; i < message.targets.length; ++i)
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.targets[i]);
                if (message.editionDefaults != null && message.editionDefaults.length)
                    for (let i = 0; i < message.editionDefaults.length; ++i)
                        $root.google.protobuf.FieldOptions.EditionDefault.encode(message.editionDefaults[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.featureSupport != null && Object.hasOwnProperty.call(message, "featureSupport"))
                    $root.google.protobuf.FieldOptions.FeatureSupport.encode(message.featureSupport, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.ctype = reader.int32();
                            break;
                        }
                    case 2: {
                            message.packed = reader.bool();
                            break;
                        }
                    case 6: {
                            message.jstype = reader.int32();
                            break;
                        }
                    case 5: {
                            message.lazy = reader.bool();
                            break;
                        }
                    case 15: {
                            message.unverifiedLazy = reader.bool();
                            break;
                        }
                    case 3: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 10: {
                            message.weak = reader.bool();
                            break;
                        }
                    case 16: {
                            message.debugRedact = reader.bool();
                            break;
                        }
                    case 17: {
                            message.retention = reader.int32();
                            break;
                        }
                    case 19: {
                            if (!(message.targets && message.targets.length))
                                message.targets = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targets.push(reader.int32());
                            } else
                                message.targets.push(reader.int32());
                            break;
                        }
                    case 20: {
                            if (!(message.editionDefaults && message.editionDefaults.length))
                                message.editionDefaults = [];
                            message.editionDefaults.push($root.google.protobuf.FieldOptions.EditionDefault.decode(reader, reader.uint32()));
                            break;
                        }
                    case 21: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.unverifiedLazy != null && message.hasOwnProperty("unverifiedLazy"))
                    if (typeof message.unverifiedLazy !== "boolean")
                        return "unverifiedLazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    if (typeof message.debugRedact !== "boolean")
                        return "debugRedact: boolean expected";
                if (message.retention != null && message.hasOwnProperty("retention"))
                    switch (message.retention) {
                    default:
                        return "retention: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.targets != null && message.hasOwnProperty("targets")) {
                    if (!Array.isArray(message.targets))
                        return "targets: array expected";
                    for (let i = 0; i < message.targets.length; ++i)
                        switch (message.targets[i]) {
                        default:
                            return "targets: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                }
                if (message.editionDefaults != null && message.hasOwnProperty("editionDefaults")) {
                    if (!Array.isArray(message.editionDefaults))
                        return "editionDefaults: array expected";
                    for (let i = 0; i < message.editionDefaults.length; ++i) {
                        let error = $root.google.protobuf.FieldOptions.EditionDefault.verify(message.editionDefaults[i]);
                        if (error)
                            return "editionDefaults." + error;
                    }
                }
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport")) {
                    let error = $root.google.protobuf.FieldOptions.FeatureSupport.verify(message.featureSupport);
                    if (error)
                        return "featureSupport." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                default:
                    if (typeof object.ctype === "number") {
                        message.ctype = object.ctype;
                        break;
                    }
                    break;
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                default:
                    if (typeof object.jstype === "number") {
                        message.jstype = object.jstype;
                        break;
                    }
                    break;
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.unverifiedLazy != null)
                    message.unverifiedLazy = Boolean(object.unverifiedLazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.debugRedact != null)
                    message.debugRedact = Boolean(object.debugRedact);
                switch (object.retention) {
                default:
                    if (typeof object.retention === "number") {
                        message.retention = object.retention;
                        break;
                    }
                    break;
                case "RETENTION_UNKNOWN":
                case 0:
                    message.retention = 0;
                    break;
                case "RETENTION_RUNTIME":
                case 1:
                    message.retention = 1;
                    break;
                case "RETENTION_SOURCE":
                case 2:
                    message.retention = 2;
                    break;
                }
                if (object.targets) {
                    if (!Array.isArray(object.targets))
                        throw TypeError(".google.protobuf.FieldOptions.targets: array expected");
                    message.targets = [];
                    for (let i = 0; i < object.targets.length; ++i)
                        switch (object.targets[i]) {
                        default:
                            if (typeof object.targets[i] === "number") {
                                message.targets[i] = object.targets[i];
                                break;
                            }
                        case "TARGET_TYPE_UNKNOWN":
                        case 0:
                            message.targets[i] = 0;
                            break;
                        case "TARGET_TYPE_FILE":
                        case 1:
                            message.targets[i] = 1;
                            break;
                        case "TARGET_TYPE_EXTENSION_RANGE":
                        case 2:
                            message.targets[i] = 2;
                            break;
                        case "TARGET_TYPE_MESSAGE":
                        case 3:
                            message.targets[i] = 3;
                            break;
                        case "TARGET_TYPE_FIELD":
                        case 4:
                            message.targets[i] = 4;
                            break;
                        case "TARGET_TYPE_ONEOF":
                        case 5:
                            message.targets[i] = 5;
                            break;
                        case "TARGET_TYPE_ENUM":
                        case 6:
                            message.targets[i] = 6;
                            break;
                        case "TARGET_TYPE_ENUM_ENTRY":
                        case 7:
                            message.targets[i] = 7;
                            break;
                        case "TARGET_TYPE_SERVICE":
                        case 8:
                            message.targets[i] = 8;
                            break;
                        case "TARGET_TYPE_METHOD":
                        case 9:
                            message.targets[i] = 9;
                            break;
                        }
                }
                if (object.editionDefaults) {
                    if (!Array.isArray(object.editionDefaults))
                        throw TypeError(".google.protobuf.FieldOptions.editionDefaults: array expected");
                    message.editionDefaults = [];
                    for (let i = 0; i < object.editionDefaults.length; ++i) {
                        if (typeof object.editionDefaults[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.editionDefaults: object expected");
                        message.editionDefaults[i] = $root.google.protobuf.FieldOptions.EditionDefault.fromObject(object.editionDefaults[i]);
                    }
                }
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.FieldOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.featureSupport != null) {
                    if (typeof object.featureSupport !== "object")
                        throw TypeError(".google.protobuf.FieldOptions.featureSupport: object expected");
                    message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.fromObject(object.featureSupport);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.targets = [];
                    object.editionDefaults = [];
                    object.uninterpretedOption = [];
                }
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object.unverifiedLazy = false;
                    object.debugRedact = false;
                    object.retention = options.enums === String ? "RETENTION_UNKNOWN" : 0;
                    object.features = null;
                    object.featureSupport = null;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] === undefined ? message.ctype : $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] === undefined ? message.jstype : $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.unverifiedLazy != null && message.hasOwnProperty("unverifiedLazy"))
                    object.unverifiedLazy = message.unverifiedLazy;
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    object.debugRedact = message.debugRedact;
                if (message.retention != null && message.hasOwnProperty("retention"))
                    object.retention = options.enums === String ? $root.google.protobuf.FieldOptions.OptionRetention[message.retention] === undefined ? message.retention : $root.google.protobuf.FieldOptions.OptionRetention[message.retention] : message.retention;
                if (message.targets && message.targets.length) {
                    object.targets = [];
                    for (let j = 0; j < message.targets.length; ++j)
                        object.targets[j] = options.enums === String ? $root.google.protobuf.FieldOptions.OptionTargetType[message.targets[j]] === undefined ? message.targets[j] : $root.google.protobuf.FieldOptions.OptionTargetType[message.targets[j]] : message.targets[j];
                }
                if (message.editionDefaults && message.editionDefaults.length) {
                    object.editionDefaults = [];
                    for (let j = 0; j < message.editionDefaults.length; ++j)
                        object.editionDefaults[j] = $root.google.protobuf.FieldOptions.EditionDefault.toObject(message.editionDefaults[j], options);
                }
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport"))
                    object.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.toObject(message.featureSupport, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FieldOptions
             * @function getTypeUrl
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FieldOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FieldOptions";
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            /**
             * OptionRetention enum.
             * @name google.protobuf.FieldOptions.OptionRetention
             * @enum {number}
             * @property {number} RETENTION_UNKNOWN=0 RETENTION_UNKNOWN value
             * @property {number} RETENTION_RUNTIME=1 RETENTION_RUNTIME value
             * @property {number} RETENTION_SOURCE=2 RETENTION_SOURCE value
             */
            FieldOptions.OptionRetention = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RETENTION_UNKNOWN"] = 0;
                values[valuesById[1] = "RETENTION_RUNTIME"] = 1;
                values[valuesById[2] = "RETENTION_SOURCE"] = 2;
                return values;
            })();

            /**
             * OptionTargetType enum.
             * @name google.protobuf.FieldOptions.OptionTargetType
             * @enum {number}
             * @property {number} TARGET_TYPE_UNKNOWN=0 TARGET_TYPE_UNKNOWN value
             * @property {number} TARGET_TYPE_FILE=1 TARGET_TYPE_FILE value
             * @property {number} TARGET_TYPE_EXTENSION_RANGE=2 TARGET_TYPE_EXTENSION_RANGE value
             * @property {number} TARGET_TYPE_MESSAGE=3 TARGET_TYPE_MESSAGE value
             * @property {number} TARGET_TYPE_FIELD=4 TARGET_TYPE_FIELD value
             * @property {number} TARGET_TYPE_ONEOF=5 TARGET_TYPE_ONEOF value
             * @property {number} TARGET_TYPE_ENUM=6 TARGET_TYPE_ENUM value
             * @property {number} TARGET_TYPE_ENUM_ENTRY=7 TARGET_TYPE_ENUM_ENTRY value
             * @property {number} TARGET_TYPE_SERVICE=8 TARGET_TYPE_SERVICE value
             * @property {number} TARGET_TYPE_METHOD=9 TARGET_TYPE_METHOD value
             */
            FieldOptions.OptionTargetType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TARGET_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TARGET_TYPE_FILE"] = 1;
                values[valuesById[2] = "TARGET_TYPE_EXTENSION_RANGE"] = 2;
                values[valuesById[3] = "TARGET_TYPE_MESSAGE"] = 3;
                values[valuesById[4] = "TARGET_TYPE_FIELD"] = 4;
                values[valuesById[5] = "TARGET_TYPE_ONEOF"] = 5;
                values[valuesById[6] = "TARGET_TYPE_ENUM"] = 6;
                values[valuesById[7] = "TARGET_TYPE_ENUM_ENTRY"] = 7;
                values[valuesById[8] = "TARGET_TYPE_SERVICE"] = 8;
                values[valuesById[9] = "TARGET_TYPE_METHOD"] = 9;
                return values;
            })();

            FieldOptions.EditionDefault = (function() {

                /**
                 * Properties of an EditionDefault.
                 * @memberof google.protobuf.FieldOptions
                 * @interface IEditionDefault
                 * @property {google.protobuf.Edition|null} [edition] EditionDefault edition
                 * @property {string|null} [value] EditionDefault value
                 */

                /**
                 * Constructs a new EditionDefault.
                 * @memberof google.protobuf.FieldOptions
                 * @classdesc Represents an EditionDefault.
                 * @implements IEditionDefault
                 * @constructor
                 * @param {google.protobuf.FieldOptions.IEditionDefault=} [properties] Properties to set
                 */
                function EditionDefault(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EditionDefault edition.
                 * @member {google.protobuf.Edition} edition
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @instance
                 */
                EditionDefault.prototype.edition = 0;

                /**
                 * EditionDefault value.
                 * @member {string} value
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @instance
                 */
                EditionDefault.prototype.value = "";

                /**
                 * Creates a new EditionDefault instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.IEditionDefault=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault instance
                 */
                EditionDefault.create = function create(properties) {
                    return new EditionDefault(properties);
                };

                /**
                 * Encodes the specified EditionDefault message. Does not implicitly {@link google.protobuf.FieldOptions.EditionDefault.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.IEditionDefault} message EditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EditionDefault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    if (message.edition != null && Object.hasOwnProperty.call(message, "edition"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.edition);
                    return writer;
                };

                /**
                 * Encodes the specified EditionDefault message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.EditionDefault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.IEditionDefault} message EditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EditionDefault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EditionDefault message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EditionDefault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions.EditionDefault();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3: {
                                message.edition = reader.int32();
                                break;
                            }
                        case 2: {
                                message.value = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EditionDefault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EditionDefault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EditionDefault message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EditionDefault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        switch (message.edition) {
                        default:
                            return "edition: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };

                /**
                 * Creates an EditionDefault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault
                 */
                EditionDefault.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions.EditionDefault)
                        return object;
                    let message = new $root.google.protobuf.FieldOptions.EditionDefault();
                    switch (object.edition) {
                    default:
                        if (typeof object.edition === "number") {
                            message.edition = object.edition;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.edition = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.edition = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.edition = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.edition = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.edition = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.edition = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.edition = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.edition = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.edition = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.edition = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.edition = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.edition = 2147483647;
                        break;
                    }
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from an EditionDefault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.EditionDefault} message EditionDefault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EditionDefault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.value = "";
                        object.edition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                    }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        object.edition = options.enums === String ? $root.google.protobuf.Edition[message.edition] === undefined ? message.edition : $root.google.protobuf.Edition[message.edition] : message.edition;
                    return object;
                };

                /**
                 * Converts this EditionDefault to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EditionDefault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EditionDefault
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EditionDefault.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldOptions.EditionDefault";
                };

                return EditionDefault;
            })();

            FieldOptions.FeatureSupport = (function() {

                /**
                 * Properties of a FeatureSupport.
                 * @memberof google.protobuf.FieldOptions
                 * @interface IFeatureSupport
                 * @property {google.protobuf.Edition|null} [editionIntroduced] FeatureSupport editionIntroduced
                 * @property {google.protobuf.Edition|null} [editionDeprecated] FeatureSupport editionDeprecated
                 * @property {string|null} [deprecationWarning] FeatureSupport deprecationWarning
                 * @property {google.protobuf.Edition|null} [editionRemoved] FeatureSupport editionRemoved
                 */

                /**
                 * Constructs a new FeatureSupport.
                 * @memberof google.protobuf.FieldOptions
                 * @classdesc Represents a FeatureSupport.
                 * @implements IFeatureSupport
                 * @constructor
                 * @param {google.protobuf.FieldOptions.IFeatureSupport=} [properties] Properties to set
                 */
                function FeatureSupport(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FeatureSupport editionIntroduced.
                 * @member {google.protobuf.Edition} editionIntroduced
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.editionIntroduced = 0;

                /**
                 * FeatureSupport editionDeprecated.
                 * @member {google.protobuf.Edition} editionDeprecated
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.editionDeprecated = 0;

                /**
                 * FeatureSupport deprecationWarning.
                 * @member {string} deprecationWarning
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.deprecationWarning = "";

                /**
                 * FeatureSupport editionRemoved.
                 * @member {google.protobuf.Edition} editionRemoved
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.editionRemoved = 0;

                /**
                 * Creates a new FeatureSupport instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.IFeatureSupport=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport instance
                 */
                FeatureSupport.create = function create(properties) {
                    return new FeatureSupport(properties);
                };

                /**
                 * Encodes the specified FeatureSupport message. Does not implicitly {@link google.protobuf.FieldOptions.FeatureSupport.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.IFeatureSupport} message FeatureSupport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSupport.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.editionIntroduced != null && Object.hasOwnProperty.call(message, "editionIntroduced"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.editionIntroduced);
                    if (message.editionDeprecated != null && Object.hasOwnProperty.call(message, "editionDeprecated"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.editionDeprecated);
                    if (message.deprecationWarning != null && Object.hasOwnProperty.call(message, "deprecationWarning"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.deprecationWarning);
                    if (message.editionRemoved != null && Object.hasOwnProperty.call(message, "editionRemoved"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.editionRemoved);
                    return writer;
                };

                /**
                 * Encodes the specified FeatureSupport message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.FeatureSupport.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.IFeatureSupport} message FeatureSupport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSupport.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FeatureSupport message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSupport.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions.FeatureSupport();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.editionIntroduced = reader.int32();
                                break;
                            }
                        case 2: {
                                message.editionDeprecated = reader.int32();
                                break;
                            }
                        case 3: {
                                message.deprecationWarning = reader.string();
                                break;
                            }
                        case 4: {
                                message.editionRemoved = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FeatureSupport message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSupport.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FeatureSupport message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureSupport.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.editionIntroduced != null && message.hasOwnProperty("editionIntroduced"))
                        switch (message.editionIntroduced) {
                        default:
                            return "editionIntroduced: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.editionDeprecated != null && message.hasOwnProperty("editionDeprecated"))
                        switch (message.editionDeprecated) {
                        default:
                            return "editionDeprecated: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.deprecationWarning != null && message.hasOwnProperty("deprecationWarning"))
                        if (!$util.isString(message.deprecationWarning))
                            return "deprecationWarning: string expected";
                    if (message.editionRemoved != null && message.hasOwnProperty("editionRemoved"))
                        switch (message.editionRemoved) {
                        default:
                            return "editionRemoved: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a FeatureSupport message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport
                 */
                FeatureSupport.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions.FeatureSupport)
                        return object;
                    let message = new $root.google.protobuf.FieldOptions.FeatureSupport();
                    switch (object.editionIntroduced) {
                    default:
                        if (typeof object.editionIntroduced === "number") {
                            message.editionIntroduced = object.editionIntroduced;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.editionIntroduced = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.editionIntroduced = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.editionIntroduced = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.editionIntroduced = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.editionIntroduced = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.editionIntroduced = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.editionIntroduced = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.editionIntroduced = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.editionIntroduced = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.editionIntroduced = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.editionIntroduced = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.editionIntroduced = 2147483647;
                        break;
                    }
                    switch (object.editionDeprecated) {
                    default:
                        if (typeof object.editionDeprecated === "number") {
                            message.editionDeprecated = object.editionDeprecated;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.editionDeprecated = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.editionDeprecated = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.editionDeprecated = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.editionDeprecated = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.editionDeprecated = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.editionDeprecated = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.editionDeprecated = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.editionDeprecated = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.editionDeprecated = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.editionDeprecated = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.editionDeprecated = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.editionDeprecated = 2147483647;
                        break;
                    }
                    if (object.deprecationWarning != null)
                        message.deprecationWarning = String(object.deprecationWarning);
                    switch (object.editionRemoved) {
                    default:
                        if (typeof object.editionRemoved === "number") {
                            message.editionRemoved = object.editionRemoved;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.editionRemoved = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.editionRemoved = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.editionRemoved = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.editionRemoved = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.editionRemoved = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.editionRemoved = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.editionRemoved = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.editionRemoved = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.editionRemoved = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.editionRemoved = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.editionRemoved = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.editionRemoved = 2147483647;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FeatureSupport message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.FeatureSupport} message FeatureSupport
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureSupport.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.editionIntroduced = options.enums === String ? "EDITION_UNKNOWN" : 0;
                        object.editionDeprecated = options.enums === String ? "EDITION_UNKNOWN" : 0;
                        object.deprecationWarning = "";
                        object.editionRemoved = options.enums === String ? "EDITION_UNKNOWN" : 0;
                    }
                    if (message.editionIntroduced != null && message.hasOwnProperty("editionIntroduced"))
                        object.editionIntroduced = options.enums === String ? $root.google.protobuf.Edition[message.editionIntroduced] === undefined ? message.editionIntroduced : $root.google.protobuf.Edition[message.editionIntroduced] : message.editionIntroduced;
                    if (message.editionDeprecated != null && message.hasOwnProperty("editionDeprecated"))
                        object.editionDeprecated = options.enums === String ? $root.google.protobuf.Edition[message.editionDeprecated] === undefined ? message.editionDeprecated : $root.google.protobuf.Edition[message.editionDeprecated] : message.editionDeprecated;
                    if (message.deprecationWarning != null && message.hasOwnProperty("deprecationWarning"))
                        object.deprecationWarning = message.deprecationWarning;
                    if (message.editionRemoved != null && message.hasOwnProperty("editionRemoved"))
                        object.editionRemoved = options.enums === String ? $root.google.protobuf.Edition[message.editionRemoved] === undefined ? message.editionRemoved : $root.google.protobuf.Edition[message.editionRemoved] : message.editionRemoved;
                    return object;
                };

                /**
                 * Converts this FeatureSupport to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureSupport.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FeatureSupport
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FeatureSupport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldOptions.FeatureSupport";
                };

                return FeatureSupport;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {google.protobuf.IFeatureSet|null} [features] OneofOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.features = null;

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.OneofOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.features = null;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OneofOptions
             * @function getTypeUrl
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OneofOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.OneofOptions";
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {boolean|null} [deprecatedLegacyJsonFieldConflicts] EnumOptions deprecatedLegacyJsonFieldConflicts
             * @property {google.protobuf.IFeatureSet|null} [features] EnumOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions deprecatedLegacyJsonFieldConflicts.
             * @member {boolean} deprecatedLegacyJsonFieldConflicts
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecatedLegacyJsonFieldConflicts = false;

            /**
             * EnumOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.features = null;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.deprecatedLegacyJsonFieldConflicts != null && Object.hasOwnProperty.call(message, "deprecatedLegacyJsonFieldConflicts"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.deprecatedLegacyJsonFieldConflicts);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.allowAlias = reader.bool();
                            break;
                        }
                    case 3: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 6: {
                            message.deprecatedLegacyJsonFieldConflicts = reader.bool();
                            break;
                        }
                    case 7: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    if (typeof message.deprecatedLegacyJsonFieldConflicts !== "boolean")
                        return "deprecatedLegacyJsonFieldConflicts: boolean expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.deprecatedLegacyJsonFieldConflicts != null)
                    message.deprecatedLegacyJsonFieldConflicts = Boolean(object.deprecatedLegacyJsonFieldConflicts);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.EnumOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                    object.deprecatedLegacyJsonFieldConflicts = false;
                    object.features = null;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    object.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumOptions
             * @function getTypeUrl
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumOptions";
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {google.protobuf.IFeatureSet|null} [features] EnumValueOptions features
             * @property {boolean|null} [debugRedact] EnumValueOptions debugRedact
             * @property {google.protobuf.FieldOptions.IFeatureSupport|null} [featureSupport] EnumValueOptions featureSupport
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.features = null;

            /**
             * EnumValueOptions debugRedact.
             * @member {boolean} debugRedact
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.debugRedact = false;

            /**
             * EnumValueOptions featureSupport.
             * @member {google.protobuf.FieldOptions.IFeatureSupport|null|undefined} featureSupport
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.featureSupport = null;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.debugRedact != null && Object.hasOwnProperty.call(message, "debugRedact"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.debugRedact);
                if (message.featureSupport != null && Object.hasOwnProperty.call(message, "featureSupport"))
                    $root.google.protobuf.FieldOptions.FeatureSupport.encode(message.featureSupport, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 2: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.debugRedact = reader.bool();
                            break;
                        }
                    case 4: {
                            message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    if (typeof message.debugRedact !== "boolean")
                        return "debugRedact: boolean expected";
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport")) {
                    let error = $root.google.protobuf.FieldOptions.FeatureSupport.verify(message.featureSupport);
                    if (error)
                        return "featureSupport." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.EnumValueOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.debugRedact != null)
                    message.debugRedact = Boolean(object.debugRedact);
                if (object.featureSupport != null) {
                    if (typeof object.featureSupport !== "object")
                        throw TypeError(".google.protobuf.EnumValueOptions.featureSupport: object expected");
                    message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.fromObject(object.featureSupport);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object.features = null;
                    object.debugRedact = false;
                    object.featureSupport = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    object.debugRedact = message.debugRedact;
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport"))
                    object.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.toObject(message.featureSupport, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumValueOptions
             * @function getTypeUrl
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumValueOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumValueOptions";
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {google.protobuf.IFeatureSet|null} [features] ServiceOptions features
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             * @property {string|null} [".google.api.defaultHost"] ServiceOptions .google.api.defaultHost
             * @property {string|null} [".google.api.oauthScopes"] ServiceOptions .google.api.oauthScopes
             * @property {string|null} [".google.api.apiVersion"] ServiceOptions .google.api.apiVersion
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.features = null;

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * ServiceOptions .google.api.defaultHost.
             * @member {string} .google.api.defaultHost
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype[".google.api.defaultHost"] = "";

            /**
             * ServiceOptions .google.api.oauthScopes.
             * @member {string} .google.api.oauthScopes
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype[".google.api.oauthScopes"] = "";

            /**
             * ServiceOptions .google.api.apiVersion.
             * @member {string} .google.api.apiVersion
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype[".google.api.apiVersion"] = "";

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.api.defaultHost"] != null && Object.hasOwnProperty.call(message, ".google.api.defaultHost"))
                    writer.uint32(/* id 1049, wireType 2 =*/8394).string(message[".google.api.defaultHost"]);
                if (message[".google.api.oauthScopes"] != null && Object.hasOwnProperty.call(message, ".google.api.oauthScopes"))
                    writer.uint32(/* id 1050, wireType 2 =*/8402).string(message[".google.api.oauthScopes"]);
                if (message[".google.api.apiVersion"] != null && Object.hasOwnProperty.call(message, ".google.api.apiVersion"))
                    writer.uint32(/* id 525000001, wireType 2 =*/4200000010).string(message[".google.api.apiVersion"]);
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 34: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 33: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    case 1049: {
                            message[".google.api.defaultHost"] = reader.string();
                            break;
                        }
                    case 1050: {
                            message[".google.api.oauthScopes"] = reader.string();
                            break;
                        }
                    case 525000001: {
                            message[".google.api.apiVersion"] = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".google.api.defaultHost"] != null && message.hasOwnProperty(".google.api.defaultHost"))
                    if (!$util.isString(message[".google.api.defaultHost"]))
                        return ".google.api.defaultHost: string expected";
                if (message[".google.api.oauthScopes"] != null && message.hasOwnProperty(".google.api.oauthScopes"))
                    if (!$util.isString(message[".google.api.oauthScopes"]))
                        return ".google.api.oauthScopes: string expected";
                if (message[".google.api.apiVersion"] != null && message.hasOwnProperty(".google.api.apiVersion"))
                    if (!$util.isString(message[".google.api.apiVersion"]))
                        return ".google.api.apiVersion: string expected";
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.ServiceOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".google.api.defaultHost"] != null)
                    message[".google.api.defaultHost"] = String(object[".google.api.defaultHost"]);
                if (object[".google.api.oauthScopes"] != null)
                    message[".google.api.oauthScopes"] = String(object[".google.api.oauthScopes"]);
                if (object[".google.api.apiVersion"] != null)
                    message[".google.api.apiVersion"] = String(object[".google.api.apiVersion"]);
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object.features = null;
                    object[".google.api.defaultHost"] = "";
                    object[".google.api.oauthScopes"] = "";
                    object[".google.api.apiVersion"] = "";
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".google.api.defaultHost"] != null && message.hasOwnProperty(".google.api.defaultHost"))
                    object[".google.api.defaultHost"] = message[".google.api.defaultHost"];
                if (message[".google.api.oauthScopes"] != null && message.hasOwnProperty(".google.api.oauthScopes"))
                    object[".google.api.oauthScopes"] = message[".google.api.oauthScopes"];
                if (message[".google.api.apiVersion"] != null && message.hasOwnProperty(".google.api.apiVersion"))
                    object[".google.api.apiVersion"] = message[".google.api.apiVersion"];
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServiceOptions
             * @function getTypeUrl
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServiceOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ServiceOptions";
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {google.protobuf.MethodOptions.IdempotencyLevel|null} [idempotencyLevel] MethodOptions idempotencyLevel
             * @property {google.protobuf.IFeatureSet|null} [features] MethodOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             * @property {Array.<string>|null} [".google.api.methodSignature"] MethodOptions .google.api.methodSignature
             * @property {google.longrunning.IOperationInfo|null} [".google.longrunning.operationInfo"] MethodOptions .google.longrunning.operationInfo
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                this[".google.api.methodSignature"] = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions idempotencyLevel.
             * @member {google.protobuf.MethodOptions.IdempotencyLevel} idempotencyLevel
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.idempotencyLevel = 0;

            /**
             * MethodOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.features = null;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * MethodOptions .google.api.methodSignature.
             * @member {Array.<string>} .google.api.methodSignature
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.methodSignature"] = $util.emptyArray;

            /**
             * MethodOptions .google.longrunning.operationInfo.
             * @member {google.longrunning.IOperationInfo|null|undefined} .google.longrunning.operationInfo
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.longrunning.operationInfo"] = null;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.idempotencyLevel != null && Object.hasOwnProperty.call(message, "idempotencyLevel"))
                    writer.uint32(/* id 34, wireType 0 =*/272).int32(message.idempotencyLevel);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.longrunning.operationInfo"] != null && Object.hasOwnProperty.call(message, ".google.longrunning.operationInfo"))
                    $root.google.longrunning.OperationInfo.encode(message[".google.longrunning.operationInfo"], writer.uint32(/* id 1049, wireType 2 =*/8394).fork()).ldelim();
                if (message[".google.api.methodSignature"] != null && message[".google.api.methodSignature"].length)
                    for (let i = 0; i < message[".google.api.methodSignature"].length; ++i)
                        writer.uint32(/* id 1051, wireType 2 =*/8410).string(message[".google.api.methodSignature"][i]);
                if (message[".google.api.http"] != null && Object.hasOwnProperty.call(message, ".google.api.http"))
                    $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 34: {
                            message.idempotencyLevel = reader.int32();
                            break;
                        }
                    case 35: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    case 72295728: {
                            message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                            break;
                        }
                    case 1051: {
                            if (!(message[".google.api.methodSignature"] && message[".google.api.methodSignature"].length))
                                message[".google.api.methodSignature"] = [];
                            message[".google.api.methodSignature"].push(reader.string());
                            break;
                        }
                    case 1049: {
                            message[".google.longrunning.operationInfo"] = $root.google.longrunning.OperationInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    switch (message.idempotencyLevel) {
                    default:
                        return "idempotencyLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    let error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                if (message[".google.api.methodSignature"] != null && message.hasOwnProperty(".google.api.methodSignature")) {
                    if (!Array.isArray(message[".google.api.methodSignature"]))
                        return ".google.api.methodSignature: array expected";
                    for (let i = 0; i < message[".google.api.methodSignature"].length; ++i)
                        if (!$util.isString(message[".google.api.methodSignature"][i]))
                            return ".google.api.methodSignature: string[] expected";
                }
                if (message[".google.longrunning.operationInfo"] != null && message.hasOwnProperty(".google.longrunning.operationInfo")) {
                    let error = $root.google.longrunning.OperationInfo.verify(message[".google.longrunning.operationInfo"]);
                    if (error)
                        return ".google.longrunning.operationInfo." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                switch (object.idempotencyLevel) {
                default:
                    if (typeof object.idempotencyLevel === "number") {
                        message.idempotencyLevel = object.idempotencyLevel;
                        break;
                    }
                    break;
                case "IDEMPOTENCY_UNKNOWN":
                case 0:
                    message.idempotencyLevel = 0;
                    break;
                case "NO_SIDE_EFFECTS":
                case 1:
                    message.idempotencyLevel = 1;
                    break;
                case "IDEMPOTENT":
                case 2:
                    message.idempotencyLevel = 2;
                    break;
                }
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.MethodOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                if (object[".google.api.methodSignature"]) {
                    if (!Array.isArray(object[".google.api.methodSignature"]))
                        throw TypeError(".google.protobuf.MethodOptions..google.api.methodSignature: array expected");
                    message[".google.api.methodSignature"] = [];
                    for (let i = 0; i < object[".google.api.methodSignature"].length; ++i)
                        message[".google.api.methodSignature"][i] = String(object[".google.api.methodSignature"][i]);
                }
                if (object[".google.longrunning.operationInfo"] != null) {
                    if (typeof object[".google.longrunning.operationInfo"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.longrunning.operationInfo: object expected");
                    message[".google.longrunning.operationInfo"] = $root.google.longrunning.OperationInfo.fromObject(object[".google.longrunning.operationInfo"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.uninterpretedOption = [];
                    object[".google.api.methodSignature"] = [];
                }
                if (options.defaults) {
                    object.deprecated = false;
                    object.idempotencyLevel = options.enums === String ? "IDEMPOTENCY_UNKNOWN" : 0;
                    object.features = null;
                    object[".google.longrunning.operationInfo"] = null;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    object.idempotencyLevel = options.enums === String ? $root.google.protobuf.MethodOptions.IdempotencyLevel[message.idempotencyLevel] === undefined ? message.idempotencyLevel : $root.google.protobuf.MethodOptions.IdempotencyLevel[message.idempotencyLevel] : message.idempotencyLevel;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".google.longrunning.operationInfo"] != null && message.hasOwnProperty(".google.longrunning.operationInfo"))
                    object[".google.longrunning.operationInfo"] = $root.google.longrunning.OperationInfo.toObject(message[".google.longrunning.operationInfo"], options);
                if (message[".google.api.methodSignature"] && message[".google.api.methodSignature"].length) {
                    object[".google.api.methodSignature"] = [];
                    for (let j = 0; j < message[".google.api.methodSignature"].length; ++j)
                        object[".google.api.methodSignature"][j] = message[".google.api.methodSignature"][j];
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MethodOptions
             * @function getTypeUrl
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MethodOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.MethodOptions";
            };

            /**
             * IdempotencyLevel enum.
             * @name google.protobuf.MethodOptions.IdempotencyLevel
             * @enum {number}
             * @property {number} IDEMPOTENCY_UNKNOWN=0 IDEMPOTENCY_UNKNOWN value
             * @property {number} NO_SIDE_EFFECTS=1 NO_SIDE_EFFECTS value
             * @property {number} IDEMPOTENT=2 IDEMPOTENT value
             */
            MethodOptions.IdempotencyLevel = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IDEMPOTENCY_UNKNOWN"] = 0;
                values[valuesById[1] = "NO_SIDE_EFFECTS"] = 1;
                values[valuesById[2] = "IDEMPOTENT"] = 2;
                return values;
            })();

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.identifierValue = reader.string();
                            break;
                        }
                    case 4: {
                            message.positiveIntValue = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.negativeIntValue = reader.int64();
                            break;
                        }
                    case 6: {
                            message.doubleValue = reader.double();
                            break;
                        }
                    case 7: {
                            message.stringValue = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.aggregateValue = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length >= 0)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UninterpretedOption
             * @function getTypeUrl
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UninterpretedOption.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UninterpretedOption";
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.namePart = reader.string();
                                break;
                            }
                        case 2: {
                                message.isExtension = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for NamePart
                 * @function getTypeUrl
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                NamePart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.UninterpretedOption.NamePart";
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.FeatureSet = (function() {

            /**
             * Properties of a FeatureSet.
             * @memberof google.protobuf
             * @interface IFeatureSet
             * @property {google.protobuf.FeatureSet.FieldPresence|null} [fieldPresence] FeatureSet fieldPresence
             * @property {google.protobuf.FeatureSet.EnumType|null} [enumType] FeatureSet enumType
             * @property {google.protobuf.FeatureSet.RepeatedFieldEncoding|null} [repeatedFieldEncoding] FeatureSet repeatedFieldEncoding
             * @property {google.protobuf.FeatureSet.Utf8Validation|null} [utf8Validation] FeatureSet utf8Validation
             * @property {google.protobuf.FeatureSet.MessageEncoding|null} [messageEncoding] FeatureSet messageEncoding
             * @property {google.protobuf.FeatureSet.JsonFormat|null} [jsonFormat] FeatureSet jsonFormat
             * @property {google.protobuf.FeatureSet.EnforceNamingStyle|null} [enforceNamingStyle] FeatureSet enforceNamingStyle
             */

            /**
             * Constructs a new FeatureSet.
             * @memberof google.protobuf
             * @classdesc Represents a FeatureSet.
             * @implements IFeatureSet
             * @constructor
             * @param {google.protobuf.IFeatureSet=} [properties] Properties to set
             */
            function FeatureSet(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FeatureSet fieldPresence.
             * @member {google.protobuf.FeatureSet.FieldPresence} fieldPresence
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.fieldPresence = 0;

            /**
             * FeatureSet enumType.
             * @member {google.protobuf.FeatureSet.EnumType} enumType
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.enumType = 0;

            /**
             * FeatureSet repeatedFieldEncoding.
             * @member {google.protobuf.FeatureSet.RepeatedFieldEncoding} repeatedFieldEncoding
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.repeatedFieldEncoding = 0;

            /**
             * FeatureSet utf8Validation.
             * @member {google.protobuf.FeatureSet.Utf8Validation} utf8Validation
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.utf8Validation = 0;

            /**
             * FeatureSet messageEncoding.
             * @member {google.protobuf.FeatureSet.MessageEncoding} messageEncoding
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.messageEncoding = 0;

            /**
             * FeatureSet jsonFormat.
             * @member {google.protobuf.FeatureSet.JsonFormat} jsonFormat
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.jsonFormat = 0;

            /**
             * FeatureSet enforceNamingStyle.
             * @member {google.protobuf.FeatureSet.EnforceNamingStyle} enforceNamingStyle
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.enforceNamingStyle = 0;

            /**
             * Creates a new FeatureSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.IFeatureSet=} [properties] Properties to set
             * @returns {google.protobuf.FeatureSet} FeatureSet instance
             */
            FeatureSet.create = function create(properties) {
                return new FeatureSet(properties);
            };

            /**
             * Encodes the specified FeatureSet message. Does not implicitly {@link google.protobuf.FeatureSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.IFeatureSet} message FeatureSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldPresence != null && Object.hasOwnProperty.call(message, "fieldPresence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldPresence);
                if (message.enumType != null && Object.hasOwnProperty.call(message, "enumType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.enumType);
                if (message.repeatedFieldEncoding != null && Object.hasOwnProperty.call(message, "repeatedFieldEncoding"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.repeatedFieldEncoding);
                if (message.utf8Validation != null && Object.hasOwnProperty.call(message, "utf8Validation"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.utf8Validation);
                if (message.messageEncoding != null && Object.hasOwnProperty.call(message, "messageEncoding"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.messageEncoding);
                if (message.jsonFormat != null && Object.hasOwnProperty.call(message, "jsonFormat"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jsonFormat);
                if (message.enforceNamingStyle != null && Object.hasOwnProperty.call(message, "enforceNamingStyle"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.enforceNamingStyle);
                return writer;
            };

            /**
             * Encodes the specified FeatureSet message, length delimited. Does not implicitly {@link google.protobuf.FeatureSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.IFeatureSet} message FeatureSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FeatureSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FeatureSet} FeatureSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FeatureSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fieldPresence = reader.int32();
                            break;
                        }
                    case 2: {
                            message.enumType = reader.int32();
                            break;
                        }
                    case 3: {
                            message.repeatedFieldEncoding = reader.int32();
                            break;
                        }
                    case 4: {
                            message.utf8Validation = reader.int32();
                            break;
                        }
                    case 5: {
                            message.messageEncoding = reader.int32();
                            break;
                        }
                    case 6: {
                            message.jsonFormat = reader.int32();
                            break;
                        }
                    case 7: {
                            message.enforceNamingStyle = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FeatureSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FeatureSet} FeatureSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FeatureSet message.
             * @function verify
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FeatureSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldPresence != null && message.hasOwnProperty("fieldPresence"))
                    switch (message.fieldPresence) {
                    default:
                        return "fieldPresence: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.enumType != null && message.hasOwnProperty("enumType"))
                    switch (message.enumType) {
                    default:
                        return "enumType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.repeatedFieldEncoding != null && message.hasOwnProperty("repeatedFieldEncoding"))
                    switch (message.repeatedFieldEncoding) {
                    default:
                        return "repeatedFieldEncoding: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.utf8Validation != null && message.hasOwnProperty("utf8Validation"))
                    switch (message.utf8Validation) {
                    default:
                        return "utf8Validation: enum value expected";
                    case 0:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.messageEncoding != null && message.hasOwnProperty("messageEncoding"))
                    switch (message.messageEncoding) {
                    default:
                        return "messageEncoding: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.jsonFormat != null && message.hasOwnProperty("jsonFormat"))
                    switch (message.jsonFormat) {
                    default:
                        return "jsonFormat: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.enforceNamingStyle != null && message.hasOwnProperty("enforceNamingStyle"))
                    switch (message.enforceNamingStyle) {
                    default:
                        return "enforceNamingStyle: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FeatureSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FeatureSet} FeatureSet
             */
            FeatureSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FeatureSet)
                    return object;
                let message = new $root.google.protobuf.FeatureSet();
                switch (object.fieldPresence) {
                default:
                    if (typeof object.fieldPresence === "number") {
                        message.fieldPresence = object.fieldPresence;
                        break;
                    }
                    break;
                case "FIELD_PRESENCE_UNKNOWN":
                case 0:
                    message.fieldPresence = 0;
                    break;
                case "EXPLICIT":
                case 1:
                    message.fieldPresence = 1;
                    break;
                case "IMPLICIT":
                case 2:
                    message.fieldPresence = 2;
                    break;
                case "LEGACY_REQUIRED":
                case 3:
                    message.fieldPresence = 3;
                    break;
                }
                switch (object.enumType) {
                default:
                    if (typeof object.enumType === "number") {
                        message.enumType = object.enumType;
                        break;
                    }
                    break;
                case "ENUM_TYPE_UNKNOWN":
                case 0:
                    message.enumType = 0;
                    break;
                case "OPEN":
                case 1:
                    message.enumType = 1;
                    break;
                case "CLOSED":
                case 2:
                    message.enumType = 2;
                    break;
                }
                switch (object.repeatedFieldEncoding) {
                default:
                    if (typeof object.repeatedFieldEncoding === "number") {
                        message.repeatedFieldEncoding = object.repeatedFieldEncoding;
                        break;
                    }
                    break;
                case "REPEATED_FIELD_ENCODING_UNKNOWN":
                case 0:
                    message.repeatedFieldEncoding = 0;
                    break;
                case "PACKED":
                case 1:
                    message.repeatedFieldEncoding = 1;
                    break;
                case "EXPANDED":
                case 2:
                    message.repeatedFieldEncoding = 2;
                    break;
                }
                switch (object.utf8Validation) {
                default:
                    if (typeof object.utf8Validation === "number") {
                        message.utf8Validation = object.utf8Validation;
                        break;
                    }
                    break;
                case "UTF8_VALIDATION_UNKNOWN":
                case 0:
                    message.utf8Validation = 0;
                    break;
                case "VERIFY":
                case 2:
                    message.utf8Validation = 2;
                    break;
                case "NONE":
                case 3:
                    message.utf8Validation = 3;
                    break;
                }
                switch (object.messageEncoding) {
                default:
                    if (typeof object.messageEncoding === "number") {
                        message.messageEncoding = object.messageEncoding;
                        break;
                    }
                    break;
                case "MESSAGE_ENCODING_UNKNOWN":
                case 0:
                    message.messageEncoding = 0;
                    break;
                case "LENGTH_PREFIXED":
                case 1:
                    message.messageEncoding = 1;
                    break;
                case "DELIMITED":
                case 2:
                    message.messageEncoding = 2;
                    break;
                }
                switch (object.jsonFormat) {
                default:
                    if (typeof object.jsonFormat === "number") {
                        message.jsonFormat = object.jsonFormat;
                        break;
                    }
                    break;
                case "JSON_FORMAT_UNKNOWN":
                case 0:
                    message.jsonFormat = 0;
                    break;
                case "ALLOW":
                case 1:
                    message.jsonFormat = 1;
                    break;
                case "LEGACY_BEST_EFFORT":
                case 2:
                    message.jsonFormat = 2;
                    break;
                }
                switch (object.enforceNamingStyle) {
                default:
                    if (typeof object.enforceNamingStyle === "number") {
                        message.enforceNamingStyle = object.enforceNamingStyle;
                        break;
                    }
                    break;
                case "ENFORCE_NAMING_STYLE_UNKNOWN":
                case 0:
                    message.enforceNamingStyle = 0;
                    break;
                case "STYLE2024":
                case 1:
                    message.enforceNamingStyle = 1;
                    break;
                case "STYLE_LEGACY":
                case 2:
                    message.enforceNamingStyle = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FeatureSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.FeatureSet} message FeatureSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FeatureSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fieldPresence = options.enums === String ? "FIELD_PRESENCE_UNKNOWN" : 0;
                    object.enumType = options.enums === String ? "ENUM_TYPE_UNKNOWN" : 0;
                    object.repeatedFieldEncoding = options.enums === String ? "REPEATED_FIELD_ENCODING_UNKNOWN" : 0;
                    object.utf8Validation = options.enums === String ? "UTF8_VALIDATION_UNKNOWN" : 0;
                    object.messageEncoding = options.enums === String ? "MESSAGE_ENCODING_UNKNOWN" : 0;
                    object.jsonFormat = options.enums === String ? "JSON_FORMAT_UNKNOWN" : 0;
                    object.enforceNamingStyle = options.enums === String ? "ENFORCE_NAMING_STYLE_UNKNOWN" : 0;
                }
                if (message.fieldPresence != null && message.hasOwnProperty("fieldPresence"))
                    object.fieldPresence = options.enums === String ? $root.google.protobuf.FeatureSet.FieldPresence[message.fieldPresence] === undefined ? message.fieldPresence : $root.google.protobuf.FeatureSet.FieldPresence[message.fieldPresence] : message.fieldPresence;
                if (message.enumType != null && message.hasOwnProperty("enumType"))
                    object.enumType = options.enums === String ? $root.google.protobuf.FeatureSet.EnumType[message.enumType] === undefined ? message.enumType : $root.google.protobuf.FeatureSet.EnumType[message.enumType] : message.enumType;
                if (message.repeatedFieldEncoding != null && message.hasOwnProperty("repeatedFieldEncoding"))
                    object.repeatedFieldEncoding = options.enums === String ? $root.google.protobuf.FeatureSet.RepeatedFieldEncoding[message.repeatedFieldEncoding] === undefined ? message.repeatedFieldEncoding : $root.google.protobuf.FeatureSet.RepeatedFieldEncoding[message.repeatedFieldEncoding] : message.repeatedFieldEncoding;
                if (message.utf8Validation != null && message.hasOwnProperty("utf8Validation"))
                    object.utf8Validation = options.enums === String ? $root.google.protobuf.FeatureSet.Utf8Validation[message.utf8Validation] === undefined ? message.utf8Validation : $root.google.protobuf.FeatureSet.Utf8Validation[message.utf8Validation] : message.utf8Validation;
                if (message.messageEncoding != null && message.hasOwnProperty("messageEncoding"))
                    object.messageEncoding = options.enums === String ? $root.google.protobuf.FeatureSet.MessageEncoding[message.messageEncoding] === undefined ? message.messageEncoding : $root.google.protobuf.FeatureSet.MessageEncoding[message.messageEncoding] : message.messageEncoding;
                if (message.jsonFormat != null && message.hasOwnProperty("jsonFormat"))
                    object.jsonFormat = options.enums === String ? $root.google.protobuf.FeatureSet.JsonFormat[message.jsonFormat] === undefined ? message.jsonFormat : $root.google.protobuf.FeatureSet.JsonFormat[message.jsonFormat] : message.jsonFormat;
                if (message.enforceNamingStyle != null && message.hasOwnProperty("enforceNamingStyle"))
                    object.enforceNamingStyle = options.enums === String ? $root.google.protobuf.FeatureSet.EnforceNamingStyle[message.enforceNamingStyle] === undefined ? message.enforceNamingStyle : $root.google.protobuf.FeatureSet.EnforceNamingStyle[message.enforceNamingStyle] : message.enforceNamingStyle;
                return object;
            };

            /**
             * Converts this FeatureSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FeatureSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FeatureSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FeatureSet
             * @function getTypeUrl
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FeatureSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FeatureSet";
            };

            /**
             * FieldPresence enum.
             * @name google.protobuf.FeatureSet.FieldPresence
             * @enum {number}
             * @property {number} FIELD_PRESENCE_UNKNOWN=0 FIELD_PRESENCE_UNKNOWN value
             * @property {number} EXPLICIT=1 EXPLICIT value
             * @property {number} IMPLICIT=2 IMPLICIT value
             * @property {number} LEGACY_REQUIRED=3 LEGACY_REQUIRED value
             */
            FeatureSet.FieldPresence = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FIELD_PRESENCE_UNKNOWN"] = 0;
                values[valuesById[1] = "EXPLICIT"] = 1;
                values[valuesById[2] = "IMPLICIT"] = 2;
                values[valuesById[3] = "LEGACY_REQUIRED"] = 3;
                return values;
            })();

            /**
             * EnumType enum.
             * @name google.protobuf.FeatureSet.EnumType
             * @enum {number}
             * @property {number} ENUM_TYPE_UNKNOWN=0 ENUM_TYPE_UNKNOWN value
             * @property {number} OPEN=1 OPEN value
             * @property {number} CLOSED=2 CLOSED value
             */
            FeatureSet.EnumType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ENUM_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "OPEN"] = 1;
                values[valuesById[2] = "CLOSED"] = 2;
                return values;
            })();

            /**
             * RepeatedFieldEncoding enum.
             * @name google.protobuf.FeatureSet.RepeatedFieldEncoding
             * @enum {number}
             * @property {number} REPEATED_FIELD_ENCODING_UNKNOWN=0 REPEATED_FIELD_ENCODING_UNKNOWN value
             * @property {number} PACKED=1 PACKED value
             * @property {number} EXPANDED=2 EXPANDED value
             */
            FeatureSet.RepeatedFieldEncoding = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "REPEATED_FIELD_ENCODING_UNKNOWN"] = 0;
                values[valuesById[1] = "PACKED"] = 1;
                values[valuesById[2] = "EXPANDED"] = 2;
                return values;
            })();

            /**
             * Utf8Validation enum.
             * @name google.protobuf.FeatureSet.Utf8Validation
             * @enum {number}
             * @property {number} UTF8_VALIDATION_UNKNOWN=0 UTF8_VALIDATION_UNKNOWN value
             * @property {number} VERIFY=2 VERIFY value
             * @property {number} NONE=3 NONE value
             */
            FeatureSet.Utf8Validation = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UTF8_VALIDATION_UNKNOWN"] = 0;
                values[valuesById[2] = "VERIFY"] = 2;
                values[valuesById[3] = "NONE"] = 3;
                return values;
            })();

            /**
             * MessageEncoding enum.
             * @name google.protobuf.FeatureSet.MessageEncoding
             * @enum {number}
             * @property {number} MESSAGE_ENCODING_UNKNOWN=0 MESSAGE_ENCODING_UNKNOWN value
             * @property {number} LENGTH_PREFIXED=1 LENGTH_PREFIXED value
             * @property {number} DELIMITED=2 DELIMITED value
             */
            FeatureSet.MessageEncoding = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MESSAGE_ENCODING_UNKNOWN"] = 0;
                values[valuesById[1] = "LENGTH_PREFIXED"] = 1;
                values[valuesById[2] = "DELIMITED"] = 2;
                return values;
            })();

            /**
             * JsonFormat enum.
             * @name google.protobuf.FeatureSet.JsonFormat
             * @enum {number}
             * @property {number} JSON_FORMAT_UNKNOWN=0 JSON_FORMAT_UNKNOWN value
             * @property {number} ALLOW=1 ALLOW value
             * @property {number} LEGACY_BEST_EFFORT=2 LEGACY_BEST_EFFORT value
             */
            FeatureSet.JsonFormat = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JSON_FORMAT_UNKNOWN"] = 0;
                values[valuesById[1] = "ALLOW"] = 1;
                values[valuesById[2] = "LEGACY_BEST_EFFORT"] = 2;
                return values;
            })();

            /**
             * EnforceNamingStyle enum.
             * @name google.protobuf.FeatureSet.EnforceNamingStyle
             * @enum {number}
             * @property {number} ENFORCE_NAMING_STYLE_UNKNOWN=0 ENFORCE_NAMING_STYLE_UNKNOWN value
             * @property {number} STYLE2024=1 STYLE2024 value
             * @property {number} STYLE_LEGACY=2 STYLE_LEGACY value
             */
            FeatureSet.EnforceNamingStyle = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ENFORCE_NAMING_STYLE_UNKNOWN"] = 0;
                values[valuesById[1] = "STYLE2024"] = 1;
                values[valuesById[2] = "STYLE_LEGACY"] = 2;
                return values;
            })();

            return FeatureSet;
        })();

        protobuf.FeatureSetDefaults = (function() {

            /**
             * Properties of a FeatureSetDefaults.
             * @memberof google.protobuf
             * @interface IFeatureSetDefaults
             * @property {Array.<google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault>|null} [defaults] FeatureSetDefaults defaults
             * @property {google.protobuf.Edition|null} [minimumEdition] FeatureSetDefaults minimumEdition
             * @property {google.protobuf.Edition|null} [maximumEdition] FeatureSetDefaults maximumEdition
             */

            /**
             * Constructs a new FeatureSetDefaults.
             * @memberof google.protobuf
             * @classdesc Represents a FeatureSetDefaults.
             * @implements IFeatureSetDefaults
             * @constructor
             * @param {google.protobuf.IFeatureSetDefaults=} [properties] Properties to set
             */
            function FeatureSetDefaults(properties) {
                this.defaults = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FeatureSetDefaults defaults.
             * @member {Array.<google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault>} defaults
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             */
            FeatureSetDefaults.prototype.defaults = $util.emptyArray;

            /**
             * FeatureSetDefaults minimumEdition.
             * @member {google.protobuf.Edition} minimumEdition
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             */
            FeatureSetDefaults.prototype.minimumEdition = 0;

            /**
             * FeatureSetDefaults maximumEdition.
             * @member {google.protobuf.Edition} maximumEdition
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             */
            FeatureSetDefaults.prototype.maximumEdition = 0;

            /**
             * Creates a new FeatureSetDefaults instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.IFeatureSetDefaults=} [properties] Properties to set
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults instance
             */
            FeatureSetDefaults.create = function create(properties) {
                return new FeatureSetDefaults(properties);
            };

            /**
             * Encodes the specified FeatureSetDefaults message. Does not implicitly {@link google.protobuf.FeatureSetDefaults.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.IFeatureSetDefaults} message FeatureSetDefaults message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSetDefaults.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.defaults != null && message.defaults.length)
                    for (let i = 0; i < message.defaults.length; ++i)
                        $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.encode(message.defaults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.minimumEdition != null && Object.hasOwnProperty.call(message, "minimumEdition"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minimumEdition);
                if (message.maximumEdition != null && Object.hasOwnProperty.call(message, "maximumEdition"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maximumEdition);
                return writer;
            };

            /**
             * Encodes the specified FeatureSetDefaults message, length delimited. Does not implicitly {@link google.protobuf.FeatureSetDefaults.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.IFeatureSetDefaults} message FeatureSetDefaults message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSetDefaults.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FeatureSetDefaults message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSetDefaults.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FeatureSetDefaults();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.defaults && message.defaults.length))
                                message.defaults = [];
                            message.defaults.push($root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.minimumEdition = reader.int32();
                            break;
                        }
                    case 5: {
                            message.maximumEdition = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FeatureSetDefaults message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSetDefaults.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FeatureSetDefaults message.
             * @function verify
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FeatureSetDefaults.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.defaults != null && message.hasOwnProperty("defaults")) {
                    if (!Array.isArray(message.defaults))
                        return "defaults: array expected";
                    for (let i = 0; i < message.defaults.length; ++i) {
                        let error = $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.verify(message.defaults[i]);
                        if (error)
                            return "defaults." + error;
                    }
                }
                if (message.minimumEdition != null && message.hasOwnProperty("minimumEdition"))
                    switch (message.minimumEdition) {
                    default:
                        return "minimumEdition: enum value expected";
                    case 0:
                    case 900:
                    case 998:
                    case 999:
                    case 1000:
                    case 1001:
                    case 1:
                    case 2:
                    case 99997:
                    case 99998:
                    case 99999:
                    case 2147483647:
                        break;
                    }
                if (message.maximumEdition != null && message.hasOwnProperty("maximumEdition"))
                    switch (message.maximumEdition) {
                    default:
                        return "maximumEdition: enum value expected";
                    case 0:
                    case 900:
                    case 998:
                    case 999:
                    case 1000:
                    case 1001:
                    case 1:
                    case 2:
                    case 99997:
                    case 99998:
                    case 99999:
                    case 2147483647:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FeatureSetDefaults message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults
             */
            FeatureSetDefaults.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FeatureSetDefaults)
                    return object;
                let message = new $root.google.protobuf.FeatureSetDefaults();
                if (object.defaults) {
                    if (!Array.isArray(object.defaults))
                        throw TypeError(".google.protobuf.FeatureSetDefaults.defaults: array expected");
                    message.defaults = [];
                    for (let i = 0; i < object.defaults.length; ++i) {
                        if (typeof object.defaults[i] !== "object")
                            throw TypeError(".google.protobuf.FeatureSetDefaults.defaults: object expected");
                        message.defaults[i] = $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.fromObject(object.defaults[i]);
                    }
                }
                switch (object.minimumEdition) {
                default:
                    if (typeof object.minimumEdition === "number") {
                        message.minimumEdition = object.minimumEdition;
                        break;
                    }
                    break;
                case "EDITION_UNKNOWN":
                case 0:
                    message.minimumEdition = 0;
                    break;
                case "EDITION_LEGACY":
                case 900:
                    message.minimumEdition = 900;
                    break;
                case "EDITION_PROTO2":
                case 998:
                    message.minimumEdition = 998;
                    break;
                case "EDITION_PROTO3":
                case 999:
                    message.minimumEdition = 999;
                    break;
                case "EDITION_2023":
                case 1000:
                    message.minimumEdition = 1000;
                    break;
                case "EDITION_2024":
                case 1001:
                    message.minimumEdition = 1001;
                    break;
                case "EDITION_1_TEST_ONLY":
                case 1:
                    message.minimumEdition = 1;
                    break;
                case "EDITION_2_TEST_ONLY":
                case 2:
                    message.minimumEdition = 2;
                    break;
                case "EDITION_99997_TEST_ONLY":
                case 99997:
                    message.minimumEdition = 99997;
                    break;
                case "EDITION_99998_TEST_ONLY":
                case 99998:
                    message.minimumEdition = 99998;
                    break;
                case "EDITION_99999_TEST_ONLY":
                case 99999:
                    message.minimumEdition = 99999;
                    break;
                case "EDITION_MAX":
                case 2147483647:
                    message.minimumEdition = 2147483647;
                    break;
                }
                switch (object.maximumEdition) {
                default:
                    if (typeof object.maximumEdition === "number") {
                        message.maximumEdition = object.maximumEdition;
                        break;
                    }
                    break;
                case "EDITION_UNKNOWN":
                case 0:
                    message.maximumEdition = 0;
                    break;
                case "EDITION_LEGACY":
                case 900:
                    message.maximumEdition = 900;
                    break;
                case "EDITION_PROTO2":
                case 998:
                    message.maximumEdition = 998;
                    break;
                case "EDITION_PROTO3":
                case 999:
                    message.maximumEdition = 999;
                    break;
                case "EDITION_2023":
                case 1000:
                    message.maximumEdition = 1000;
                    break;
                case "EDITION_2024":
                case 1001:
                    message.maximumEdition = 1001;
                    break;
                case "EDITION_1_TEST_ONLY":
                case 1:
                    message.maximumEdition = 1;
                    break;
                case "EDITION_2_TEST_ONLY":
                case 2:
                    message.maximumEdition = 2;
                    break;
                case "EDITION_99997_TEST_ONLY":
                case 99997:
                    message.maximumEdition = 99997;
                    break;
                case "EDITION_99998_TEST_ONLY":
                case 99998:
                    message.maximumEdition = 99998;
                    break;
                case "EDITION_99999_TEST_ONLY":
                case 99999:
                    message.maximumEdition = 99999;
                    break;
                case "EDITION_MAX":
                case 2147483647:
                    message.maximumEdition = 2147483647;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FeatureSetDefaults message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.FeatureSetDefaults} message FeatureSetDefaults
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FeatureSetDefaults.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.defaults = [];
                if (options.defaults) {
                    object.minimumEdition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                    object.maximumEdition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                }
                if (message.defaults && message.defaults.length) {
                    object.defaults = [];
                    for (let j = 0; j < message.defaults.length; ++j)
                        object.defaults[j] = $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.toObject(message.defaults[j], options);
                }
                if (message.minimumEdition != null && message.hasOwnProperty("minimumEdition"))
                    object.minimumEdition = options.enums === String ? $root.google.protobuf.Edition[message.minimumEdition] === undefined ? message.minimumEdition : $root.google.protobuf.Edition[message.minimumEdition] : message.minimumEdition;
                if (message.maximumEdition != null && message.hasOwnProperty("maximumEdition"))
                    object.maximumEdition = options.enums === String ? $root.google.protobuf.Edition[message.maximumEdition] === undefined ? message.maximumEdition : $root.google.protobuf.Edition[message.maximumEdition] : message.maximumEdition;
                return object;
            };

            /**
             * Converts this FeatureSetDefaults to JSON.
             * @function toJSON
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FeatureSetDefaults.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FeatureSetDefaults
             * @function getTypeUrl
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FeatureSetDefaults.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FeatureSetDefaults";
            };

            FeatureSetDefaults.FeatureSetEditionDefault = (function() {

                /**
                 * Properties of a FeatureSetEditionDefault.
                 * @memberof google.protobuf.FeatureSetDefaults
                 * @interface IFeatureSetEditionDefault
                 * @property {google.protobuf.Edition|null} [edition] FeatureSetEditionDefault edition
                 * @property {google.protobuf.IFeatureSet|null} [overridableFeatures] FeatureSetEditionDefault overridableFeatures
                 * @property {google.protobuf.IFeatureSet|null} [fixedFeatures] FeatureSetEditionDefault fixedFeatures
                 */

                /**
                 * Constructs a new FeatureSetEditionDefault.
                 * @memberof google.protobuf.FeatureSetDefaults
                 * @classdesc Represents a FeatureSetEditionDefault.
                 * @implements IFeatureSetEditionDefault
                 * @constructor
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault=} [properties] Properties to set
                 */
                function FeatureSetEditionDefault(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FeatureSetEditionDefault edition.
                 * @member {google.protobuf.Edition} edition
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 */
                FeatureSetEditionDefault.prototype.edition = 0;

                /**
                 * FeatureSetEditionDefault overridableFeatures.
                 * @member {google.protobuf.IFeatureSet|null|undefined} overridableFeatures
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 */
                FeatureSetEditionDefault.prototype.overridableFeatures = null;

                /**
                 * FeatureSetEditionDefault fixedFeatures.
                 * @member {google.protobuf.IFeatureSet|null|undefined} fixedFeatures
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 */
                FeatureSetEditionDefault.prototype.fixedFeatures = null;

                /**
                 * Creates a new FeatureSetEditionDefault instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault=} [properties] Properties to set
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault instance
                 */
                FeatureSetEditionDefault.create = function create(properties) {
                    return new FeatureSetEditionDefault(properties);
                };

                /**
                 * Encodes the specified FeatureSetEditionDefault message. Does not implicitly {@link google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault} message FeatureSetEditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSetEditionDefault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.edition != null && Object.hasOwnProperty.call(message, "edition"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.edition);
                    if (message.overridableFeatures != null && Object.hasOwnProperty.call(message, "overridableFeatures"))
                        $root.google.protobuf.FeatureSet.encode(message.overridableFeatures, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.fixedFeatures != null && Object.hasOwnProperty.call(message, "fixedFeatures"))
                        $root.google.protobuf.FeatureSet.encode(message.fixedFeatures, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified FeatureSetEditionDefault message, length delimited. Does not implicitly {@link google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault} message FeatureSetEditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSetEditionDefault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FeatureSetEditionDefault message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSetEditionDefault.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3: {
                                message.edition = reader.int32();
                                break;
                            }
                        case 4: {
                                message.overridableFeatures = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.fixedFeatures = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FeatureSetEditionDefault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSetEditionDefault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FeatureSetEditionDefault message.
                 * @function verify
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureSetEditionDefault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        switch (message.edition) {
                        default:
                            return "edition: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.overridableFeatures != null && message.hasOwnProperty("overridableFeatures")) {
                        let error = $root.google.protobuf.FeatureSet.verify(message.overridableFeatures);
                        if (error)
                            return "overridableFeatures." + error;
                    }
                    if (message.fixedFeatures != null && message.hasOwnProperty("fixedFeatures")) {
                        let error = $root.google.protobuf.FeatureSet.verify(message.fixedFeatures);
                        if (error)
                            return "fixedFeatures." + error;
                    }
                    return null;
                };

                /**
                 * Creates a FeatureSetEditionDefault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault
                 */
                FeatureSetEditionDefault.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault)
                        return object;
                    let message = new $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault();
                    switch (object.edition) {
                    default:
                        if (typeof object.edition === "number") {
                            message.edition = object.edition;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.edition = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.edition = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.edition = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.edition = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.edition = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.edition = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.edition = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.edition = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.edition = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.edition = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.edition = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.edition = 2147483647;
                        break;
                    }
                    if (object.overridableFeatures != null) {
                        if (typeof object.overridableFeatures !== "object")
                            throw TypeError(".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.overridableFeatures: object expected");
                        message.overridableFeatures = $root.google.protobuf.FeatureSet.fromObject(object.overridableFeatures);
                    }
                    if (object.fixedFeatures != null) {
                        if (typeof object.fixedFeatures !== "object")
                            throw TypeError(".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.fixedFeatures: object expected");
                        message.fixedFeatures = $root.google.protobuf.FeatureSet.fromObject(object.fixedFeatures);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FeatureSetEditionDefault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} message FeatureSetEditionDefault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureSetEditionDefault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.edition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                        object.overridableFeatures = null;
                        object.fixedFeatures = null;
                    }
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        object.edition = options.enums === String ? $root.google.protobuf.Edition[message.edition] === undefined ? message.edition : $root.google.protobuf.Edition[message.edition] : message.edition;
                    if (message.overridableFeatures != null && message.hasOwnProperty("overridableFeatures"))
                        object.overridableFeatures = $root.google.protobuf.FeatureSet.toObject(message.overridableFeatures, options);
                    if (message.fixedFeatures != null && message.hasOwnProperty("fixedFeatures"))
                        object.fixedFeatures = $root.google.protobuf.FeatureSet.toObject(message.fixedFeatures, options);
                    return object;
                };

                /**
                 * Converts this FeatureSetEditionDefault to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureSetEditionDefault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FeatureSetEditionDefault
                 * @function getTypeUrl
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FeatureSetEditionDefault.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
                };

                return FeatureSetEditionDefault;
            })();

            return FeatureSetDefaults;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SourceCodeInfo
             * @function getTypeUrl
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SourceCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.SourceCodeInfo";
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            }
                        case 2: {
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            }
                        case 3: {
                                message.leadingComments = reader.string();
                                break;
                            }
                        case 4: {
                                message.trailingComments = reader.string();
                                break;
                            }
                        case 6: {
                                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                    message.leadingDetachedComments = [];
                                message.leadingDetachedComments.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (let i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (let j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Location
                 * @function getTypeUrl
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Location.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.SourceCodeInfo.Location";
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GeneratedCodeInfo
             * @function getTypeUrl
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GeneratedCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo";
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 * @property {google.protobuf.GeneratedCodeInfo.Annotation.Semantic|null} [semantic] Annotation semantic
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Annotation semantic.
                 * @member {google.protobuf.GeneratedCodeInfo.Annotation.Semantic} semantic
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.semantic = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    if (message.semantic != null && Object.hasOwnProperty.call(message, "semantic"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.semantic);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            }
                        case 2: {
                                message.sourceFile = reader.string();
                                break;
                            }
                        case 3: {
                                message.begin = reader.int32();
                                break;
                            }
                        case 4: {
                                message.end = reader.int32();
                                break;
                            }
                        case 5: {
                                message.semantic = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    if (message.semantic != null && message.hasOwnProperty("semantic"))
                        switch (message.semantic) {
                        default:
                            return "semantic: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    switch (object.semantic) {
                    default:
                        if (typeof object.semantic === "number") {
                            message.semantic = object.semantic;
                            break;
                        }
                        break;
                    case "NONE":
                    case 0:
                        message.semantic = 0;
                        break;
                    case "SET":
                    case 1:
                        message.semantic = 1;
                        break;
                    case "ALIAS":
                    case 2:
                        message.semantic = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                        object.semantic = options.enums === String ? "NONE" : 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    if (message.semantic != null && message.hasOwnProperty("semantic"))
                        object.semantic = options.enums === String ? $root.google.protobuf.GeneratedCodeInfo.Annotation.Semantic[message.semantic] === undefined ? message.semantic : $root.google.protobuf.GeneratedCodeInfo.Annotation.Semantic[message.semantic] : message.semantic;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Annotation
                 * @function getTypeUrl
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Annotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo.Annotation";
                };

                /**
                 * Semantic enum.
                 * @name google.protobuf.GeneratedCodeInfo.Annotation.Semantic
                 * @enum {number}
                 * @property {number} NONE=0 NONE value
                 * @property {number} SET=1 SET value
                 * @property {number} ALIAS=2 ALIAS value
                 */
                Annotation.Semantic = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NONE"] = 0;
                    values[valuesById[1] = "SET"] = 1;
                    values[valuesById[2] = "ALIAS"] = 2;
                    return values;
                })();

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Creates a new Duration instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seconds = reader.int64();
                            break;
                        }
                    case 2: {
                            message.nanos = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                let message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Duration
             * @function getTypeUrl
             * @memberof google.protobuf.Duration
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Duration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Duration";
            };

            return Duration;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type_url = reader.string();
                            break;
                        }
                    case 2: {
                            message.value = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                let message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Any
             * @function getTypeUrl
             * @memberof google.protobuf.Any
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Any.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Any";
            };

            return Any;
        })();

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Empty
             * @function getTypeUrl
             * @memberof google.protobuf.Empty
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Empty";
            };

            return Empty;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seconds = reader.int64();
                            break;
                        }
                    case 2: {
                            message.nanos = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                let message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Timestamp
             * @function getTypeUrl
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Timestamp";
            };

            return Timestamp;
        })();

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             */
            function DoubleValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Creates a new DoubleValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             * @returns {google.protobuf.DoubleValue} DoubleValue instance
             */
            DoubleValue.create = function create(properties) {
                return new DoubleValue(properties);
            };

            /**
             * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} message DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified DoubleValue message, length delimited. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} message DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DoubleValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DoubleValue message.
             * @function verify
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoubleValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a DoubleValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DoubleValue} DoubleValue
             */
            DoubleValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DoubleValue)
                    return object;
                let message = new $root.google.protobuf.DoubleValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a DoubleValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.DoubleValue} message DoubleValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoubleValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this DoubleValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.DoubleValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoubleValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DoubleValue
             * @function getTypeUrl
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DoubleValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.DoubleValue";
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             */
            function FloatValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Creates a new FloatValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             * @returns {google.protobuf.FloatValue} FloatValue instance
             */
            FloatValue.create = function create(properties) {
                return new FloatValue(properties);
            };

            /**
             * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} message FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                return writer;
            };

            /**
             * Encodes the specified FloatValue message, length delimited. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} message FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FloatValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FloatValue message.
             * @function verify
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FloatValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a FloatValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FloatValue} FloatValue
             */
            FloatValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FloatValue)
                    return object;
                let message = new $root.google.protobuf.FloatValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a FloatValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.FloatValue} message FloatValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FloatValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this FloatValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.FloatValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FloatValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FloatValue
             * @function getTypeUrl
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FloatValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FloatValue";
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {number|Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             */
            function Int64Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Int64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.Int64Value} Int64Value instance
             */
            Int64Value.create = function create(properties) {
                return new Int64Value(properties);
            };

            /**
             * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} message Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
                return writer;
            };

            /**
             * Encodes the specified Int64Value message, length delimited. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} message Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int64Value();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Int64Value message.
             * @function verify
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates an Int64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int64Value} Int64Value
             */
            Int64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int64Value)
                    return object;
                let message = new $root.google.protobuf.Int64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an Int64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.Int64Value} message Int64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this Int64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Int64Value
             * @function getTypeUrl
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Int64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Int64Value";
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {number|Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             */
            function UInt64Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new UInt64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt64Value} UInt64Value instance
             */
            UInt64Value.create = function create(properties) {
                return new UInt64Value(properties);
            };

            /**
             * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} message UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                return writer;
            };

            /**
             * Encodes the specified UInt64Value message, length delimited. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} message UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt64Value();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UInt64Value message.
             * @function verify
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a UInt64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt64Value} UInt64Value
             */
            UInt64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt64Value)
                    return object;
                let message = new $root.google.protobuf.UInt64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a UInt64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.UInt64Value} message UInt64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                return object;
            };

            /**
             * Converts this UInt64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UInt64Value
             * @function getTypeUrl
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UInt64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UInt64Value";
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             */
            function Int32Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Creates a new Int32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.Int32Value} Int32Value instance
             */
            Int32Value.create = function create(properties) {
                return new Int32Value(properties);
            };

            /**
             * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} message Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                return writer;
            };

            /**
             * Encodes the specified Int32Value message, length delimited. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} message Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Int32Value();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Int32Value message.
             * @function verify
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates an Int32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int32Value} Int32Value
             */
            Int32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int32Value)
                    return object;
                let message = new $root.google.protobuf.Int32Value();
                if (object.value != null)
                    message.value = object.value | 0;
                return message;
            };

            /**
             * Creates a plain object from an Int32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.Int32Value} message Int32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Int32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Int32Value
             * @function getTypeUrl
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Int32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Int32Value";
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             */
            function UInt32Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Creates a new UInt32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt32Value} UInt32Value instance
             */
            UInt32Value.create = function create(properties) {
                return new UInt32Value(properties);
            };

            /**
             * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} message UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified UInt32Value message, length delimited. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} message UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UInt32Value();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UInt32Value message.
             * @function verify
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a UInt32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt32Value} UInt32Value
             */
            UInt32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt32Value)
                    return object;
                let message = new $root.google.protobuf.UInt32Value();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a UInt32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.UInt32Value} message UInt32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this UInt32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UInt32Value
             * @function getTypeUrl
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UInt32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UInt32Value";
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             */
            function BoolValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Creates a new BoolValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             * @returns {google.protobuf.BoolValue} BoolValue instance
             */
            BoolValue.create = function create(properties) {
                return new BoolValue(properties);
            };

            /**
             * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} message BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified BoolValue message, length delimited. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} message BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BoolValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoolValue message.
             * @function verify
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoolValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a BoolValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BoolValue} BoolValue
             */
            BoolValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BoolValue)
                    return object;
                let message = new $root.google.protobuf.BoolValue();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a BoolValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.BoolValue} message BoolValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoolValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this BoolValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BoolValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoolValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BoolValue
             * @function getTypeUrl
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoolValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.BoolValue";
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             */
            function StringValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Creates a new StringValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             * @returns {google.protobuf.StringValue} StringValue instance
             */
            StringValue.create = function create(properties) {
                return new StringValue(properties);
            };

            /**
             * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified StringValue message, length delimited. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.StringValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StringValue message.
             * @function verify
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a StringValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.StringValue} StringValue
             */
            StringValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.StringValue)
                    return object;
                let message = new $root.google.protobuf.StringValue();
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a StringValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.StringValue} message StringValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = "";
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this StringValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.StringValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StringValue
             * @function getTypeUrl
             * @memberof google.protobuf.StringValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StringValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.StringValue";
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             */
            function BytesValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new BytesValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             * @returns {google.protobuf.BytesValue} BytesValue instance
             */
            BytesValue.create = function create(properties) {
                return new BytesValue(properties);
            };

            /**
             * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} message BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified BytesValue message, length delimited. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} message BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.BytesValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BytesValue message.
             * @function verify
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BytesValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a BytesValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BytesValue} BytesValue
             */
            BytesValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BytesValue)
                    return object;
                let message = new $root.google.protobuf.BytesValue();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a BytesValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.BytesValue} message BytesValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BytesValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this BytesValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BytesValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BytesValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BytesValue
             * @function getTypeUrl
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BytesValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.BytesValue";
            };

            return BytesValue;
        })();

        return protobuf;
    })();

    google.longrunning = (function() {

        /**
         * Namespace longrunning.
         * @memberof google
         * @namespace
         */
        const longrunning = {};

        longrunning.Operations = (function() {

            /**
             * Constructs a new Operations service.
             * @memberof google.longrunning
             * @classdesc Represents an Operations
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Operations(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Operations.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Operations;

            /**
             * Creates new Operations service using the specified rpc implementation.
             * @function create
             * @memberof google.longrunning.Operations
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Operations} RPC service. Useful where requests and/or responses are streamed.
             */
            Operations.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link google.longrunning.Operations#listOperations}.
             * @memberof google.longrunning.Operations
             * @typedef ListOperationsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.longrunning.ListOperationsResponse} [response] ListOperationsResponse
             */

            /**
             * Calls ListOperations.
             * @function listOperations
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IListOperationsRequest} request ListOperationsRequest message or plain object
             * @param {google.longrunning.Operations.ListOperationsCallback} callback Node-style callback called with the error, if any, and ListOperationsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Operations.prototype.listOperations = function listOperations(request, callback) {
                return this.rpcCall(listOperations, $root.google.longrunning.ListOperationsRequest, $root.google.longrunning.ListOperationsResponse, request, callback);
            }, "name", { value: "ListOperations" });

            /**
             * Calls ListOperations.
             * @function listOperations
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IListOperationsRequest} request ListOperationsRequest message or plain object
             * @returns {Promise<google.longrunning.ListOperationsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link google.longrunning.Operations#getOperation}.
             * @memberof google.longrunning.Operations
             * @typedef GetOperationCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.longrunning.Operation} [response] Operation
             */

            /**
             * Calls GetOperation.
             * @function getOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IGetOperationRequest} request GetOperationRequest message or plain object
             * @param {google.longrunning.Operations.GetOperationCallback} callback Node-style callback called with the error, if any, and Operation
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Operations.prototype.getOperation = function getOperation(request, callback) {
                return this.rpcCall(getOperation, $root.google.longrunning.GetOperationRequest, $root.google.longrunning.Operation, request, callback);
            }, "name", { value: "GetOperation" });

            /**
             * Calls GetOperation.
             * @function getOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IGetOperationRequest} request GetOperationRequest message or plain object
             * @returns {Promise<google.longrunning.Operation>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link google.longrunning.Operations#deleteOperation}.
             * @memberof google.longrunning.Operations
             * @typedef DeleteOperationCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls DeleteOperation.
             * @function deleteOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IDeleteOperationRequest} request DeleteOperationRequest message or plain object
             * @param {google.longrunning.Operations.DeleteOperationCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Operations.prototype.deleteOperation = function deleteOperation(request, callback) {
                return this.rpcCall(deleteOperation, $root.google.longrunning.DeleteOperationRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "DeleteOperation" });

            /**
             * Calls DeleteOperation.
             * @function deleteOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IDeleteOperationRequest} request DeleteOperationRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link google.longrunning.Operations#cancelOperation}.
             * @memberof google.longrunning.Operations
             * @typedef CancelOperationCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CancelOperation.
             * @function cancelOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.ICancelOperationRequest} request CancelOperationRequest message or plain object
             * @param {google.longrunning.Operations.CancelOperationCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Operations.prototype.cancelOperation = function cancelOperation(request, callback) {
                return this.rpcCall(cancelOperation, $root.google.longrunning.CancelOperationRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CancelOperation" });

            /**
             * Calls CancelOperation.
             * @function cancelOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.ICancelOperationRequest} request CancelOperationRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link google.longrunning.Operations#waitOperation}.
             * @memberof google.longrunning.Operations
             * @typedef WaitOperationCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.longrunning.Operation} [response] Operation
             */

            /**
             * Calls WaitOperation.
             * @function waitOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IWaitOperationRequest} request WaitOperationRequest message or plain object
             * @param {google.longrunning.Operations.WaitOperationCallback} callback Node-style callback called with the error, if any, and Operation
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Operations.prototype.waitOperation = function waitOperation(request, callback) {
                return this.rpcCall(waitOperation, $root.google.longrunning.WaitOperationRequest, $root.google.longrunning.Operation, request, callback);
            }, "name", { value: "WaitOperation" });

            /**
             * Calls WaitOperation.
             * @function waitOperation
             * @memberof google.longrunning.Operations
             * @instance
             * @param {google.longrunning.IWaitOperationRequest} request WaitOperationRequest message or plain object
             * @returns {Promise<google.longrunning.Operation>} Promise
             * @variation 2
             */

            return Operations;
        })();

        longrunning.Operation = (function() {

            /**
             * Properties of an Operation.
             * @memberof google.longrunning
             * @interface IOperation
             * @property {string|null} [name] Operation name
             * @property {google.protobuf.IAny|null} [metadata] Operation metadata
             * @property {boolean|null} [done] Operation done
             * @property {google.rpc.IStatus|null} [error] Operation error
             * @property {google.protobuf.IAny|null} [response] Operation response
             */

            /**
             * Constructs a new Operation.
             * @memberof google.longrunning
             * @classdesc Represents an Operation.
             * @implements IOperation
             * @constructor
             * @param {google.longrunning.IOperation=} [properties] Properties to set
             */
            function Operation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Operation name.
             * @member {string} name
             * @memberof google.longrunning.Operation
             * @instance
             */
            Operation.prototype.name = "";

            /**
             * Operation metadata.
             * @member {google.protobuf.IAny|null|undefined} metadata
             * @memberof google.longrunning.Operation
             * @instance
             */
            Operation.prototype.metadata = null;

            /**
             * Operation done.
             * @member {boolean} done
             * @memberof google.longrunning.Operation
             * @instance
             */
            Operation.prototype.done = false;

            /**
             * Operation error.
             * @member {google.rpc.IStatus|null|undefined} error
             * @memberof google.longrunning.Operation
             * @instance
             */
            Operation.prototype.error = null;

            /**
             * Operation response.
             * @member {google.protobuf.IAny|null|undefined} response
             * @memberof google.longrunning.Operation
             * @instance
             */
            Operation.prototype.response = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Operation result.
             * @member {"error"|"response"|undefined} result
             * @memberof google.longrunning.Operation
             * @instance
             */
            Object.defineProperty(Operation.prototype, "result", {
                get: $util.oneOfGetter($oneOfFields = ["error", "response"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Operation instance using the specified properties.
             * @function create
             * @memberof google.longrunning.Operation
             * @static
             * @param {google.longrunning.IOperation=} [properties] Properties to set
             * @returns {google.longrunning.Operation} Operation instance
             */
            Operation.create = function create(properties) {
                return new Operation(properties);
            };

            /**
             * Encodes the specified Operation message. Does not implicitly {@link google.longrunning.Operation.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.Operation
             * @static
             * @param {google.longrunning.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.google.protobuf.Any.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.done != null && Object.hasOwnProperty.call(message, "done"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.done);
                if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                    $root.google.rpc.Status.encode(message.error, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                    $root.google.protobuf.Any.encode(message.response, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Operation message, length delimited. Does not implicitly {@link google.longrunning.Operation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.Operation
             * @static
             * @param {google.longrunning.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Operation message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.Operation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.metadata = $root.google.protobuf.Any.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.done = reader.bool();
                            break;
                        }
                    case 4: {
                            message.error = $root.google.rpc.Status.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.response = $root.google.protobuf.Any.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Operation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Operation message.
             * @function verify
             * @memberof google.longrunning.Operation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Operation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.google.protobuf.Any.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.done != null && message.hasOwnProperty("done"))
                    if (typeof message.done !== "boolean")
                        return "done: boolean expected";
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.result = 1;
                    {
                        let error = $root.google.rpc.Status.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.response != null && message.hasOwnProperty("response")) {
                    if (properties.result === 1)
                        return "result: multiple values";
                    properties.result = 1;
                    {
                        let error = $root.google.protobuf.Any.verify(message.response);
                        if (error)
                            return "response." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Operation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.Operation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.Operation} Operation
             */
            Operation.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.Operation)
                    return object;
                let message = new $root.google.longrunning.Operation();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".google.longrunning.Operation.metadata: object expected");
                    message.metadata = $root.google.protobuf.Any.fromObject(object.metadata);
                }
                if (object.done != null)
                    message.done = Boolean(object.done);
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".google.longrunning.Operation.error: object expected");
                    message.error = $root.google.rpc.Status.fromObject(object.error);
                }
                if (object.response != null) {
                    if (typeof object.response !== "object")
                        throw TypeError(".google.longrunning.Operation.response: object expected");
                    message.response = $root.google.protobuf.Any.fromObject(object.response);
                }
                return message;
            };

            /**
             * Creates a plain object from an Operation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.Operation
             * @static
             * @param {google.longrunning.Operation} message Operation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Operation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.metadata = null;
                    object.done = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.google.protobuf.Any.toObject(message.metadata, options);
                if (message.done != null && message.hasOwnProperty("done"))
                    object.done = message.done;
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.google.rpc.Status.toObject(message.error, options);
                    if (options.oneofs)
                        object.result = "error";
                }
                if (message.response != null && message.hasOwnProperty("response")) {
                    object.response = $root.google.protobuf.Any.toObject(message.response, options);
                    if (options.oneofs)
                        object.result = "response";
                }
                return object;
            };

            /**
             * Converts this Operation to JSON.
             * @function toJSON
             * @memberof google.longrunning.Operation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Operation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Operation
             * @function getTypeUrl
             * @memberof google.longrunning.Operation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Operation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.Operation";
            };

            return Operation;
        })();

        longrunning.GetOperationRequest = (function() {

            /**
             * Properties of a GetOperationRequest.
             * @memberof google.longrunning
             * @interface IGetOperationRequest
             * @property {string|null} [name] GetOperationRequest name
             */

            /**
             * Constructs a new GetOperationRequest.
             * @memberof google.longrunning
             * @classdesc Represents a GetOperationRequest.
             * @implements IGetOperationRequest
             * @constructor
             * @param {google.longrunning.IGetOperationRequest=} [properties] Properties to set
             */
            function GetOperationRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetOperationRequest name.
             * @member {string} name
             * @memberof google.longrunning.GetOperationRequest
             * @instance
             */
            GetOperationRequest.prototype.name = "";

            /**
             * Creates a new GetOperationRequest instance using the specified properties.
             * @function create
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {google.longrunning.IGetOperationRequest=} [properties] Properties to set
             * @returns {google.longrunning.GetOperationRequest} GetOperationRequest instance
             */
            GetOperationRequest.create = function create(properties) {
                return new GetOperationRequest(properties);
            };

            /**
             * Encodes the specified GetOperationRequest message. Does not implicitly {@link google.longrunning.GetOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {google.longrunning.IGetOperationRequest} message GetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified GetOperationRequest message, length delimited. Does not implicitly {@link google.longrunning.GetOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {google.longrunning.IGetOperationRequest} message GetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.GetOperationRequest} GetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.GetOperationRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.GetOperationRequest} GetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetOperationRequest message.
             * @function verify
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a GetOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.GetOperationRequest} GetOperationRequest
             */
            GetOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.GetOperationRequest)
                    return object;
                let message = new $root.google.longrunning.GetOperationRequest();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a GetOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {google.longrunning.GetOperationRequest} message GetOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this GetOperationRequest to JSON.
             * @function toJSON
             * @memberof google.longrunning.GetOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetOperationRequest
             * @function getTypeUrl
             * @memberof google.longrunning.GetOperationRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetOperationRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.GetOperationRequest";
            };

            return GetOperationRequest;
        })();

        longrunning.ListOperationsRequest = (function() {

            /**
             * Properties of a ListOperationsRequest.
             * @memberof google.longrunning
             * @interface IListOperationsRequest
             * @property {string|null} [name] ListOperationsRequest name
             * @property {string|null} [filter] ListOperationsRequest filter
             * @property {number|null} [pageSize] ListOperationsRequest pageSize
             * @property {string|null} [pageToken] ListOperationsRequest pageToken
             */

            /**
             * Constructs a new ListOperationsRequest.
             * @memberof google.longrunning
             * @classdesc Represents a ListOperationsRequest.
             * @implements IListOperationsRequest
             * @constructor
             * @param {google.longrunning.IListOperationsRequest=} [properties] Properties to set
             */
            function ListOperationsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListOperationsRequest name.
             * @member {string} name
             * @memberof google.longrunning.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.name = "";

            /**
             * ListOperationsRequest filter.
             * @member {string} filter
             * @memberof google.longrunning.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.filter = "";

            /**
             * ListOperationsRequest pageSize.
             * @member {number} pageSize
             * @memberof google.longrunning.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.pageSize = 0;

            /**
             * ListOperationsRequest pageToken.
             * @member {string} pageToken
             * @memberof google.longrunning.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.pageToken = "";

            /**
             * Creates a new ListOperationsRequest instance using the specified properties.
             * @function create
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {google.longrunning.IListOperationsRequest=} [properties] Properties to set
             * @returns {google.longrunning.ListOperationsRequest} ListOperationsRequest instance
             */
            ListOperationsRequest.create = function create(properties) {
                return new ListOperationsRequest(properties);
            };

            /**
             * Encodes the specified ListOperationsRequest message. Does not implicitly {@link google.longrunning.ListOperationsRequest.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {google.longrunning.IListOperationsRequest} message ListOperationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.filter);
                if (message.pageSize != null && Object.hasOwnProperty.call(message, "pageSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pageSize);
                if (message.pageToken != null && Object.hasOwnProperty.call(message, "pageToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.pageToken);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified ListOperationsRequest message, length delimited. Does not implicitly {@link google.longrunning.ListOperationsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {google.longrunning.IListOperationsRequest} message ListOperationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListOperationsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.ListOperationsRequest} ListOperationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.ListOperationsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 4: {
                            message.name = reader.string();
                            break;
                        }
                    case 1: {
                            message.filter = reader.string();
                            break;
                        }
                    case 2: {
                            message.pageSize = reader.int32();
                            break;
                        }
                    case 3: {
                            message.pageToken = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListOperationsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.ListOperationsRequest} ListOperationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListOperationsRequest message.
             * @function verify
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListOperationsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.filter != null && message.hasOwnProperty("filter"))
                    if (!$util.isString(message.filter))
                        return "filter: string expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize))
                        return "pageSize: integer expected";
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    if (!$util.isString(message.pageToken))
                        return "pageToken: string expected";
                return null;
            };

            /**
             * Creates a ListOperationsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.ListOperationsRequest} ListOperationsRequest
             */
            ListOperationsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.ListOperationsRequest)
                    return object;
                let message = new $root.google.longrunning.ListOperationsRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.filter != null)
                    message.filter = String(object.filter);
                if (object.pageSize != null)
                    message.pageSize = object.pageSize | 0;
                if (object.pageToken != null)
                    message.pageToken = String(object.pageToken);
                return message;
            };

            /**
             * Creates a plain object from a ListOperationsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {google.longrunning.ListOperationsRequest} message ListOperationsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListOperationsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.filter = "";
                    object.pageSize = 0;
                    object.pageToken = "";
                    object.name = "";
                }
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = message.filter;
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    object.pageSize = message.pageSize;
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    object.pageToken = message.pageToken;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this ListOperationsRequest to JSON.
             * @function toJSON
             * @memberof google.longrunning.ListOperationsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListOperationsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ListOperationsRequest
             * @function getTypeUrl
             * @memberof google.longrunning.ListOperationsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ListOperationsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.ListOperationsRequest";
            };

            return ListOperationsRequest;
        })();

        longrunning.ListOperationsResponse = (function() {

            /**
             * Properties of a ListOperationsResponse.
             * @memberof google.longrunning
             * @interface IListOperationsResponse
             * @property {Array.<google.longrunning.IOperation>|null} [operations] ListOperationsResponse operations
             * @property {string|null} [nextPageToken] ListOperationsResponse nextPageToken
             */

            /**
             * Constructs a new ListOperationsResponse.
             * @memberof google.longrunning
             * @classdesc Represents a ListOperationsResponse.
             * @implements IListOperationsResponse
             * @constructor
             * @param {google.longrunning.IListOperationsResponse=} [properties] Properties to set
             */
            function ListOperationsResponse(properties) {
                this.operations = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListOperationsResponse operations.
             * @member {Array.<google.longrunning.IOperation>} operations
             * @memberof google.longrunning.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.operations = $util.emptyArray;

            /**
             * ListOperationsResponse nextPageToken.
             * @member {string} nextPageToken
             * @memberof google.longrunning.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.nextPageToken = "";

            /**
             * Creates a new ListOperationsResponse instance using the specified properties.
             * @function create
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {google.longrunning.IListOperationsResponse=} [properties] Properties to set
             * @returns {google.longrunning.ListOperationsResponse} ListOperationsResponse instance
             */
            ListOperationsResponse.create = function create(properties) {
                return new ListOperationsResponse(properties);
            };

            /**
             * Encodes the specified ListOperationsResponse message. Does not implicitly {@link google.longrunning.ListOperationsResponse.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {google.longrunning.IListOperationsResponse} message ListOperationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operations != null && message.operations.length)
                    for (let i = 0; i < message.operations.length; ++i)
                        $root.google.longrunning.Operation.encode(message.operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
                return writer;
            };

            /**
             * Encodes the specified ListOperationsResponse message, length delimited. Does not implicitly {@link google.longrunning.ListOperationsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {google.longrunning.IListOperationsResponse} message ListOperationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListOperationsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.ListOperationsResponse} ListOperationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.ListOperationsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.operations && message.operations.length))
                                message.operations = [];
                            message.operations.push($root.google.longrunning.Operation.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.nextPageToken = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListOperationsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.ListOperationsResponse} ListOperationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListOperationsResponse message.
             * @function verify
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListOperationsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operations != null && message.hasOwnProperty("operations")) {
                    if (!Array.isArray(message.operations))
                        return "operations: array expected";
                    for (let i = 0; i < message.operations.length; ++i) {
                        let error = $root.google.longrunning.Operation.verify(message.operations[i]);
                        if (error)
                            return "operations." + error;
                    }
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    if (!$util.isString(message.nextPageToken))
                        return "nextPageToken: string expected";
                return null;
            };

            /**
             * Creates a ListOperationsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.ListOperationsResponse} ListOperationsResponse
             */
            ListOperationsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.ListOperationsResponse)
                    return object;
                let message = new $root.google.longrunning.ListOperationsResponse();
                if (object.operations) {
                    if (!Array.isArray(object.operations))
                        throw TypeError(".google.longrunning.ListOperationsResponse.operations: array expected");
                    message.operations = [];
                    for (let i = 0; i < object.operations.length; ++i) {
                        if (typeof object.operations[i] !== "object")
                            throw TypeError(".google.longrunning.ListOperationsResponse.operations: object expected");
                        message.operations[i] = $root.google.longrunning.Operation.fromObject(object.operations[i]);
                    }
                }
                if (object.nextPageToken != null)
                    message.nextPageToken = String(object.nextPageToken);
                return message;
            };

            /**
             * Creates a plain object from a ListOperationsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {google.longrunning.ListOperationsResponse} message ListOperationsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListOperationsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.operations = [];
                if (options.defaults)
                    object.nextPageToken = "";
                if (message.operations && message.operations.length) {
                    object.operations = [];
                    for (let j = 0; j < message.operations.length; ++j)
                        object.operations[j] = $root.google.longrunning.Operation.toObject(message.operations[j], options);
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    object.nextPageToken = message.nextPageToken;
                return object;
            };

            /**
             * Converts this ListOperationsResponse to JSON.
             * @function toJSON
             * @memberof google.longrunning.ListOperationsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListOperationsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ListOperationsResponse
             * @function getTypeUrl
             * @memberof google.longrunning.ListOperationsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ListOperationsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.ListOperationsResponse";
            };

            return ListOperationsResponse;
        })();

        longrunning.CancelOperationRequest = (function() {

            /**
             * Properties of a CancelOperationRequest.
             * @memberof google.longrunning
             * @interface ICancelOperationRequest
             * @property {string|null} [name] CancelOperationRequest name
             */

            /**
             * Constructs a new CancelOperationRequest.
             * @memberof google.longrunning
             * @classdesc Represents a CancelOperationRequest.
             * @implements ICancelOperationRequest
             * @constructor
             * @param {google.longrunning.ICancelOperationRequest=} [properties] Properties to set
             */
            function CancelOperationRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CancelOperationRequest name.
             * @member {string} name
             * @memberof google.longrunning.CancelOperationRequest
             * @instance
             */
            CancelOperationRequest.prototype.name = "";

            /**
             * Creates a new CancelOperationRequest instance using the specified properties.
             * @function create
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {google.longrunning.ICancelOperationRequest=} [properties] Properties to set
             * @returns {google.longrunning.CancelOperationRequest} CancelOperationRequest instance
             */
            CancelOperationRequest.create = function create(properties) {
                return new CancelOperationRequest(properties);
            };

            /**
             * Encodes the specified CancelOperationRequest message. Does not implicitly {@link google.longrunning.CancelOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {google.longrunning.ICancelOperationRequest} message CancelOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified CancelOperationRequest message, length delimited. Does not implicitly {@link google.longrunning.CancelOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {google.longrunning.ICancelOperationRequest} message CancelOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CancelOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.CancelOperationRequest} CancelOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.CancelOperationRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CancelOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.CancelOperationRequest} CancelOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CancelOperationRequest message.
             * @function verify
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CancelOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a CancelOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.CancelOperationRequest} CancelOperationRequest
             */
            CancelOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.CancelOperationRequest)
                    return object;
                let message = new $root.google.longrunning.CancelOperationRequest();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a CancelOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {google.longrunning.CancelOperationRequest} message CancelOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this CancelOperationRequest to JSON.
             * @function toJSON
             * @memberof google.longrunning.CancelOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CancelOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CancelOperationRequest
             * @function getTypeUrl
             * @memberof google.longrunning.CancelOperationRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CancelOperationRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.CancelOperationRequest";
            };

            return CancelOperationRequest;
        })();

        longrunning.DeleteOperationRequest = (function() {

            /**
             * Properties of a DeleteOperationRequest.
             * @memberof google.longrunning
             * @interface IDeleteOperationRequest
             * @property {string|null} [name] DeleteOperationRequest name
             */

            /**
             * Constructs a new DeleteOperationRequest.
             * @memberof google.longrunning
             * @classdesc Represents a DeleteOperationRequest.
             * @implements IDeleteOperationRequest
             * @constructor
             * @param {google.longrunning.IDeleteOperationRequest=} [properties] Properties to set
             */
            function DeleteOperationRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteOperationRequest name.
             * @member {string} name
             * @memberof google.longrunning.DeleteOperationRequest
             * @instance
             */
            DeleteOperationRequest.prototype.name = "";

            /**
             * Creates a new DeleteOperationRequest instance using the specified properties.
             * @function create
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {google.longrunning.IDeleteOperationRequest=} [properties] Properties to set
             * @returns {google.longrunning.DeleteOperationRequest} DeleteOperationRequest instance
             */
            DeleteOperationRequest.create = function create(properties) {
                return new DeleteOperationRequest(properties);
            };

            /**
             * Encodes the specified DeleteOperationRequest message. Does not implicitly {@link google.longrunning.DeleteOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {google.longrunning.IDeleteOperationRequest} message DeleteOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified DeleteOperationRequest message, length delimited. Does not implicitly {@link google.longrunning.DeleteOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {google.longrunning.IDeleteOperationRequest} message DeleteOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.DeleteOperationRequest} DeleteOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.DeleteOperationRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.DeleteOperationRequest} DeleteOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteOperationRequest message.
             * @function verify
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a DeleteOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.DeleteOperationRequest} DeleteOperationRequest
             */
            DeleteOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.DeleteOperationRequest)
                    return object;
                let message = new $root.google.longrunning.DeleteOperationRequest();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a DeleteOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {google.longrunning.DeleteOperationRequest} message DeleteOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this DeleteOperationRequest to JSON.
             * @function toJSON
             * @memberof google.longrunning.DeleteOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteOperationRequest
             * @function getTypeUrl
             * @memberof google.longrunning.DeleteOperationRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteOperationRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.DeleteOperationRequest";
            };

            return DeleteOperationRequest;
        })();

        longrunning.WaitOperationRequest = (function() {

            /**
             * Properties of a WaitOperationRequest.
             * @memberof google.longrunning
             * @interface IWaitOperationRequest
             * @property {string|null} [name] WaitOperationRequest name
             * @property {google.protobuf.IDuration|null} [timeout] WaitOperationRequest timeout
             */

            /**
             * Constructs a new WaitOperationRequest.
             * @memberof google.longrunning
             * @classdesc Represents a WaitOperationRequest.
             * @implements IWaitOperationRequest
             * @constructor
             * @param {google.longrunning.IWaitOperationRequest=} [properties] Properties to set
             */
            function WaitOperationRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WaitOperationRequest name.
             * @member {string} name
             * @memberof google.longrunning.WaitOperationRequest
             * @instance
             */
            WaitOperationRequest.prototype.name = "";

            /**
             * WaitOperationRequest timeout.
             * @member {google.protobuf.IDuration|null|undefined} timeout
             * @memberof google.longrunning.WaitOperationRequest
             * @instance
             */
            WaitOperationRequest.prototype.timeout = null;

            /**
             * Creates a new WaitOperationRequest instance using the specified properties.
             * @function create
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {google.longrunning.IWaitOperationRequest=} [properties] Properties to set
             * @returns {google.longrunning.WaitOperationRequest} WaitOperationRequest instance
             */
            WaitOperationRequest.create = function create(properties) {
                return new WaitOperationRequest(properties);
            };

            /**
             * Encodes the specified WaitOperationRequest message. Does not implicitly {@link google.longrunning.WaitOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {google.longrunning.IWaitOperationRequest} message WaitOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                    $root.google.protobuf.Duration.encode(message.timeout, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WaitOperationRequest message, length delimited. Does not implicitly {@link google.longrunning.WaitOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {google.longrunning.IWaitOperationRequest} message WaitOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WaitOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.WaitOperationRequest} WaitOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.WaitOperationRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.timeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WaitOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.WaitOperationRequest} WaitOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WaitOperationRequest message.
             * @function verify
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WaitOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.timeout != null && message.hasOwnProperty("timeout")) {
                    let error = $root.google.protobuf.Duration.verify(message.timeout);
                    if (error)
                        return "timeout." + error;
                }
                return null;
            };

            /**
             * Creates a WaitOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.WaitOperationRequest} WaitOperationRequest
             */
            WaitOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.WaitOperationRequest)
                    return object;
                let message = new $root.google.longrunning.WaitOperationRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.timeout != null) {
                    if (typeof object.timeout !== "object")
                        throw TypeError(".google.longrunning.WaitOperationRequest.timeout: object expected");
                    message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                }
                return message;
            };

            /**
             * Creates a plain object from a WaitOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {google.longrunning.WaitOperationRequest} message WaitOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WaitOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.timeout = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                return object;
            };

            /**
             * Converts this WaitOperationRequest to JSON.
             * @function toJSON
             * @memberof google.longrunning.WaitOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WaitOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WaitOperationRequest
             * @function getTypeUrl
             * @memberof google.longrunning.WaitOperationRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WaitOperationRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.WaitOperationRequest";
            };

            return WaitOperationRequest;
        })();

        longrunning.OperationInfo = (function() {

            /**
             * Properties of an OperationInfo.
             * @memberof google.longrunning
             * @interface IOperationInfo
             * @property {string|null} [responseType] OperationInfo responseType
             * @property {string|null} [metadataType] OperationInfo metadataType
             */

            /**
             * Constructs a new OperationInfo.
             * @memberof google.longrunning
             * @classdesc Represents an OperationInfo.
             * @implements IOperationInfo
             * @constructor
             * @param {google.longrunning.IOperationInfo=} [properties] Properties to set
             */
            function OperationInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OperationInfo responseType.
             * @member {string} responseType
             * @memberof google.longrunning.OperationInfo
             * @instance
             */
            OperationInfo.prototype.responseType = "";

            /**
             * OperationInfo metadataType.
             * @member {string} metadataType
             * @memberof google.longrunning.OperationInfo
             * @instance
             */
            OperationInfo.prototype.metadataType = "";

            /**
             * Creates a new OperationInfo instance using the specified properties.
             * @function create
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {google.longrunning.IOperationInfo=} [properties] Properties to set
             * @returns {google.longrunning.OperationInfo} OperationInfo instance
             */
            OperationInfo.create = function create(properties) {
                return new OperationInfo(properties);
            };

            /**
             * Encodes the specified OperationInfo message. Does not implicitly {@link google.longrunning.OperationInfo.verify|verify} messages.
             * @function encode
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {google.longrunning.IOperationInfo} message OperationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.responseType != null && Object.hasOwnProperty.call(message, "responseType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.responseType);
                if (message.metadataType != null && Object.hasOwnProperty.call(message, "metadataType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.metadataType);
                return writer;
            };

            /**
             * Encodes the specified OperationInfo message, length delimited. Does not implicitly {@link google.longrunning.OperationInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {google.longrunning.IOperationInfo} message OperationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OperationInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.longrunning.OperationInfo} OperationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.longrunning.OperationInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.responseType = reader.string();
                            break;
                        }
                    case 2: {
                            message.metadataType = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OperationInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.longrunning.OperationInfo} OperationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OperationInfo message.
             * @function verify
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OperationInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.responseType != null && message.hasOwnProperty("responseType"))
                    if (!$util.isString(message.responseType))
                        return "responseType: string expected";
                if (message.metadataType != null && message.hasOwnProperty("metadataType"))
                    if (!$util.isString(message.metadataType))
                        return "metadataType: string expected";
                return null;
            };

            /**
             * Creates an OperationInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.longrunning.OperationInfo} OperationInfo
             */
            OperationInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.longrunning.OperationInfo)
                    return object;
                let message = new $root.google.longrunning.OperationInfo();
                if (object.responseType != null)
                    message.responseType = String(object.responseType);
                if (object.metadataType != null)
                    message.metadataType = String(object.metadataType);
                return message;
            };

            /**
             * Creates a plain object from an OperationInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {google.longrunning.OperationInfo} message OperationInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OperationInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.responseType = "";
                    object.metadataType = "";
                }
                if (message.responseType != null && message.hasOwnProperty("responseType"))
                    object.responseType = message.responseType;
                if (message.metadataType != null && message.hasOwnProperty("metadataType"))
                    object.metadataType = message.metadataType;
                return object;
            };

            /**
             * Converts this OperationInfo to JSON.
             * @function toJSON
             * @memberof google.longrunning.OperationInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OperationInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OperationInfo
             * @function getTypeUrl
             * @memberof google.longrunning.OperationInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OperationInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.longrunning.OperationInfo";
            };

            return OperationInfo;
        })();

        return longrunning;
    })();

    google.rpc = (function() {

        /**
         * Namespace rpc.
         * @memberof google
         * @namespace
         */
        const rpc = {};

        rpc.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof google.rpc
             * @interface IStatus
             * @property {number|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {Array.<google.protobuf.IAny>|null} [details] Status details
             */

            /**
             * Constructs a new Status.
             * @memberof google.rpc
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {google.rpc.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                this.details = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {number} code
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status details.
             * @member {Array.<google.protobuf.IAny>} details
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.details = $util.emptyArray;

            /**
             * Creates a new Status instance using the specified properties.
             * @function create
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.IStatus=} [properties] Properties to set
             * @returns {google.rpc.Status} Status instance
             */
            Status.create = function create(properties) {
                return new Status(properties);
            };

            /**
             * Encodes the specified Status message. Does not implicitly {@link google.rpc.Status.verify|verify} messages.
             * @function encode
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.details != null && message.details.length)
                    for (let i = 0; i < message.details.length; ++i)
                        $root.google.protobuf.Any.encode(message.details[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Status message, length delimited. Does not implicitly {@link google.rpc.Status.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Status message from the specified reader or buffer.
             * @function decode
             * @memberof google.rpc.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.rpc.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.rpc.Status();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.message = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.details && message.details.length))
                                message.details = [];
                            message.details.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Status message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.rpc.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.rpc.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isInteger(message.code))
                        return "code: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.details != null && message.hasOwnProperty("details")) {
                    if (!Array.isArray(message.details))
                        return "details: array expected";
                    for (let i = 0; i < message.details.length; ++i) {
                        let error = $root.google.protobuf.Any.verify(message.details[i]);
                        if (error)
                            return "details." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.rpc.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.google.rpc.Status)
                    return object;
                let message = new $root.google.rpc.Status();
                if (object.code != null)
                    message.code = object.code | 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.details) {
                    if (!Array.isArray(object.details))
                        throw TypeError(".google.rpc.Status.details: array expected");
                    message.details = [];
                    for (let i = 0; i < object.details.length; ++i) {
                        if (typeof object.details[i] !== "object")
                            throw TypeError(".google.rpc.Status.details: object expected");
                        message.details[i] = $root.google.protobuf.Any.fromObject(object.details[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.details = [];
                if (options.defaults) {
                    object.code = 0;
                    object.message = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.details && message.details.length) {
                    object.details = [];
                    for (let j = 0; j < message.details.length; ++j)
                        object.details[j] = $root.google.protobuf.Any.toObject(message.details[j], options);
                }
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof google.rpc.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Status
             * @function getTypeUrl
             * @memberof google.rpc.Status
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Status.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.rpc.Status";
            };

            return Status;
        })();

        return rpc;
    })();

    return google;
})();

export { $root as default };
